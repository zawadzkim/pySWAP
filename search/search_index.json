{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Welcome to the documentation of pySWAP. Vast majority of the content here related to the model variables comes from the template files of the original input files made by SWAP developers (can be previewed here), user manual (Kroes et al, 2017) and other documents shipped witht he software through SWAP website (link to the model website).</p>"},{"location":"#what_is_pyswap","title":"What is pySWAP?","text":"<p>pySWAP is a Python wrapper (not Python implementation) for the SWAP hydrological model developed at Wageningen University and Research. It simplifies the creation of input files, execution of the SWAP model, and analysis and visualization of results. Users can set up and document their models in Jupyter notebooks, enhancing transparency, collaboration, and facilitating community-supported debugging.</p> <p>Warning</p> <p>pySWAP is in the early stages of development so any contributions are highly encouraged. You can open issues, submit pull requests, or initiate discussions on GitHub. For more details on how you can contribute, visit the CONTRIBUTE section and get involved!</p> <p>Tip</p> <p>Just want to try it out? Skip to the Quick start.</p>"},{"location":"#why_was_pyswap_developed","title":"Why was pySWAP developed?","text":"<p>There are several packages to run SWAP model written in R, namely the rSWAP, SWAPTools and swap2r (links to forks provided). However, in the Python community using SWAP everybody was writing their own codes, resulting in repetetive work. pySWAP aims to provide a scaffolding for development of a complete Python interface for SWAP model to extend the range of users, potentially contributing the development of the fortran source code.</p>"},{"location":"#what_does_pyswap_offer_you","title":"What does pySWAP offer you?","text":"<ul> <li> <p> Python interface</p> <p>Interact with the SWAP model using intuitive object-oriented Python API</p> <p> Reference</p> </li> <li> <p> Input validation</p> <p>pySWAP uses Pydantic and Pandera validation frameworks to make sure   SWAP simulations run smoothly</p> </li> <li> <p> Markdown documentation</p> <p>This documentation is written in markdown allowing anyone to contribute</p> <p> See how</p> </li> <li> <p> Open Software - Open Science</p> <p>pySWAP is open-source with MIT license and aims at improving   transparency and sharability of modelling work</p> <p> License</p> </li> </ul>"},{"location":"blog/","title":"Blog","text":""},{"location":"blog/2024/06/12/welcome-to-pyswap-blog/","title":"Welcome to pySWAP blog","text":"<p>In this blog I will share my experiences with modelling of vadose zone processes, mostly using SWAP and pySWAP. Let's see where does it go from here!</p> <p>All contributions are welcome!</p>"},{"location":"reference/api-reference/","title":"API reference","text":"<p>Plotting functionality for pySWAP.</p> <p>Modules:</p> Name Description <code>evapotranspiration</code> <p>Functions for plotting evapotranspiration data.</p> <code>gwl</code> <p>Functions for plotting groundwater level data.</p> <code>watercontent</code> <p>Functions for plotting water content data.</p>"},{"location":"reference/api-reference/#pyswap.simsettings--simulation_settings","title":"Simulation settings","text":"<p>Main simulation settings for the SWAP model.</p> <p>Modules:</p> Name Description <code>general</code> <p>General simulation settings for the SWAP model.</p> <code>metadata</code> <p>Metadata for the SWAP model.</p> <code>richards</code> <p>Richards simulation settings for the SWAP model.</p>"},{"location":"reference/api-reference/#pyswap.simsettings.general","title":"<code>general</code>","text":""},{"location":"reference/api-reference/#pyswap.simsettings.general.GeneralSettings","title":"<code>GeneralSettings</code>","text":"<p>               Bases: <code>PySWAPBaseModel</code></p> <p>General settings of the simulation.</p> <p>Todo</p> <ul> <li>remove the individual file extension switches and replace with a list of extensions. Make the class     automatically generate the switches based on the list of extensions.</li> </ul> <p>Attributes:</p> Name Type Description <code>pathwork</code> <code>str</code> <p>Path to the working directory</p> <code>pathatm</code> <code>str</code> <p>Path to folder with weather files</p> <code>pathcrop</code> <code>str</code> <p>Path to folder with crop files</p> <code>pathdrain</code> <code>str</code> <p>Path to folder with drainage files</p> <code>swscre</code> <code>Literal[0, 1, 3]</code> <p>Switch, display progression of simulation run to screen</p> <code>swerror</code> <code>Literal[0, 1]</code> <p>Switch for printing errors to screen</p> <code>tstart</code> <code>date</code> <p>Start date of simulation run, give day-month-year</p> <code>tend</code> <code>date</code> <p>End date of simulation run, give day-month-year</p> <code>nprintday</code> <code>int</code> <p>Number of output times during a day</p> <code>swmonth</code> <code>Literal[0, 1]</code> <p>Switch, output each month</p> <code>swyrvar</code> <code>Literal[0, 1]</code> <p>Output times for overall water and solute balances in .BAL and .BLC file: choose output  at a fixed date each year or at different dates</p> <code>period</code> <code>Optional[int]</code> <p>Fixed output interval</p> <code>swres</code> <code>Optional[Literal[0, 1]]</code> <p>Switch, reset output interval counter each year</p> <code>swodat</code> <code>Optional[Literal[0, 1]]</code> <p>Switch, extra output dates are given in table below</p> <code>outdatin</code> <code>Optional[DateList]</code> <p>list of specific dates</p> <code>datefix</code> <code>Optional[DayMonth]</code> <p>fixed date for output</p> <code>outdat</code> <code>Optional[DateList]</code> <p>specify all output dates</p> <code>outfil</code> <code>str</code> <p>Generic file name of output files</p> <code>swheader</code> <code>Literal[0, 1]</code> <p>Print header at the start of each balance period</p> <code>swwba</code> <code>Literal[0, 1]</code> <p>Switch, output daily water balance</p> <code>swend</code> <code>Literal[0, 1]</code> <p>Switch, output end-conditions</p> <code>swvap</code> <code>Literal[0, 1]</code> <p>Switch, output soil profiles of moisture, solute and temperature</p> <code>swbal</code> <code>Literal[0, 1]</code> <p>Switch, output file with yearly water balance</p> <code>swblc</code> <code>Literal[0, 1]</code> <p>Switch, output file with detailed yearly water balance</p> <code>swsba</code> <code>Literal[0, 1]</code> <p>Switch, output file of daily solute balance</p> <code>swate</code> <code>Literal[0, 1]</code> <p>Switch, output file with soil temperature profiles</p> <code>swbma</code> <code>Literal[0, 1]</code> <p>Switch, output file with water fluxes, only for macropore flow</p> <code>swdrf</code> <code>Literal[0, 1]</code> <p>Switch, output of drainage fluxes, only for extended drainage</p> <code>swswb</code> <code>Literal[0, 1]</code> <p>Switch, output surface water reservoir, only for extended drainage</p> <code>swini</code> <code>Literal[0, 1]</code> <p>Switch, output of initial SoilPhysParam and HeatParam</p> <code>swinc</code> <code>Literal[0, 1]</code> <p>Switch, output of water balance increments</p> <code>swcrp</code> <code>Literal[0, 1]</code> <p>Switch, output of simple or detailed crop growth model</p> <code>swstr</code> <code>Literal[0, 1]</code> <p>Switch, output of stress values for wetness, drought, salinity and frost</p> <code>swirg</code> <code>Literal[0, 1]</code> <p>Switch, output of irrigation gifts</p> <code>swcsv</code> <code>Literal[0, 1]</code> <p>Switch, csv output</p> <code>inlist_csv</code> <code>Optional[StringList]</code> <p>list of variables for the csv output</p> <code>swcsv_tz</code> <code>Literal[0, 1]</code> <p>Switch, csv output with depth</p> <code>inlist_csv_tz</code> <code>Optional[StringList]</code> <p>list of variables for the csv tz output</p> <code>swafo</code> <code>Literal[0, 1, 2]</code> <p>Switch, output file with formatted hydrological data</p> <code>swaun</code> <code>Literal[0, 1, 2]</code> <p>Switch, output file with unformatted hydrological data</p> <code>critdevmasbal</code> <code>Optional[float]</code> <p>Critical Deviation in water balance during PERIOD</p> <code>swdiscrvert</code> <code>Literal[0, 1]</code> <p>Switch to convert vertical discretization</p> <code>numnodnew</code> <code>Optional[int]</code> <p>New number of nodes</p> <code>dznew</code> <code>Optional[FloatList]</code> <p>Thickness of compartments</p> Source code in <code>pyswap/simsettings/general.py</code> <pre><code>class GeneralSettings(PySWAPBaseModel):\n    \"\"\"General settings of the simulation.\n\n    !!! todo\n        * remove the individual file extension switches and replace with a list of extensions. Make the class\n            automatically generate the switches based on the list of extensions.\n\n    Attributes:\n        pathwork (str): Path to the working directory\n        pathatm (str): Path to folder with weather files\n        pathcrop (str): Path to folder with crop files\n        pathdrain (str): Path to folder with drainage files\n        swscre (Literal[0, 1, 3]): Switch, display progression of simulation run to screen\n        swerror (Literal[0, 1]): Switch for printing errors to screen\n        tstart (d): Start date of simulation run, give day-month-year\n        tend (d): End date of simulation run, give day-month-year\n        nprintday (int): Number of output times during a day\n        swmonth (Literal[0, 1]): Switch, output each month\n        swyrvar (Literal[0, 1]): Output times for overall water and solute balances in *.BAL and *.BLC file: choose output \n            at a fixed date each year or at different dates\n        period (Optional[int]): Fixed output interval\n        swres (Optional[Literal[0, 1]]): Switch, reset output interval counter each year\n        swodat (Optional[Literal[0, 1]]): Switch, extra output dates are given in table below\n        outdatin (Optional[DateList]): list of specific dates\n        datefix (Optional[DayMonth]): fixed date for output\n        outdat (Optional[DateList]): specify all output dates\n        outfil (str): Generic file name of output files\n        swheader (Literal[0, 1]): Print header at the start of each balance period\n        swwba (Literal[0, 1]): Switch, output daily water balance\n        swend (Literal[0, 1]): Switch, output end-conditions\n        swvap (Literal[0, 1]): Switch, output soil profiles of moisture, solute and temperature\n        swbal (Literal[0, 1]): Switch, output file with yearly water balance\n        swblc (Literal[0, 1]): Switch, output file with detailed yearly water balance\n        swsba (Literal[0, 1]): Switch, output file of daily solute balance\n        swate (Literal[0, 1]): Switch, output file with soil temperature profiles\n        swbma (Literal[0, 1]): Switch, output file with water fluxes, only for macropore flow\n        swdrf (Literal[0, 1]): Switch, output of drainage fluxes, only for extended drainage\n        swswb (Literal[0, 1]): Switch, output surface water reservoir, only for extended drainage\n        swini (Literal[0, 1]): Switch, output of initial SoilPhysParam and HeatParam\n        swinc (Literal[0, 1]): Switch, output of water balance increments\n        swcrp (Literal[0, 1]): Switch, output of simple or detailed crop growth model\n        swstr (Literal[0, 1]): Switch, output of stress values for wetness, drought, salinity and frost\n        swirg (Literal[0, 1]): Switch, output of irrigation gifts\n        swcsv (Literal[0, 1]): Switch, csv output\n        inlist_csv (Optional[StringList]): list of variables for the csv output\n        swcsv_tz (Literal[0, 1]): Switch, csv output with depth\n        inlist_csv_tz (Optional[StringList]): list of variables for the csv tz output\n        swafo (Literal[0, 1, 2]): Switch, output file with formatted hydrological data\n        swaun (Literal[0, 1, 2]): Switch, output file with unformatted hydrological data\n        critdevmasbal (Optional[float]): Critical Deviation in water balance during PERIOD\n        swdiscrvert (Literal[0, 1]): Switch to convert vertical discretization\n        numnodnew (Optional[int]): New number of nodes\n        dznew (Optional[FloatList]): Thickness of compartments\n    \"\"\"\n\n    pathwork: str = BASE_PATH\n    pathatm: str = BASE_PATH\n    pathcrop: str = BASE_PATH\n    pathdrain: str = BASE_PATH\n    swscre: Literal[0, 1, 3] = 0\n    swerror: Literal[0, 1] = 0\n\n    tstart: d  # convert this to DD-MM-YYYY\n    tend: d  # convert this to DD-MM-YYYY\n\n    nprintday: int = Field(default=1, ge=1, le=1440)\n    swmonth: Literal[0, 1] = 1\n    swyrvar: Literal[0, 1] = 0\n    # if swmonth is 0\n    period: Optional[int] = Field(default=None, **YEARRANGE)\n    swres: Optional[Literal[0, 1]] = None\n    swodat: Optional[Literal[0, 1]] = None\n    # if swyrvar is 1\n    outdatin: Optional[DateList] = None\n    datefix: Optional[DayMonth] = None\n    outdat: Optional[DateList] = None\n\n    outfil: str = \"result\"\n    swheader: Literal[0, 1] = 0\n    swwba: Literal[0, 1] = 0\n    swend: Literal[0, 1] = 0\n    swvap: Literal[0, 1] = 0\n    swbal: Literal[0, 1] = 0\n    swblc: Literal[0, 1] = 1\n    swsba: Literal[0, 1] = 0\n    swate: Literal[0, 1] = 0\n    swbma: Literal[0, 1] = 0\n    swdrf: Literal[0, 1] = 0\n    swswb: Literal[0, 1] = 0\n    swini: Literal[0, 1] = 0\n    swinc: Literal[0, 1] = 0\n    swcrp: Literal[0, 1] = 0\n    swstr: Literal[0, 1] = 0\n    swirg: Literal[0, 1] = 0\n    swcsv: Literal[0, 1] = 1\n    inlist_csv: Optional[StringList] = None\n    swcsv_tz: Literal[0, 1] = 0\n    inlist_csv_tz: Optional[StringList] = None\n    swafo: Literal[0, 1, 2] = 0\n    swaun: Literal[0, 1, 2] = 0\n    critdevmasbal: Optional[float] = Field(default=None, **UNITRANGE)\n    swdiscrvert: Literal[0, 1] = 0\n    numnodnew: Optional[int] = None\n    dznew: Optional[FloatList] = None\n\n    @model_validator(mode='after')\n    def _validate_model(self) -&gt; Self:\n\n        if not self.swmonth:\n            assert self.period is not None, \"period is required when swmonth is 0\"\n            assert self.swres is not None, \"swres is required when swmonth is 0\"\n            assert self.swodat is not None, \"swodat is required when swmonth is 0\"\n            if self.swodat:\n                assert self.outdatin is not None, \"outdatin is required when swodat is 1\"\n\n        if self.swyrvar:\n            assert self.outdat is not None, \"outdat is required when svyrvar is 1\"\n        else:\n            assert self.datefix is not None, \"datefix is required when swyrvar is 0\"\n\n        if self.swafo in [1, 2] or self.swaun in [1, 2]:\n            assert self.critdevmasbal is not None, \"critdevmasbal is required when SWAFO = 1 or 2 or SWAUN = 1 or 2\"\n            assert self.swdiscrvert, \"SWDISCRVERT is required when SWAFO = 1 or 2 or SWAUN = 1 or 2\"\n        if self.swdiscrvert:\n            assert self.numnodnew is not None, \"NUMNODNEW is required when SWDISCRVERT = 1\"\n            assert self.dznew is not None, \"DZNEW is required when SWDISCRVERT = 1\"\n\n        return self\n</code></pre>"},{"location":"reference/api-reference/#pyswap.simsettings.metadata","title":"<code>metadata</code>","text":"<p>Metadata class collecting basic information about the model.</p> <p>Classes:</p> Name Description <code>Metadata</code> <p>Metadata of a SWAP model.</p>"},{"location":"reference/api-reference/#pyswap.simsettings.metadata.Metadata","title":"<code>Metadata</code>","text":"<p>               Bases: <code>PySWAPBaseModel</code></p> <p>Metadata of a SWAP model.</p> <p>Attributes:</p> Name Type Description <code>author</code> <code>str</code> <p>Author of the model.</p> <code>institution</code> <code>str</code> <p>Institution of the author.</p> <code>email</code> <code>str</code> <p>Email of the author.</p> <code>project</code> <code>str</code> <p>Name of the project.</p> <code>swap_ver</code> <code>str</code> <p>Version of SWAP used.</p> <code>comment</code> <code>Optional[str]</code> <p>Comment about the model.</p> Source code in <code>pyswap/simsettings/metadata.py</code> <pre><code>class Metadata(PySWAPBaseModel):\n    \"\"\"Metadata of a SWAP model.\n\n    Attributes:\n        author (str): Author of the model.\n        institution (str): Institution of the author.\n        email (str): Email of the author.\n        project (str): Name of the project.\n        swap_ver (str): Version of SWAP used.\n        comment (Optional[str]): Comment about the model.\n    \"\"\"\n\n    author: str = Field(exclude=True)\n    institution: str = Field(exclude=True)\n    email: str = Field(exclude=True)\n    project: str\n    swap_ver: str = Field(exclude=True)\n    comment: Optional[str] = Field(default=None, exclude=True)\n</code></pre>"},{"location":"reference/api-reference/#pyswap.simsettings.richards","title":"<code>richards</code>","text":"<p>Settings for the Richards' equation with some reasonable defaults included.</p> <p>Classes:</p> Name Description <code>RichardsSettings</code> <p>Holds the settings for the Richards' equation.</p>"},{"location":"reference/api-reference/#pyswap.simsettings.richards.RichardsSettings","title":"<code>RichardsSettings</code>","text":"<p>               Bases: <code>PySWAPBaseModel</code></p> <p>Settings for the Richards' equation.</p> <p>Attributes:</p> Name Type Description <code>swkmean</code> <code>int</code> <p>Switch for averaging method of hydraulic conductivity</p> <code>swkimpl</code> <code>Literal[0, 1]</code> <p>Switch for updating hydraulic conductivity during iteration</p> <code>dtmin</code> <code>float</code> <p>Minimum timestep</p> <code>dtmax</code> <code>float</code> <p>Maximum timestep</p> <code>gwlconv</code> <code>float</code> <p>Maximum difference of groundwater level between time steps</p> <code>critdevh1cp</code> <code>float</code> <p>Maximum relative difference in pressure heads per compartment</p> <code>critdevh2cp</code> <code>float</code> <p>Maximum absolute difference in pressure heads per compartment</p> <code>critdevponddt</code> <code>float</code> <p>Maximum water balance error of ponding layer</p> <code>maxit</code> <code>int</code> <p>Maximum number of iteration cycles</p> <code>maxbacktr</code> <code>int</code> <p>Maximum number of back track cycles within an iteration cycle</p> Source code in <code>pyswap/simsettings/richards.py</code> <pre><code>class RichardsSettings(PySWAPBaseModel):\n    \"\"\"Settings for the Richards' equation.\n\n    Attributes:\n        swkmean (int): Switch for averaging method of hydraulic conductivity\n        swkimpl (Literal[0, 1]): Switch for updating hydraulic conductivity during iteration\n        dtmin (float): Minimum timestep\n        dtmax (float): Maximum timestep\n        gwlconv (float): Maximum difference of groundwater level between time steps\n        critdevh1cp (float): Maximum relative difference in pressure heads per compartment\n        critdevh2cp (float): Maximum absolute difference in pressure heads per compartment\n        critdevponddt (float): Maximum water balance error of ponding layer\n        maxit (int): Maximum number of iteration cycles\n        maxbacktr (int): Maximum number of back track cycles within an iteration cycle\n    \"\"\"\n\n    swkmean: int\n    swkimpl: Literal[0, 1]\n    dtmin: float = 0.000001\n    dtmax: float = 0.04\n    gwlconv: float = 100.0\n    critdevh1cp: float = 0.01\n    critdevh2cp: float = 0.1\n    critdevponddt: float = 0.0001\n    maxit: int = 30\n    maxbacktr: int = 3\n</code></pre>"},{"location":"reference/api-reference/#pyswap.atmosphere--atmosphere_subpackage","title":"Atmosphere subpackage","text":"<p>Meteorological settings and data for SWAP simulations.</p> <p>Modules:</p> Name Description <code>metfile</code> <p>meteorological data for SWAP simulations</p> <code>meteorology</code> <p>meteorological settings for SWAP simulations</p>"},{"location":"reference/api-reference/#pyswap.atmosphere.meteorology","title":"<code>meteorology</code>","text":"<p>Meteorological settings for SWAP simulations.</p> <p>Note</p> <p><code>Meteorology</code> object requires the <code>MetFile</code> object to be passed upon initialization. When the model is run, the <code>MetFile</code> object is saved to a .met file.</p> <p>Classes:</p> Name Description <code>Meteorology</code> <p>Holds the settings of the meteo section of the .swp file.</p>"},{"location":"reference/api-reference/#pyswap.atmosphere.meteorology.Meteorology","title":"<code>Meteorology</code>","text":"<p>               Bases: <code>PySWAPBaseModel</code></p> <p>Meteorological settings of the simulation.</p> <p>Attributes:</p> Name Type Description <code>lat</code> <code>float</code> <p>latitude of the meteo station [degrees].</p> <code>swetr</code> <code>int</code> <p>Switch type of weather data for potential evapotranspiration:</p> <ul> <li>0 - Use basic weather data and apply Penman-Monteith equation.</li> <li>1 - Use reference evapotranspiration data in combination with crop factors.</li> </ul> <code>swdivide</code> <code>int</code> <p>Switch for distribution of E and T. Defaults to 0:</p> <ul> <li>0 - Based on crop and soil factors.</li> <li>1 - Based on direct application of Penman-Monteith.</li> </ul> <code>swmetdetail</code> <code>int</code> <p>Switch for time interval of evapotranspiration and rainfall weather data:</p> <ul> <li>0 - Daily data.</li> <li>1 - Subdaily data.</li> </ul> <code>swrain</code> <code>int</code> <p>Switch for use of actual rainfall intensity, defaults to 0:</p> <ul> <li>0 - Use daily rainfall amounts.</li> <li>1 - Use daily rainfall amounts + mean intensity.</li> <li>2 - Use daily rainfall amounts + duration.</li> <li>3 - Use detailed rainfall records (dt &lt; 1 day), as supplied in separate file.</li> </ul> <code>swetsine</code> <code>int</code> <p>Switch, distribute daily Tp and Ep according to sinus wave, default to 0:</p> <ul> <li>0 - No distribution.</li> <li>1 - Distribute Tp and Ep according to sinus wave.</li> </ul> <code>metfile</code> <code>MetFile</code> <p>MetFile model containing meteorological data to be saved to .met file.</p> <code>alt</code> <code>float</code> <p>Altitude of the meteo station [m].</p> <code>altw</code> <code>float</code> <p>Altitude of the wind [m].</p> <code>angstroma</code> <code>float</code> <p>Fraction of extraterrestrial radiation reaching the earth on overcast days.</p> <code>angstromb</code> <code>float</code> <p>Additional fraction of extraterrestrial radiation reaching the earth on clear days.</p> <code>table_rainflux</code> <code>Table</code> <p>rainfall intensity RAINFLUX as function of time TIME.</p> <code>rainfil</code> <code>str</code> <p>file name of file with detailed rainfall data.</p> <code>nmetdetail</code> <code>int</code> <p>Number of weather data records each day.</p> <p>Methods:</p> Name Description <code>write_met</code> <p>Write the .met file.</p> Source code in <code>pyswap/atmosphere/meteorology.py</code> <pre><code>class Meteorology(PySWAPBaseModel):\n    \"\"\"Meteorological settings of the simulation.\n\n    Attributes:\n        lat (float): latitude of the meteo station [degrees].\n        swetr (int): Switch type of weather data for potential evapotranspiration:\n\n            * 0 - Use basic weather data and apply Penman-Monteith equation.\n            * 1 - Use reference evapotranspiration data in combination with crop factors.\n\n        swdivide (int): Switch for distribution of E and T. Defaults to 0:\n\n            * 0 - Based on crop and soil factors.\n            * 1 - Based on direct application of Penman-Monteith.\n\n        swmetdetail (int): Switch for time interval of evapotranspiration and rainfall weather data:\n\n            * 0 - Daily data.\n            * 1 - Subdaily data.\n\n        swrain (int): Switch for use of actual rainfall intensity, defaults to 0:\n\n            * 0 - Use daily rainfall amounts.\n            * 1 - Use daily rainfall amounts + mean intensity.\n            * 2 - Use daily rainfall amounts + duration.\n            * 3 - Use detailed rainfall records (dt &lt; 1 day), as supplied in separate file.\n\n        swetsine (int): Switch, distribute daily Tp and Ep according to sinus wave, default to 0:\n\n            * 0 - No distribution.\n            * 1 - Distribute Tp and Ep according to sinus wave.\n\n        metfile (MetFile): MetFile model containing meteorological data to be saved to .met file.\n        alt (float): Altitude of the meteo station [m].\n        altw (float): Altitude of the wind [m].\n        angstroma (float): Fraction of extraterrestrial radiation reaching the earth on overcast days.\n        angstromb (float): Additional fraction of extraterrestrial radiation reaching the earth on clear days.\n        table_rainflux (Table): rainfall intensity RAINFLUX as function of time TIME.\n        rainfil (str): file name of file with detailed rainfall data.\n        nmetdetail (int): Number of weather data records each day.\n\n    Methods:\n        write_met: Write the .met file.\n    \"\"\"\n\n    # metfil: str\n    lat: float = Field(ge=-90, le=90)\n    swetr: Literal[0, 1]\n    swdivide: Literal[0, 1]\n    # TODO: SWRAIN should be optional, but Fortran code evaluates its presence anyway\n    swrain: Optional[Literal[0, 1, 2, 3]] = 0\n    # TODO: SWETSINE should be optional, but Fortran code evaluates its presence anyway\n    swetsine: Literal[0, 1] = 0\n    metfile: Optional[MetFile] = Field(\n        default=None, repr=False)\n    alt: float = Field(ge=-400.0, le=3000.0)\n    altw: float = Field(default=None, ge=0.0, le=99.0)\n    angstroma: float = Field(default=None, **UNITRANGE)\n    angstromb: float = Field(default=None, **UNITRANGE)\n    swmetdetail: Optional[Literal[0, 1]] = None\n    table_rainflux: Optional[Table] = None\n    rainfil: Optional[str] = None\n    nmetdetail: Optional[int] = Field(default=None, ge=1, le=96)\n\n    @model_validator(mode='after')\n    def _validate_meteo_section(self) -&gt; Self:\n\n        if self.swetr == 1:  # if PM method is NOT used\n            assert self.swetsine is not None, \"SWETSINE is required when SWETR is 1\"\n            assert self.swrain is not None, \"SWRAIN is required when SWETR is 1\"\n            if self.swrain == 1:\n                assert self.table_rainflux is not None, \"RAINFLUX is required when SWRAIN is 1\"\n            elif self.swrain == 3:\n                assert self.rainfil, \"RAINFIL is required when SWRAIN is 3\"\n\n        else:\n            assert self.alt is not None, \"alt settings are required when SWETR is 0\"\n            assert self.altw is not None, \"altw settings are required when SWETR is 0\"\n            assert self.angstroma is not None, \"angstroma settings are required when SWETR is 0\"\n            assert self.angstromb is not None, \"angstromb settings are required when SWETR is 0\"\n            assert self.swmetdetail is not None, \"SWMETDETAIL is required when SWETR is 0\"\n            if self.swmetdetail == 1:\n                assert self.nmetdetail is not None, \"NMETDETAIL is required when SWMETDETAIL is 1\"\n\n        return self\n\n    def write_met(self, path: str):\n        \"\"\"Write the .met file.\n\n        !!! note\n\n            in this function the extension is not passed because\n            swp file requires the metfile parameter to be passed already with \n            the extension.\n\n        Parameters:\n            path (str): Path to the file.\n        \"\"\"\n        save_file(\n            string=self.metfile.content.to_csv(\n                index=False, lineterminator='\\n'),\n            fname=self.metfile.metfil,\n            path=path\n        )\n\n        print(f'{self.metfile.metfil} saved.')\n</code></pre>"},{"location":"reference/api-reference/#pyswap.atmosphere.meteorology.Meteorology.write_met","title":"<code>write_met(path)</code>","text":"<p>Write the .met file.</p> <p>Note</p> <p>in this function the extension is not passed because swp file requires the metfile parameter to be passed already with  the extension.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the file.</p> required Source code in <code>pyswap/atmosphere/meteorology.py</code> <pre><code>def write_met(self, path: str):\n    \"\"\"Write the .met file.\n\n    !!! note\n\n        in this function the extension is not passed because\n        swp file requires the metfile parameter to be passed already with \n        the extension.\n\n    Parameters:\n        path (str): Path to the file.\n    \"\"\"\n    save_file(\n        string=self.metfile.content.to_csv(\n            index=False, lineterminator='\\n'),\n        fname=self.metfile.metfil,\n        path=path\n    )\n\n    print(f'{self.metfile.metfil} saved.')\n</code></pre>"},{"location":"reference/api-reference/#pyswap.atmosphere.metfile","title":"<code>metfile</code>","text":"<p>Getting and formatting meteorological data for SWAP similation.</p> <p>Classes:</p> Name Description <code>MetFile</code> <p>meteorological data for the .met file</p> <p>Functions:</p> Name Description <code>load_from_csv</code> <p>loading meteorological data from a CSV file</p> <code>load_from_knmi</code> <p>retrieving meteorological data from KNMI API</p>"},{"location":"reference/api-reference/#pyswap.atmosphere.metfile.MetFile","title":"<code>MetFile</code>","text":"<p>               Bases: <code>PySWAPBaseModel</code></p> <p>Meteorological data for the .met file.</p> <p>This object is created by functions fetching or loading meteorological data from various sources. The data is stored as a pandas.DataFrame, but is formatted  with a custom field serializer of the CSVTable field type.</p> <p>Attributes:</p> Name Type Description <code>metfil</code> <code>str</code> <p>name of the .met file</p> <code>content</code> <code>CSVTable</code> <p>meteorological data file</p> Source code in <code>pyswap/atmosphere/metfile.py</code> <pre><code>class MetFile(PySWAPBaseModel):\n    \"\"\"Meteorological data for the .met file.\n\n    This object is created by functions fetching or loading meteorological data\n    from various sources. The data is stored as a pandas.DataFrame, but is formatted \n    with a custom field serializer of the CSVTable field type.\n\n    Attributes:\n        metfil (str): name of the .met file\n        content (CSVTable): meteorological data file\n    \"\"\"\n\n    metfil: str\n    content: Optional[CSVTable] = Field(default=None, exclude=True)\n</code></pre>"},{"location":"reference/api-reference/#pyswap.atmosphere.metfile.load_from_csv","title":"<code>load_from_csv(metfil, csv_path, **kwargs)</code>","text":"<p>Method for loading meteorological data from a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>metfil</code> <code>str</code> <p>name of the .met file</p> required <code>csv_path</code> <code>str</code> <p>path to the CSV file</p> required <code>**kwargs</code> <code>dict</code> <p>keyword arguments for pandas.read_csv</p> <code>{}</code> <p>Returns:</p> Type Description <code>MetFile</code> <p>MetFile object.</p> Source code in <code>pyswap/atmosphere/metfile.py</code> <pre><code>def load_from_csv(metfil: str, csv_path: str, **kwargs) -&gt; MetFile:\n    \"\"\"Method for loading meteorological data from a CSV file.\n\n    Parameters:\n        metfil (str): name of the .met file\n        csv_path (str): path to the CSV file\n        **kwargs (dict): keyword arguments for pandas.read_csv\n\n    Returns:\n        MetFile object.\n    \"\"\"\n\n    return MetFile(metfil=metfil, content=read_csv(csv_path, **kwargs))\n</code></pre>"},{"location":"reference/api-reference/#pyswap.atmosphere.metfile.load_from_knmi","title":"<code>load_from_knmi(metfil, stations, variables=['TEMP', 'PRCP', 'Q', 'UG', 'FG', 'UX', 'UN'], start='20000101', end='20200101', frequency='day', inseason=False)</code>","text":"<p>Retrieves the meteorological data from KNMI API using knmi-py.</p> <p>Parameters:</p> Name Type Description Default <code>metfil</code> <code>str</code> <p>name of the .met file</p> required <code>stations</code> <code>str | list</code> <p>station number(s) to retrieve data from</p> required <code>variables</code> <code>str | list</code> <p>variables to retrieve</p> <code>['TEMP', 'PRCP', 'Q', 'UG', 'FG', 'UX', 'UN']</code> <code>start</code> <code>str | datetime</code> <p>start date of the data</p> <code>'20000101'</code> <code>end</code> <code>str | datetime</code> <p>end date of the data</p> <code>'20200101'</code> <code>frequency</code> <code>Literal['day', 'hour']</code> <p>frequency of the data (day or hour)</p> <code>'day'</code> <code>inseason</code> <code>bool</code> <p>whether to retrieve in-season data</p> <code>False</code> <p>Returns:</p> Type Description <code>MetFile</code> <p>MetFile object.</p> Source code in <code>pyswap/atmosphere/metfile.py</code> <pre><code>def load_from_knmi(metfil: str,\n                   stations: str | list,\n                   variables: str | list = [\n                       'TEMP', 'PRCP', 'Q', 'UG',  'FG', 'UX', 'UN'],\n                   start: str | dt = '20000101',\n                   end: str | dt = '20200101',\n                   frequency: Literal['day', 'hour'] = 'day',\n                   inseason: bool = False) -&gt; MetFile:\n    \"\"\"Retrieves the meteorological data from KNMI API using knmi-py.\n\n    Parameters:\n        metfil (str): name of the .met file\n        stations (str | list): station number(s) to retrieve data from\n        variables (str | list): variables to retrieve\n        start (str | dt): start date of the data\n        end (str | dt): end date of the data\n        frequency (Literal['day', 'hour']): frequency of the data (day or hour)\n        inseason (bool): whether to retrieve in-season data\n\n    Returns:\n        MetFile object.\n    \"\"\"\n\n    if isinstance(stations, str):\n        stations = [stations]\n    if isinstance(variables, str):\n        variables = [variables]\n\n    get_func = get_day_data_dataframe if frequency == 'day' else get_hour_data_dataframe\n\n    df = get_func(stations=stations,\n                  start=start,\n                  end=end,\n                  variables=variables,\n                  inseason=inseason)\n\n    # rename some columns\n    required_column_names = {'STN': 'Station',\n                             'TN': 'Tmin',\n                             'TX': 'Tmax',\n                             'UG': 'HUM',\n                             'DR': 'WET',\n                             'FG': 'WIND',\n                             'RH': 'RAIN',\n                             'EV24': 'ETref',\n                             'Q': 'RAD'}\n\n    df = df.rename(columns=required_column_names)\n\n    # recalculation of the parameters\n    df[['Tmin', 'Tmax', 'ETref', 'RAIN', 'WIND']] = df[['Tmin', 'Tmax', 'ETref', 'RAIN',\n                                                                        'WIND']] * 0.1  # the original unit is 0.1 Unit\n    df['WET'] = df['WET'] * \\\n        0.1 * 24  # the required unit is days\n\n    return MetFile(metfil=metfil, content=df)\n</code></pre>"},{"location":"reference/api-reference/#pyswap.atmosphere.tables","title":"<code>tables</code>","text":""},{"location":"reference/api-reference/#pyswap.plant--plant_subpackage","title":"Plant subpackage","text":"<p>Crop settings and files for the SWAP simulation.</p> <p>Modules:</p> Name Description <code>crop</code> <p>The crop settings.</p> <code>crpfile</code> <p>The crop file.</p> <code>create_crp_tables</code> <p>Experimental module with functions to create crop tables.</p>"},{"location":"reference/api-reference/#pyswap.plant.crop","title":"<code>crop</code>","text":""},{"location":"reference/api-reference/#pyswap.plant.crop.Crop","title":"<code>Crop</code>","text":"<p>               Bases: <code>PySWAPBaseModel</code></p> <p>Holds the crop settings of the simulation.</p> <p>Attributes:</p> Name Type Description <code>swcrop</code> <code>int</code> <p>Switch for crop:</p> <ul> <li>0 - Bare soil.</li> <li>1 - Simulate crop.</li> </ul> <code>rds</code> <code>Optional[float]</code> <p>Rooting depth of the crop [cm].</p> <code>table_croprotation</code> <code>Optional[Table]</code> <p>Table with crop rotation data.</p> <code>cropfiles</code> <code>Optional[List[CropFile]]</code> <p>List of crop files.</p> <p>Methods:</p> Name Description <code>write_crop</code> <p>Write the crop files.</p> Source code in <code>pyswap/plant/crop.py</code> <pre><code>class Crop(PySWAPBaseModel):\n    \"\"\"Holds the crop settings of the simulation.\n\n    Attributes:\n        swcrop (int): Switch for crop:\n\n            * 0 - Bare soil.\n            * 1 - Simulate crop.\n\n        rds (Optional[float]): Rooting depth of the crop [cm].\n        table_croprotation (Optional[Table]): Table with crop rotation data.\n        cropfiles (Optional[List[CropFile]]): List of crop files.\n\n    Methods:\n        write_crop: Write the crop files.\n    \"\"\"\n\n    swcrop: Literal[0, 1]\n    rds: Optional[float] = Field(default=None, ge=1, le=5000)\n    table_croprotation: Optional[Table] = None\n    cropfiles: Optional[List[CropFile]] = Field(default=None, exclude=True)\n\n    def _validate_crop_section(self) -&gt; Self:\n        if self.swcrop == 1:\n            assert self.rds is not None, \"rds must be specified if swcrop is True\"\n            assert self.table_croprotation is not None, \"croprotation must be specified if swcrop is True\"\n\n        return self\n\n    def write_crop(self, path: str):\n        count = 0\n        for cropfile in self.cropfiles:\n            count += 1\n            save_file(\n                string=cropfile.content,\n                extension='crp',\n                fname=cropfile.name,\n                path=path\n            )\n\n        print(f'{count} crop file(s) saved.')\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.crpfile","title":"<code>crpfile</code>","text":"<p>Create .crp file for SWAP model.</p> <p>Similar to the .dra or .swp files, the .crp file is a configuration file for the SWAP model.  The classes in this module represent distincs sections of the .crp file. The main class is the <code>CropFile</code> class which holds the settings for the crop simulation.</p> <p>Classes:</p> Name Description <code>CropFile</code> <p>Class for the .crp file.</p> <code>CropDevelopmentSettings</code> <p>Class for the crop development settings.</p> <code>CropDevelopmentSettingsWOFOST</code> <p>Class for the crop development settings in WOFOST.</p> <code>CropDevelopmentSettingsFixed</code> <p>Class for the fixed crop development settings.</p> <code>OxygenStress</code> <p>Class for the oxygen stress settings.</p> <code>DroughtStress</code> <p>Class for the drought stress settings.</p> <code>SaltStress</code> <p>Class for the salt stress settings.</p> <code>CompensateRWUStress</code> <p>Class for the compensate root water uptake stress settings.</p> <code>Interception</code> <p>Class for the interception settings.</p> <code>CO2Correction</code> <p>Class for the CO2 correction settings.</p> <code>ScheduledIrrigation</code> <p>Class for the scheduled irrigation settings.</p> <code>Preparation</code> <p>Class for the preparation settings.</p> Warning <p>This script will undergo major changes in the future. Some things to improve include smoother integration with WOFOST configuration files (yaml) and code readability.</p>"},{"location":"reference/api-reference/#pyswap.plant.crpfile.CO2Correction","title":"<code>CO2Correction</code>","text":"<p>               Bases: <code>PySWAPBaseModel</code></p> <p>CO2 correction settings for WOFOST-type .crp file.</p> <p>Attributes:</p> Name Type Description <code>swco2</code> <code>Literal[0, 1]</code> <p>Switch for assimilation correction due to CO2 impact</p> <ul> <li>0 - No CO2 assimilation correction</li> <li>1 - CO2 assimilation correction</li> </ul> <code>atmofil</code> <code>Optional[str]</code> <p>alternative filename for atmosphere.co2</p> <code>co2amaxtb</code> <code>Optional[Arrays]</code> <p>Correction of photosynthesis as a function of atmospheric CO2 concentration</p> <code>co2efftb</code> <code>Optional[Arrays]</code> <p>orrection of radiation use efficiency as a function of atmospheric CO2 concentration</p> <code>co2tratb</code> <code>Optional[Arrays]</code> <p>Correction of transpiration as a function of atmospheric CO2 concentration</p> Source code in <code>pyswap/plant/crpfile.py</code> <pre><code>class CO2Correction(PySWAPBaseModel):\n    \"\"\"CO2 correction settings for WOFOST-type .crp file.\n\n    Attributes:\n        swco2 (Literal[0, 1]): Switch for assimilation correction due to CO2 impact\n\n            * 0 - No CO2 assimilation correction\n            * 1 - CO2 assimilation correction\n\n        atmofil (Optional[str]): alternative filename for atmosphere.co2\n        co2amaxtb (Optional[Arrays]): Correction of photosynthesis as a function of atmospheric CO2 concentration\n        co2efftb (Optional[Arrays]): orrection of radiation use efficiency as a function of atmospheric CO2 concentration\n        co2tratb (Optional[Arrays]): Correction of transpiration as a function of atmospheric CO2 concentration\n    \"\"\"\n\n    swco2: Literal[0, 1]\n    atmofil: Optional[str] = None\n    co2amaxtb: Optional[Arrays] = None\n    co2efftb: Optional[Arrays] = None\n    co2tratb: Optional[Arrays] = None\n\n    @model_validator(mode='after')\n    def _validate_co2correction(self) -&gt; Self:\n        if self.swco2 == 1:\n            assert self.atmofil is not None, 'amofil is required when swco2 is 1'\n            assert self.co2amaxtb is not None, 'co2amaxtb is required when swco2 is 1'\n            assert self.co2efftb is not None, 'co2efftb is required when swco2 is 1'\n            assert self.co2tratb is not None, 'co2tratb is required when swco2 is 1'\n\n        return self\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.crpfile.CompensateRWUStress","title":"<code>CompensateRWUStress</code>","text":"<p>               Bases: <code>PySWAPBaseModel</code></p> <p>Compensate root water uptake stress settings for .crp file.</p> <p>Attributes:</p> Name Type Description <code>swcompensate</code> <code>Literal[0, 1, 2]</code> <p>Switch for compensate root water uptake stress</p> <ul> <li>0 - No compensation</li> <li>1 - Compensation according to Jarvis (1989)</li> <li>2 - Compensation according to Walsum (2019)</li> </ul> <code>swstressor</code> <code>Optional[Literal[1, 2, 3, 4, 5]]</code> <p>Switch for stressor</p> <ul> <li>1 - Compensation of all stressors</li> <li>2 - Compensation of drought stress</li> <li>3 - Compensation of oxygen stress</li> <li>4 - Compensation of salinity stress</li> <li>5 - Compensation of frost stress</li> </ul> <code>alphacrit</code> <code>Optional[float]</code> <p>Critical stress index for compensation of root water uptake</p> <code>dcritrtz</code> <code>Optional[float]</code> <p>Threshold of rootzone thickness after which compensation occurs</p> Source code in <code>pyswap/plant/crpfile.py</code> <pre><code>class CompensateRWUStress(PySWAPBaseModel):\n    \"\"\"Compensate root water uptake stress settings for .crp file.\n\n    Attributes:\n        swcompensate (Literal[0, 1, 2]): Switch for compensate root water uptake stress\n\n            * 0 - No compensation\n            * 1 - Compensation according to Jarvis (1989)\n            * 2 - Compensation according to Walsum (2019)\n\n        swstressor (Optional[Literal[1, 2, 3, 4, 5]]): Switch for stressor\n\n            * 1 - Compensation of all stressors\n            * 2 - Compensation of drought stress\n            * 3 - Compensation of oxygen stress\n            * 4 - Compensation of salinity stress\n            * 5 - Compensation of frost stress\n\n        alphacrit (Optional[float]): Critical stress index for compensation of root water uptake\n        dcritrtz (Optional[float]): Threshold of rootzone thickness after which compensation occurs\n    \"\"\"\n    swcompensate: Literal[0, 1, 2]\n    swstressor: Optional[Literal[1, 2, 3, 4, 5]] = None\n    alphacrit: Optional[float] = Field(default=None, ge=0.2, le=1.0)\n    dcritrtz: Optional[float] = Field(default=None, ge=0.02, le=100.0)\n\n    @model_validator(mode='after')\n    def _validate_prepartion(self) -&gt; Self:\n        if self.swcompensate in [1, 2]:\n            assert self.swstressor is not None, \"swstressor is required when swcompensate is 1 or 2.\"\n        if self.swcompensate == 1:\n            assert self.alphacrit is not None, \"alphacrit is required when swcompensate is 1.\"\n        if self.swcompensate == 2:\n            assert self.dcritrtz is not None, \"dcritrtz is required when swcompensate is 2.\"\n\n        return self\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.crpfile.CropDevelopmentSettings","title":"<code>CropDevelopmentSettings</code>","text":"<p>               Bases: <code>PySWAPBaseModel</code></p> <p>Crop development settings (parts 1-xx form the template)</p> Note <p>The validation of this class should be optimized. The current implementation repeats the validation of the base class in each subclass. The observed issue is that when the validator is inherited from the base class and there is another validator in the subclass (even if they have different names), at the validation step of the child class the validator throws an error that the attribute is NoneType. To be fixed later.</p> <p>Attributes:</p> Name Type Description <code>swcf</code> <code>Literal[1, 2]</code> <p>Choose between crop factor and crop height</p> <ul> <li>1 - Crop factor</li> <li>2 - Crop height</li> </ul> <code>table_dvs_cf</code> <code>Optional[Table]</code> <p>Table with crop factors as a function of development stage</p> <code>table_dvs_ch</code> <code>Optional[Table]</code> <p>Table with crop height as a function of development stage</p> <code>albedo</code> <code>Optional[float]</code> <p>Crop reflection coefficient</p> <code>rsc</code> <code>Optional[float]</code> <p>Minimum canopy resistance</p> <code>rsw</code> <code>Optional[float]</code> <p>Canopy resistance of intercepted water</p> <code>tsumea</code> <code>float</code> <p>Temperature sum from emergence to anthesis</p> <code>tsumam</code> <code>float</code> <p>Temperature sum from anthesis to maturity</p> <code>tbase</code> <code>Optional[float]</code> <p>Start value of temperature sum</p> <code>kdif</code> <code>float</code> <p>Extinction coefficient for diffuse visible light</p> <code>kdir</code> <code>float</code> <p>Extinction coefficient for direct visible light</p> <code>swrd</code> <code>Optional[Literal[1, 2, 3]]</code> <p>Switch development of root growth</p> <ul> <li>1 - Root growth depends on development stage</li> <li>2 - Root growth depends on maximum daily increase</li> <li>3 - Root growth depends on available root biomass</li> </ul> <code>rdtb</code> <code>Optional[Arrays]</code> <p>Rooting Depth as a function of development stage</p> <code>rdi</code> <code>float</code> <p>Initial rooting depth</p> <code>rri</code> <code>float</code> <p>Maximum daily increase in rooting depth</p> <code>rdc</code> <code>float</code> <p>Maximum rooting depth of particular crop</p> <code>swdmi2rd</code> <code>Optional[Literal[0, 1]]</code> <p>Switch for calculation rooting depth</p> <ul> <li>0 - Rooting depth increase is related to availability assimilates for roots</li> <li>1 - Rooting depth increase is related to relative dry matter increase</li> </ul> <code>rlwtb</code> <code>Optional[Arrays]</code> <p>rooting depth as function of root weight</p> <code>wrtmax</code> <code>float</code> <p>Maximum root weight</p> <code>swrdc</code> <code>Literal[0, 1]</code> <p>Switch for calculation of relative root density</p> <code>rdctb</code> <code>Arrays</code> <p>root density as function of relative rooting depth</p> Source code in <code>pyswap/plant/crpfile.py</code> <pre><code>class CropDevelopmentSettings(PySWAPBaseModel):\n    \"\"\"Crop development settings (parts 1-xx form the template)\n\n    Note:\n        The validation of this class should be optimized. The current implementation\n        repeats the validation of the base class in each subclass. The observed issue is that\n        when the validator is inherited from the base class and there is another validator in the\n        subclass (even if they have different names), at the validation step of the child class the\n        validator throws an error that the attribute is NoneType. To be fixed later.\n\n    Attributes:\n        swcf (Literal[1, 2]): Choose between crop factor and crop height\n\n            * 1 - Crop factor\n            * 2 - Crop height\n\n        table_dvs_cf (Optional[Table]): Table with crop factors as a function of development stage\n        table_dvs_ch (Optional[Table]): Table with crop height as a function of development stage\n        albedo (Optional[float]): Crop reflection coefficient\n        rsc (Optional[float]): Minimum canopy resistance\n        rsw (Optional[float]): Canopy resistance of intercepted water\n        tsumea (float): Temperature sum from emergence to anthesis\n        tsumam (float): Temperature sum from anthesis to maturity\n        tbase (Optional[float]): Start value of temperature sum\n        kdif (float): Extinction coefficient for diffuse visible light\n        kdir (float): Extinction coefficient for direct visible light\n        swrd (Optional[Literal[1, 2, 3]]): Switch development of root growth\n\n            * 1 - Root growth depends on development stage\n            * 2 - Root growth depends on maximum daily increase\n            * 3 - Root growth depends on available root biomass\n\n        rdtb (Optional[Arrays]): Rooting Depth as a function of development stage\n        rdi (float): Initial rooting depth\n        rri (float): Maximum daily increase in rooting depth\n        rdc (float): Maximum rooting depth of particular crop\n        swdmi2rd (Optional[Literal[0, 1]]): Switch for calculation rooting depth\n\n            * 0 - Rooting depth increase is related to availability assimilates for roots\n            * 1 - Rooting depth increase is related to relative dry matter increase\n\n        rlwtb (Optional[Arrays]): rooting depth as function of root weight\n        wrtmax (float): Maximum root weight\n        swrdc (Literal[0, 1]): Switch for calculation of relative root density\n        rdctb (Arrays): root density as function of relative rooting depth\n    \"\"\"\n    swcf: Literal[1, 2]\n    table_dvs_cf: Optional[Table] = None\n    table_dvs_ch: Optional[Table] = None\n    albedo: Optional[float] = Field(default=None, **UNITRANGE)\n    rsc: Optional[float] = Field(default=None, ge=0.0, le=1.0e6)\n    rsw: Optional[float] = Field(default=None, ge=0.0, le=1.0e6)\n    # In WOFOST reference yaml files this is called TSUM1\n    tsumea: float = Field(default=None, ge=0.0, le=1.0e4)\n    # In WOFOST reference yaml files this is called TSUM2\n    tsumam: float = Field(default=None, ge=0.0, le=1.0e4)\n    # In SWAP this parameter seems to meen something different than in the\n    # WOFOST template. The range of value is the same though.\n    tbase: Optional[float] = Field(default=None, ge=-10.0, le=30.0)\n    kdif: float = Field(ge=0.0, le=2.0)\n    kdir: float = Field(ge=0.0, le=2.0)\n    swrd: Optional[Literal[1, 2, 3]] = None\n    rdtb: Optional[Arrays] = None\n    rdi: float = Field(default=None, ge=0.0, le=1000.0)\n    rri: float = Field(default=None, ge=0.0, le=100.0)\n    rdc: float = Field(default=None, ge=0.0, le=1000.0)\n    swdmi2rd: Optional[Literal[0, 1]] = None\n    rlwtb: Optional[Arrays] = None\n    wrtmax: float = Field(default=None, ge=0.0, le=1.0e5)\n    swrdc: Literal[0, 1] = 0\n    rdctb: Arrays\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.crpfile.CropDevelopmentSettingsFixed","title":"<code>CropDevelopmentSettingsFixed</code>","text":"<p>               Bases: <code>CropDevelopmentSettings</code></p> <p>Fixed crop development settings (parts 1-xx form the template)</p> Warning <p>This class is not complete. It is missing the validation.</p> Note <p>I noticed an issue with the tables here. They are actually arrays (each array is a column) that are preceeded by the variable name and \"=\". That variable name is the same for all options of tables which have different column names (e.g., DVS/LAI or DVS/SCF) but the variable name is the same (e.g., GCTB). TODO: implement a check of the column before the df is converted to string.</p> <p>Attributes:</p> Name Type Description <code>idev</code> <code>Literal[1, 2]</code> <p>Duration of crop growing period</p> <ul> <li>1 - Duration is fixed</li> <li>2 - Duration is variable</li> </ul> <code>lcc</code> <code>Optional[int]</code> <p>Duration of the crop growing period</p> <code>swgc</code> <code>Literal[1, 2]</code> <p>Choose between Leaf Area Index or Soil Cover Fraction</p> <ul> <li>1 - LAI</li> <li>2 - SCF</li> </ul> <code>gctb</code> <code>Arrays</code> <p>Soil Cover Fraction as a function of development stage</p> Source code in <code>pyswap/plant/crpfile.py</code> <pre><code>class CropDevelopmentSettingsFixed(CropDevelopmentSettings):\n    \"\"\"Fixed crop development settings (parts 1-xx form the template)\n\n    Warning:\n        This class is not complete. It is missing the validation.\n\n    Note:\n        I noticed an issue with the tables here. They are actually arrays (each\n        array is a column) that are preceeded by the variable name and \"=\". That variable\n        name is the same for all options of tables which have different column names (e.g., DVS/LAI or\n        DVS/SCF) but the variable name is the same (e.g., GCTB).\n        TODO: implement a check of the column before the df is converted to string.\n\n    Attributes:\n        idev (Literal[1, 2]): Duration of crop growing period\n\n            * 1 - Duration is fixed\n            * 2 - Duration is variable\n\n        lcc (Optional[int]): Duration of the crop growing period\n        swgc (Literal[1, 2]): Choose between Leaf Area Index or Soil Cover Fraction\n\n            * 1 - LAI\n            * 2 - SCF\n\n        gctb (Arrays): Soil Cover Fraction as a function of development stage\n    \"\"\"\n\n    idev: Literal[1, 2]\n    lcc: Optional[int] = Field(default=None, **YEARRANGE)\n    swgc: Literal[1, 2]\n    gctb: Arrays\n    kytb: Optional[Arrays] = None\n\n    @model_validator(mode='after')\n    def _validate_crop_fixed(self) -&gt; Self:\n        # validation of the base class\n        if self.swcf == 1:\n            assert self.table_dvs_cf is not None, \"table_dvs_cf is required when swcf is 1.\"\n        elif self.swcf == 2:\n            assert self.table_dvs_ch is not None, \"table_dvs_ch is required when swcf is 2.\"\n            assert self.albedo is not None, \"albedo is required when swcf is 2.\"\n            assert self.rsc is not None, \"rsc is required when swcf is 2.\"\n            assert self.rsw is not None, \"rsw is required when swcf is 2.\"\n        if self.swrd == 1:\n            assert self.rdtb is not None, \"rdtb is required when swrd is 1.\"\n        elif self.swrd == 2:\n            assert self.rdi is not None, \"rdi is required when swrd is 2.\"\n            assert self.rri is not None, \"rri is required when swrd is 2.\"\n            assert self.rdc is not None, \"rdc is required when swrd is 2.\"\n            assert self.swdmi2rd is not None, \"swdmi2rd is required when swrd is 2.\"\n        elif self.swrd == 3:\n            assert self.rlwtb is not None, \"rlwtb is required when swrd is 3.\"\n            assert self.wrtmax is not None, \"wrtmax is required when swrd is 3.\"\n        # validation specific to the fixed crop development settings\n        if self.idev == 1:\n            assert self.lcc is not None, \"lcc is required when idev is 1.\"\n        elif self.idev == 2:\n            assert self.tsumea is not None, \"tsumea is required when idev is 2.\"\n            assert self.tsumam is not None, \"tsumam is required when idev is 2.\"\n            assert self.tbase is not None, \"tbase is required when idev is 2.\"\n\n        return self\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.crpfile.CropDevelopmentSettingsGrass","title":"<code>CropDevelopmentSettingsGrass</code>","text":"<p>               Bases: <code>CropDevelopmentSettingsWOFOST</code></p> <p>Crop development settings specific to grass growth.</p> <p>Attributes:</p> Name Type Description <code>swtsum</code> <code>Literal[0, 1, 2]</code> <p>Select either sum air temperatures or soil temperature at particular depth</p> <ul> <li>0 - no delay of start grass growth</li> <li>1 - start of grass growth based on sum air temperatures &gt; 200 degree C</li> <li>2 - start of grass growth based on soil temperature at particular depth</li> </ul> <code>tsumtemp</code> <code>Optional[float]</code> <p>Specific stem area [0..1 ha/kg, R]</p> <code>tsumdepth</code> <code>Optional[float]</code> <p>Life span under leaves under optimum conditions [0..366 d, R]</p> <code>tsumtime</code> <code>Optional[float]</code> <p>Lower threshold temperature for ageing of leaves [-10..30 degree C, R]</p> Source code in <code>pyswap/plant/crpfile.py</code> <pre><code>class CropDevelopmentSettingsGrass(CropDevelopmentSettingsWOFOST):\n    \"\"\"Crop development settings specific to grass growth.\n\n    Attributes:\n        swtsum (Literal[0, 1, 2]): Select either sum air temperatures or soil temperature at particular depth\n\n            * 0 - no delay of start grass growth\n            * 1 - start of grass growth based on sum air temperatures &gt; 200 degree C\n            * 2 - start of grass growth based on soil temperature at particular depth\n\n        tsumtemp (Optional[float]): Specific stem area [0..1 ha/kg, R]\n        tsumdepth (Optional[float]): Life span under leaves under optimum conditions [0..366 d, R]\n        tsumtime (Optional[float]): Lower threshold temperature for ageing of leaves [-10..30 degree C, R]\n    \"\"\"\n    swtsum: Literal[0, 1, 2]\n    tsumtemp: Optional[float] = None\n    tsumdepth: Optional[float] = None\n    tsumtime: Optional[float] = None\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.crpfile.CropDevelopmentSettingsWOFOST","title":"<code>CropDevelopmentSettingsWOFOST</code>","text":"<p>               Bases: <code>CropDevelopmentSettings</code></p> <p>Additional settings for the </p> Warning <p>The validation for this class is not complete. Also check the Optional attributes!</p> Note <p>Use serialization_alias to change the parameter names who are different between WOFOST and SWAP.</p> <p>Attributes:</p> Name Type Description <code>idsl</code> <code>Literal[0, 1, 2]</code> <code>dtsmtb</code> <code>Arrays</code> <code>dlo</code> <code>Optional[float]</code> <code>dlc</code> <code>Optional[float]</code> <code>vernsat</code> <code>Optional[float]</code> <code>vernbase</code> <code>Optional[float]</code> <code>verndvs</code> <code>Optional[float]</code> <code>verntb</code> <code>Optional[Arrays]</code> <code>tdwi</code> <code>float</code> <code>laiem</code> <code>float</code> <code>rgrlai</code> <code>float</code> <code>spa</code> <code>float</code> <code>ssa</code> <code>float</code> <code>span</code> <code>float</code> <code>slatb</code> <code>Arrays</code> <code>eff</code> <code>float</code> <code>amaxtb</code> <code>Arrays</code> <code>tmpftb</code> <code>Arrays</code> <code>tmnftb</code> <code>Arrays</code> <code>cvo</code> <code>float</code> <code>cvl</code> <code>float</code> <code>cvr</code> <code>float</code> <code>cvs</code> <code>float</code> <code>q10</code> <code>float</code> <code>rml</code> <code>float</code> <code>rmo</code> <code>float</code> <code>rmr</code> <code>float</code> <code>rms</code> <code>float</code> <code>rfsetb</code> <code>Arrays</code> <code>frtb</code> <code>Arrays</code> <code>fltb</code> <code>Arrays</code> <code>fstb</code> <code>Arrays</code> <code>fotb</code> <code>Arrays</code> <code>perdl</code> <code>float</code> <code>rdrrtb</code> <code>Arrays</code> <code>rdrstb</code> <code>Arrays</code> Source code in <code>pyswap/plant/crpfile.py</code> <pre><code>class CropDevelopmentSettingsWOFOST(CropDevelopmentSettings):\n    \"\"\"Additional settings for the \n\n    Warning:\n        The validation for this class is not complete. Also check the Optional attributes!\n\n    Note:\n        Use serialization_alias to change the parameter names who are different between WOFOST and SWAP.\n\n    Attributes:\n        idsl (Literal[0, 1, 2]):\n        dtsmtb (Arrays):\n        dlo (Optional[float]):\n        dlc (Optional[float]):\n        vernsat (Optional[float]):\n        vernbase (Optional[float]):\n        verndvs (Optional[float]):\n        verntb (Optional[Arrays]):\n        tdwi (float):\n        laiem (float):\n        rgrlai (float):\n        spa (float):\n        ssa (float):\n        span (float):\n        slatb (Arrays):\n        eff (float):\n        amaxtb (Arrays):\n        tmpftb (Arrays):\n        tmnftb (Arrays):\n        cvo (float):\n        cvl (float):\n        cvr (float):\n        cvs (float):\n        q10 (float):\n        rml (float):\n        rmo (float):\n        rmr (float):\n        rms (float):\n        rfsetb (Arrays):\n        frtb (Arrays):\n        fltb (Arrays):\n        fstb (Arrays):\n        fotb (Arrays):\n        perdl (float):\n        rdrrtb (Arrays):\n        rdrstb (Arrays):\n    \"\"\"\n    idsl: Optional[Literal[0, 1, 2]] = None  # for grass at least\n    dtsmtb: Optional[Arrays] = None   # for grass at least\n    dlo: Optional[float] = Field(default=None, ge=0.0, le=24.0)\n    dlc: Optional[float] = Field(default=None, ge=0.0, le=24.0)\n    vernsat: Optional[float] = Field(default=None, ge=0.0, le=100.0)\n    vernbase: Optional[float] = Field(default=None, ge=0.0, le=100.0)\n    verndvs: Optional[float] = Field(default=None, ge=0.0, le=0.3)\n    verntb: Optional[Arrays] = None\n    tdwi: float = Field(ge=0.0, le=10_000)\n    laiem: float = Field(ge=0.0, le=10)\n    rgrlai: float = Field(**UNITRANGE)\n    spa: Optional[float] = Field(**UNITRANGE, default=None)\n    ssa: float = Field(**UNITRANGE)\n    span: float = Field(**YEARRANGE)\n    slatb: Arrays\n    eff:  float = Field(ge=0.0, le=10.0)\n    amaxtb: Arrays\n    tmpftb: Arrays\n    tmnftb: Arrays\n    cvo: Optional[float] = Field(\n        **UNITRANGE, default=None)  # for grass at least\n    cvl: float = Field(**UNITRANGE)\n    cvr: float = Field(**UNITRANGE)\n    cvs: float = Field(**UNITRANGE)\n    q10: float = Field(ge=0.0, le=5.0)\n    rml: float = Field(**UNITRANGE)\n    rmo: Optional[float] = Field(\n        **UNITRANGE, default=None)  # for grass at least\n    rmr: float = Field(**UNITRANGE)\n    rms: float = Field(**UNITRANGE)\n    rfsetb: Arrays\n    frtb: Arrays\n    fltb: Arrays\n    fstb: Arrays\n    fotb: Optional[Arrays] = None  # for grass at least\n    perdl: float = Field(ge=0.0, le=3.0)\n    rdrrtb: Arrays\n    rdrstb: Arrays\n\n    @model_validator(mode='after')\n    def _validate_crop_wofost(self) -&gt; Self:\n        # validation of the base class\n        if self.swcf == 1:\n            assert self.table_dvs_cf is not None, \"table_dvs_cf is required when swcf is 1.\"\n        elif self.swcf == 2:\n            assert self.table_dvs_ch is not None, \"table_dvs_ch is required when swcf is 2.\"\n            assert self.albedo is not None, \"albedo is required when swcf is 2.\"\n            assert self.rsc is not None, \"rsc is required when swcf is 2.\"\n            assert self.rsw is not None, \"rsw is required when swcf is 2.\"\n        if self.swrd == 1:\n            assert self.rdtb is not None, \"rdtb is required when swrd is 1.\"\n        elif self.swrd == 2:\n            assert self.rdi is not None, \"rdi is required when swrd is 2.\"\n            assert self.rri is not None, \"rri is required when swrd is 2.\"\n            assert self.rdc is not None, \"rdc is required when swrd is 2.\"\n            assert self.swdmi2rd is not None, \"swdmi2rd is required when swrd is 2.\"\n        elif self.swrd == 3:\n            assert self.rlwtb is not None, \"rlwtb is required when swrd is 3.\"\n            assert self.wrtmax is not None, \"wrtmax is required when swrd is 3.\"\n        # validation specific to the WOFOST crop development settings\n        if self.idsl in [1, 2]:\n            assert self.dlc is not None, \"dlc is required when idsl is either 1 or 2.\"\n            assert self.dlo is not None, \"dlo is required when idsl is either 1 or 2.\"\n        elif self.idsl == 2:\n            assert self.vernsat is not None, \"vernsat is required when idsl is 2.\"\n            assert self.vernbase is not None, \"vernbase is required when idsl is 2.\"\n            assert self.verndvs is not None, \"verndvs is required when idsl is 2.\"\n            assert self.verntb is not None, \"verntb is required when idsl is 2.\"\n\n        return self\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.crpfile.CropFile","title":"<code>CropFile</code>","text":"<p>               Bases: <code>PySWAPBaseModel</code></p> <p>Main class for the .crp file.</p> <p>This class collects all the settings for the crop file. Currently the types of the  attributes are set to Any because the validation is not yet implemented.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the crop</p> <code>path</code> <code>Optional[str]</code> <p>Path to the .crp file</p> <code>prep</code> <code>Optional[Preparation]</code> <p>Preparation settings</p> <code>oxygenstress</code> <code>Optional[OxygenStress]</code> <p>Oxygen stress settings</p> <code>droughtstress</code> <code>Optional[DroughtStress]</code> <p>Drought stress settings</p> <code>saltstress</code> <code>Optional[SaltStress]</code> <p>Salt stress settings</p> <code>compensaterwu</code> <code>Optional[CompensateRWUStress]</code> <p>Compensate root water uptake stress settings</p> <code>interception</code> <code>Optional[Interception]</code> <p>Interception settings</p> <code>scheduledirrigation</code> <code>Optional[ScheduledIrrigation]</code> <p>Scheduled irrigation settings</p> <code>grassland_management</code> <code>Optional[GrasslandManagement]</code> <p>Grassland management settings</p> Source code in <code>pyswap/plant/crpfile.py</code> <pre><code>class CropFile(PySWAPBaseModel):\n    \"\"\"Main class for the .crp file.\n\n    This class collects all the settings for the crop file. Currently the types of the \n    attributes are set to Any because the validation is not yet implemented.\n\n    Attributes:\n        name (str): Name of the crop\n        path (Optional[str]): Path to the .crp file\n        prep (Optional[Preparation]): Preparation settings\n        cropdev_settings (Optional[CropDevelopmentSettings | \n            CropDevelopmentSettingsFixed | \n            CropDevelopmentSettingsWOFOST]): Crop development settings\n        oxygenstress (Optional[OxygenStress]): Oxygen stress settings\n        droughtstress (Optional[DroughtStress]): Drought stress settings\n        saltstress (Optional[SaltStress]): Salt stress settings\n        compensaterwu (Optional[CompensateRWUStress]): Compensate root water uptake stress settings\n        interception (Optional[Interception]): Interception settings\n        scheduledirrigation (Optional[ScheduledIrrigation]): Scheduled irrigation settings\n        grassland_management (Optional[GrasslandManagement]): Grassland management settings\n    \"\"\"\n\n    name: str = Field(exclude=True)\n    path: Optional[str] = None\n    prep: Optional[Preparation] = None\n    cropdev_settings: Optional[CropDevelopmentSettings |\n                               CropDevelopmentSettingsFixed |\n                               CropDevelopmentSettingsWOFOST |\n                               CropDevelopmentSettingsGrass] = None\n    oxygenstress: Optional[OxygenStress] = None\n    droughtstress: Optional[DroughtStress] = None\n    saltstress: Optional[SaltStress] = SaltStress(swsalinity=0)\n    compensaterwu: Optional[CompensateRWUStress] = CompensateRWUStress(\n        swcompensate=0)\n    interception: Optional[Interception] = None\n    scheduledirrigation: Optional[ScheduledIrrigation] = ScheduledIrrigation(\n        schedule=0)\n    grasslandmanagement: Optional[GrasslandManagement] = None\n    co2correction: Optional[CO2Correction] = None\n\n    @computed_field(return_type=str)\n    def content(self):\n        if self.path:\n            return open_file(self.path)\n        else:\n            return self._concat_sections()\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.crpfile.DroughtStress","title":"<code>DroughtStress</code>","text":"<p>               Bases: <code>PySWAPBaseModel</code></p> <p>Drought stress settings for .crp file.</p> <p>Attributes:</p> Name Type Description <code>swdrought</code> <code>Literal[1, 2]</code> <p>Switch for drought stress</p> <ul> <li>1 - Drought stress according to Feddes et al. (1978)</li> <li>2 - rought stress according to De Jong van Lier et al. (2008)</li> </ul> <code>swjarvis</code> <code>Optional[Literal[0, 1, 2, 3, 4]]</code> <p>DEPRECATED Switch for Jarvis model for water uptake reduction</p> <code>alphcrit</code> <code>Optional[float]</code> <p>Optional[float] = DEPRECATED Critical stress index (Jarvis, 1989) for compensation of root water uptake [0.2..1 -, R]</p> <code>hlim3h</code> <code>Optional[float]</code> <p>Pressure head below which water uptake reduction starts at high Tpot</p> <code>hlim3l</code> <code>Optional[float]</code> <p>Pressure head below which water uptake reduction starts at low Tpot</p> <code>hlim4</code> <code>Optional[float]</code> <p>No water extraction at lower soil water pressure heads</p> <code>adcrh</code> <code>Optional[float]</code> <p>Level of high atmospheric demand, corresponding to HLIM3H</p> <code>adcrl</code> <code>Optional[float]</code> <p>Level of low atmospheric demand, corresponding to HLIM3L</p> <code>wiltpoint</code> <code>Optional[float]</code> <p>Minimum pressure head in leaves</p> <code>kstem</code> <code>Optional[float]</code> <p>Hydraulic conductance between leaf and root xylem</p> <code>rxylem</code> <code>Optional[float]</code> <p>Xylem radius</p> <code>rootradius</code> <code>Optional[float]</code> <p>Root radius</p> <code>kroot</code> <code>Optional[float]</code> <p>Radial hydraulic conductivity of root tissue</p> <code>rootcoefa</code> <code>Optional[float]</code> <p>Defines relative distance between roots at which mean soil water content occurs</p> <code>swhydrlift</code> <code>Optional[Literal[0, 1]]</code> <p>Switch for possibility hydraulic lift in root system</p> <code>rooteff</code> <code>Optional[float]</code> <p>Root system efficiency factor</p> <code>stephr</code> <code>Optional[float]</code> <p>Step between values of hroot and hxylem in iteration cycle</p> <code>criterhr</code> <code>Optional[float]</code> <p>Maximum difference of Hroot between iterations; convergence criterium</p> <code>taccur</code> <code>Optional[float]</code> <p>Maximum absolute difference between simulated and calculated potential transpiration rate</p> Source code in <code>pyswap/plant/crpfile.py</code> <pre><code>class DroughtStress(PySWAPBaseModel):\n    \"\"\"Drought stress settings for .crp file.\n\n    Attributes:\n        swdrought (Literal[1, 2]): Switch for drought stress\n\n            * 1 - Drought stress according to Feddes et al. (1978)\n            * 2 - rought stress according to De Jong van Lier et al. (2008)\n\n        swjarvis (Optional[Literal[0, 1, 2, 3, 4]]): _DEPRECATED_ Switch for Jarvis model for water uptake reduction\n        alphcrit: Optional[float] = _DEPRECATED_ Critical stress index (Jarvis, 1989) for compensation of root water uptake [0.2..1 -, R]\n        hlim3h (Optional[float]): Pressure head below which water uptake reduction starts at high Tpot\n        hlim3l (Optional[float]): Pressure head below which water uptake reduction starts at low Tpot\n        hlim4 (Optional[float]): No water extraction at lower soil water pressure heads\n        adcrh (Optional[float]): Level of high atmospheric demand, corresponding to HLIM3H\n        adcrl (Optional[float]): Level of low atmospheric demand, corresponding to HLIM3L\n        wiltpoint (Optional[float]): Minimum pressure head in leaves\n        kstem (Optional[float]): Hydraulic conductance between leaf and root xylem\n        rxylem (Optional[float]): Xylem radius\n        rootradius (Optional[float]): Root radius\n        kroot (Optional[float]): Radial hydraulic conductivity of root tissue\n        rootcoefa (Optional[float]): Defines relative distance between roots at which mean soil water content occurs\n        swhydrlift (Optional[Literal[0, 1]]): Switch for possibility hydraulic lift in root system\n        rooteff (Optional[float]): Root system efficiency factor\n        stephr (Optional[float]): Step between values of hroot and hxylem in iteration cycle\n        criterhr (Optional[float]): Maximum difference of Hroot between iterations; convergence criterium\n        taccur (Optional[float]): Maximum absolute difference between simulated and calculated potential transpiration rate\n    \"\"\"\n    swdrought: Literal[1, 2]\n    swjarvis: Optional[Literal[0, 1, 2, 3, 4]] = None\n    alphcrit: Optional[float] = Field(default=None, ge=0.2, le=1.0)\n    hlim3h: Optional[float] = Field(default=None, ge=-1.0e4, le=100.0)\n    hlim3l: Optional[float] = Field(default=None, ge=-1.0e4, le=100.0)\n    hlim4: Optional[float] = Field(default=None, ge=-1.6e4, le=100.0)\n    adcrh: Optional[float] = Field(default=None, ge=0.0, le=5.0)\n    adcrl: Optional[float] = Field(default=None, ge=0.0, le=5.0)\n    wiltpoint: Optional[float] = Field(default=None, ge=-1.0e8, le=-1.0e2)\n    kstem: Optional[float] = Field(default=None, ge=1.0e-10, le=10.0)\n    rxylem: Optional[float] = Field(default=None, ge=1.0e-4, le=1.0)\n    rootradius: Optional[float] = Field(default=None, ge=1.0e-4, le=1.0)\n    kroot: Optional[float] = Field(default=None, ge=1.0e-10, le=1.0e10)\n    rootcoefa: Optional[float] = Field(default=None, **UNITRANGE)\n    swhydrlift: Optional[Literal[0, 1]] = None\n    rooteff: Optional[float] = Field(default=None, **UNITRANGE)\n    stephr: Optional[float] = Field(default=None, ge=0.0, le=10.0)\n    criterhr: Optional[float] = Field(default=None, ge=0.0, le=10.0)\n    taccur: Optional[float] = Field(default=None, ge=1.0e-5, le=1.0e-2)\n\n    @model_validator(mode='after')\n    def _validate_prepartion(self) -&gt; Self:\n        if self.swdrought == 1:\n            assert self.hlim3h is not None, \"hlim3h is required when swdrought is 1.\"\n            assert self.hlim3l is not None, \"hlim3l is required when swdrought is 1.\"\n            assert self.hlim4 is not None, \"hlim4 is required when swdrought is 1.\"\n            assert self.adcrh is not None, \"adcrh is required when swdrought is 1.\"\n            assert self.adcrl is not None, \"adcrl is required when swdrought is 1.\"\n        if self.swdrought == 2:\n            assert self.wiltpoint is not None, \"wiltpoint is required when swdrought is 2.\"\n            assert self.kstem is not None, \"kstem is required when swdrought is 2.\"\n            assert self.rxylem is not None, \"rxylem is required when swdrought is 2.\"\n            assert self.rootradius is not None, \"rootradius is required when swdrought is 2.\"\n            assert self.kroot is not None, \"kroot is required when swdrought is 2.\"\n            assert self.rootcoefa is not None, \"rootcoefa is required when swdrought is 2.\"\n            assert self.swhydrlift is not None, \"swhydrlift is required when swdrought is 2.\"\n            assert self.rooteff is not None, \"rooteff is required when swdrought is 2.\"\n            assert self.stephr is not None, \"stephr is required when swdrought is 2.\"\n            assert self.criterhr is not None, \"criterhr is required when swdrought is 2.\"\n            assert self.taccur is not None, \"taccur is required when swdrought is 2.\"\n\n        return self\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.crpfile.GrasslandManagement","title":"<code>GrasslandManagement</code>","text":"<p>               Bases: <code>PySWAPBaseModel</code></p> <p>Settings specific to the dynamic grass growth module.</p> <p>Warning</p> <p>Validation still required.</p> <p>Attributes:</p> Name Type Description <code>seqgrazmow</code> <code>IntList</code> <p>sequence of periods with different practices within calender year. Available options:</p> <ul> <li>1 - Grazing</li> <li>2 - Mowing</li> <li>3 - Grazing with dewooling</li> </ul> <code>swharvest</code> <code>Literal[1, 2]</code> <p>Switch for timing harvest, either for mowing or grazing</p> <ul> <li>1 - Use dry matter threshold</li> <li>2 - Use fixed dates</li> </ul> <code>dateharvest</code> <code>Optional[DateList]</code> <p>harvest dates (maximum 999)</p> <code>swdmgrz</code> <code>Optional[Literal[1, 2]]</code> <p>Switch for dry matter threshold to trigger harvest by grazing</p> <ul> <li>1 - Use fixed threshold</li> <li>2 - Use flexible threshold</li> </ul> <code>dmgrazing</code> <code>Optional[Arrays]</code> <p>Minimum dry matter amount for cattle to enter the field [0..1d6 kg DM/ha, R]</p> <code>dmgrztb</code> <code>Optional[int]</code> <p>List threshold of above ground dry matter [0..1d6 kg DM/ha, R] to trigger grazing as function of daynumber [1..366 d, R]</p> <code>maxdaygrz</code> <code>Optional[int]</code> <p>Maximum growing period after harvest [1..366 -, I]</p> <code>swlossgrz</code> <code>Optional[Literal[0, 1]]</code> <p>Switch for losses due to insufficient pressure head during grazing</p> <ul> <li>0 - No loss</li> <li>1 - Losses due to treading</li> </ul> <code>tagprest</code> <code>Optional[float]</code> <p>Minimum amount of above ground DM after grazing [0..1d6 kg DM/ha, R]</p> <code>dewrest</code> <code>Optional[float]</code> <p>Remaining yield above ground after dewooling event [0..1d6 kg DM/ha, R]</p> <code>table_lsda</code> <code>Optional[Table]</code> <p>Actual livestock density of each grazing period</p> <code>table_lsdb</code> <code>Optional[Table]</code> <p>Relation between livestock density, number of grazing days and dry matter uptake</p> <code>swdmmow</code> <code>Optional[int]</code> <p>Switch for dry matter threshold to trigger harvest by mowing</p> <ul> <li>1 - Use fixed threshold</li> <li>2 - Use flexible threshold</li> </ul> <code>dmharvest</code> <code>Optional[float]</code> <p>Threshold of above ground dry matter to trigger mowing [0..1d6 kg DM/ha, R]</p> <code>daylastharvest</code> <code>Optional[int]</code> <p>Last calendar day on which mowing may occur [1..366 -, I]</p> <code>dmlastharvest</code> <code>Optional[float]</code> <p>Minimum above ground dry matter for mowing on last date [0..1d6 kg DM/ha, R]</p> <code>dmmowtb</code> <code>Optional[int]</code> <p>Dry matter mowing threshold</p> <code>maxdaymow</code> <code>Optional[int]</code> <p>Maximum growing period after harvest [1..366 -, I]</p> <code>swlossmow</code> <code>Optional[int]</code> <p>Switch for losses due to insufficient pressure head during mowing</p> <ul> <li>0 - No loss</li> <li>1 - Losses due to treading</li> </ul> <code>mowrest</code> <code>Optional[float]</code> <p>Remaining yield above ground after mowing event [0..1d6 kg DM/ha, R]</p> <code>table_dmmowdelay</code> <code>Optional[Optional[Table]]</code> <p>Relation between dry matter harvest [0..1d6 kg/ha, R] and days of delay in regrowth [0..366 d, I] after mowing</p> <code>swpotrelmf</code> <code>int</code> <p>Switch for calculation of potential yield</p> <ul> <li>1 - theoretical potential yield</li> <li>2 - attainable yield</li> </ul> <code>relmf</code> <code>float</code> <p>Relative management factor to reduce theoretical potential yield to attainable yield [0..1 -, R]</p> Source code in <code>pyswap/plant/crpfile.py</code> <pre><code>class GrasslandManagement(PySWAPBaseModel):\n    \"\"\"Settings specific to the dynamic grass growth module.\n\n    !!! warning\n\n        Validation still required.\n\n    Attributes:\n        seqgrazmow (IntList): sequence of periods with different practices within calender year. Available options:\n\n            * 1 - Grazing\n            * 2 - Mowing\n            * 3 - Grazing with dewooling\n\n        swharvest (Literal[1, 2]): Switch for timing harvest, either for mowing or grazing\n\n            * 1 - Use dry matter threshold\n            * 2 - Use fixed dates\n\n        dateharvest Optional[(DateList)]: harvest dates (maximum 999)\n        swdmgrz Optional[(Literal[1, 2])]: Switch for dry matter threshold to trigger harvest by grazing\n\n            * 1 - Use fixed threshold\n            * 2 - Use flexible threshold\n\n        dmgrazing Optional[(Arrays)]: Minimum dry matter amount for cattle to enter the field [0..1d6 kg DM/ha, R]\n        dmgrztb Optional[(int)]: List threshold of above ground dry matter [0..1d6 kg DM/ha, R] to trigger grazing as function of daynumber [1..366 d, R]\n        maxdaygrz Optional[(int)]: Maximum growing period after harvest [1..366 -, I]\n        swlossgrz Optional[(Literal[0, 1])]: Switch for losses due to insufficient pressure head during grazing\n\n            * 0 - No loss\n            * 1 - Losses due to treading\n\n        tagprest Optional[(float)]: Minimum amount of above ground DM after grazing [0..1d6 kg DM/ha, R]\n        dewrest Optional[(float)]: Remaining yield above ground after dewooling event [0..1d6 kg DM/ha, R]\n        table_lsda (Optional[Table]): Actual livestock density of each grazing period\n        table_lsdb (Optional[Table]): Relation between livestock density, number of grazing days and dry matter uptake\n        swdmmow Optional[(int)]: Switch for dry matter threshold to trigger harvest by mowing\n\n            * 1 - Use fixed threshold\n            * 2 - Use flexible threshold\n\n        dmharvest Optional[(float)]: Threshold of above ground dry matter to trigger mowing [0..1d6 kg DM/ha, R]\n        daylastharvest Optional[(int)]: Last calendar day on which mowing may occur [1..366 -, I]\n        dmlastharvest Optional[(float)]: Minimum above ground dry matter for mowing on last date [0..1d6 kg DM/ha, R]\n        dmmowtb Optional[(int)]: Dry matter mowing threshold\n        maxdaymow Optional[(int)]:Maximum growing period after harvest [1..366 -, I]\n        swlossmow Optional[(int)]: Switch for losses due to insufficient pressure head during mowing\n\n            * 0 - No loss\n            * 1 - Losses due to treading\n\n        mowrest Optional[(float)]: Remaining yield above ground after mowing event [0..1d6 kg DM/ha, R]\n        table_dmmowdelay Optional[(Optional[Table])]: Relation between dry matter harvest [0..1d6 kg/ha, R] and days of delay in regrowth [0..366 d, I] after mowing\n        swpotrelmf (int): Switch for calculation of potential yield\n\n            * 1 - theoretical potential yield\n            * 2 - attainable yield\n\n        relmf (float): Relative management factor to reduce theoretical potential yield to attainable yield [0..1 -, R]\n    \"\"\"\n\n    seqgrazmow: IntList\n    swharvest: Literal[1, 2]\n    dateharvest: Optional[DateList] = None\n    swdmgrz: Optional[Literal[1, 2]] = None\n    dmgrazing: Optional[Arrays] = None\n    dmgrztb: Optional[Arrays] = None\n    maxdaygrz: Optional[int] = None\n    swlossgrz: Optional[Literal[0, 1]] = None\n    tagprest: Optional[float] = None\n    dewrest: Optional[float] = None\n    table_lsda: Optional[Table] = None\n    table_lsdb: Optional[Table] = None\n    swdmmow: Optional[int] = None\n    dmharvest: Optional[float] = None\n    daylastharvest: Optional[int] = None\n    dmlastharvest: Optional[float] = None\n    dmmowtb: Optional[Arrays] = None\n    maxdaymow: Optional[int] = None\n    swlossmow: Optional[int] = None\n    mowrest: Optional[float] = None\n    table_dmmowdelay: Optional[Table] = None\n    swpotrelmf: int\n    relmf: float\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.crpfile.Interception","title":"<code>Interception</code>","text":"<p>               Bases: <code>PySWAPBaseModel</code></p> <p>Interception settings for .crp file.</p> <p>Attributes:</p> Name Type Description <code>swinter</code> <code>Literal[0, 1, 2]</code> <p>Switch for rainfall interception method</p> <ul> <li>0 - No interception</li> <li>1 - Agricultural crops (Von Hoyningen-Hune and Braden)</li> <li>2 - Trees and forests (Gash)</li> </ul> <code>cofab</code> <code>Optional[float]</code> <p>Interception coefficient, corresponding to maximum interception amount</p> <code>table_intertb</code> <code>Optional[Table]</code> <p>table with the following columns as a function of time T:</p> <ul> <li>PFREE - Free throughfall coefficient</li> <li>PSTEM - Stemflow coefficient</li> <li>SCANOPY - Canopy storage coefficient</li> <li>AVPREC = Average rainfall intensity</li> <li>AVEVAP = Average evaporation intensity during rainfall from a wet canopy</li> </ul> Source code in <code>pyswap/plant/crpfile.py</code> <pre><code>class Interception(PySWAPBaseModel):\n    \"\"\"Interception settings for .crp file.\n\n    Attributes:\n        swinter (Literal[0, 1, 2]): Switch for rainfall interception method\n\n            * 0 - No interception\n            * 1 - Agricultural crops (Von Hoyningen-Hune and Braden)\n            * 2 - Trees and forests (Gash)\n\n        cofab (Optional[float]): Interception coefficient, corresponding to maximum interception amount\n        table_intertb (Optional[Table]): table with the following columns as a function of time T:\n\n            * PFREE - Free throughfall coefficient\n            * PSTEM - Stemflow coefficient\n            * SCANOPY - Canopy storage coefficient\n            * AVPREC = Average rainfall intensity\n            * AVEVAP = Average evaporation intensity during rainfall from a wet canopy\n    \"\"\"\n    swinter: Literal[0, 1, 2]\n    cofab: Optional[float] = Field(default=None, **UNITRANGE)\n    table_intertb: Optional[Table] = None\n\n    @model_validator(mode='after')\n    def _validate_prepartion(self) -&gt; Self:\n        if self.swinter == 1:\n            assert self.cofab is not None, \"cofab is required when swinter is 1.\"\n        elif self.swinter == 1:\n            assert self.table_intertb is not None, \"table_intertb is required when swinter is 2.\"\n\n        return self\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.crpfile.OxygenStress","title":"<code>OxygenStress</code>","text":"<p>               Bases: <code>PySWAPBaseModel</code></p> <p>Oxygen stress settings for .crp file.</p> <p>Attributes:</p> Name Type Description <code>swoxygen</code> <code>Literal[0, 1, 2]</code> <p>Switch for oxygen stress</p> <ul> <li>0 - No oxygen stress</li> <li>1 - Oxygen stress according to Feddes et al. (1978)</li> <li>2 - Oxygen stress according to Bartholomeus et al. (2008)</li> </ul> <code>swoxygentype</code> <code>Optional[Literal[1, 2]]</code> <p>switch for physical processes or repro. functions to calculate oxygen stress</p> <ul> <li>1 - physical processes</li> <li>2 - reproduction functions</li> </ul> <code>swwrtnonox</code> <code>Literal[0, 1]</code> <p>Switch for checking aerobic conditions in root zone to stop root(zone) development</p> <code>aeratecrit</code> <code>Optional[float]</code> <p>Threshold to stop root extension in case of oxygenstress; 0.0 maximum oxygen stress</p> <code>hlim1</code> <code>Optional[float]</code> <p>No water extraction at higher pressure heads</p> <code>hlim2u</code> <code>Optional[float]</code> <p>H below which optimum water extr. starts for top layer</p> <code>hlim2l</code> <code>Optional[float]</code> <p>H below which optimum water extr. starts for sub layer</p> <code>q10_microbial</code> <code>Optional[float]</code> <p>Relative increase in microbial respiration at temperature increase of 10 C</p> <code>specific_resp_humus</code> <code>Optional[float]</code> <p>Respiration rate of humus at 25 C</p> <code>srl</code> <code>Optional[float]</code> <p>Specific root length</p> <code>swrootradius</code> <code>Optional[Literal[1, 2]]</code> <p>Switch for calculation of root radius</p> <ul> <li>1 - Calculate root radius</li> <li>2 - Root radius given in an input file</li> </ul> <code>dry_mat_cont_roots</code> <code>Optional[float]</code> <p>Dry matter content of roots</p> <code>air_filled_root_por</code> <code>Optional[float]</code> <p>Air filled root porosity</p> <code>spec_weight_root_tissue</code> <code>Optional[float]</code> <p>Specific weight of non-airfilled root tissue</p> <code>var_a</code> <code>Optional[float]</code> <p>Variance of root radius</p> <code>root_radiuso2</code> <code>Optional[float]</code> <p>Root radius for oxygen stress module</p> <code>q10_root</code> <code>Optional[float]</code> <p>Relative increase in root respiration at temperature increase of 10 oC</p> <code>f_senes</code> <code>Optional[float]</code> <p>Reduction factor for senescence, used for maintenance respiration</p> <code>c_mroot</code> <code>Optional[float]</code> <p>Maintenance coefficient of root</p> <code>table_max_resp_factor</code> <code>Optional[Table]</code> <p>Ratio root total respiration / maintenance respiration as a function of development stage</p> <code>table_dvs_w_root_ss</code> <code>Optional[Table]</code> <p>List dry weight of roots at soil surface as a function of development stage</p> <p>TODO: Find a way to validate the parameters that are required when the croptype=1 and swoxygen=2 (currently I cannot access the croptype parameter)</p> Source code in <code>pyswap/plant/crpfile.py</code> <pre><code>class OxygenStress(PySWAPBaseModel):\n    \"\"\"Oxygen stress settings for .crp file.\n\n    Attributes:\n        swoxygen (Literal[0, 1, 2]): Switch for oxygen stress\n\n            * 0 - No oxygen stress\n            * 1 - Oxygen stress according to Feddes et al. (1978)\n            * 2 - Oxygen stress according to Bartholomeus et al. (2008)\n\n        swoxygentype (Optional[Literal[1, 2]]): switch for physical processes or repro. functions to calculate oxygen stress\n\n            * 1 - physical processes\n            * 2 - reproduction functions\n\n        swwrtnonox (Literal[0, 1]): Switch for checking aerobic conditions in root zone to stop root(zone) development\n        aeratecrit (Optional[float]): Threshold to stop root extension in case of oxygenstress; 0.0 maximum oxygen stress\n        hlim1 (Optional[float]): No water extraction at higher pressure heads\n        hlim2u (Optional[float]): H below which optimum water extr. starts for top layer\n        hlim2l (Optional[float]): H below which optimum water extr. starts for sub layer\n        q10_microbial (Optional[float]): Relative increase in microbial respiration at temperature increase of 10 C\n        specific_resp_humus (Optional[float]): Respiration rate of humus at 25 C\n        srl (Optional[float]): Specific root length\n        swrootradius (Optional[Literal[1, 2]]): Switch for calculation of root radius\n\n            * 1 - Calculate root radius\n            * 2 - Root radius given in an input file\n\n        dry_mat_cont_roots (Optional[float]): Dry matter content of roots\n        air_filled_root_por (Optional[float]): Air filled root porosity\n        spec_weight_root_tissue (Optional[float]): Specific weight of non-airfilled root tissue\n        var_a (Optional[float]): Variance of root radius\n        root_radiuso2 (Optional[float]): Root radius for oxygen stress module\n        q10_root (Optional[float]): Relative increase in root respiration at temperature increase of 10 oC\n        f_senes (Optional[float]): Reduction factor for senescence, used for maintenance respiration\n        c_mroot (Optional[float]): Maintenance coefficient of root\n        table_max_resp_factor (Optional[Table]): Ratio root total respiration / maintenance respiration as a function of development stage\n        table_dvs_w_root_ss (Optional[Table]): List dry weight of roots at soil surface as a function of development stage\n\n    TODO: Find a way to validate the parameters that are required when the\n    croptype=1 and swoxygen=2 (currently I cannot access the croptype parameter)\n    \"\"\"\n\n    swoxygen: Literal[0, 1, 2]\n    swwrtnonox: Literal[0, 1]\n    swoxygentype: Optional[Literal[1, 2]] = None\n    aeratecrit: Optional[float] = Field(default=None, ge=0.0001, le=1.0)\n    hlim1: Optional[float] = Field(default=None, ge=-100.0, le=100.0)\n    hlim2u: Optional[float] = Field(default=None, ge=-1000.0, le=100.0)\n    hlim2l: Optional[float] = Field(default=None, ge=-1000.0, le=100.0)\n    q10_microbial: Optional[float] = Field(default=None, ge=1.0, le=4.0)\n    specific_resp_humus: Optional[float] = Field(default=None, **UNITRANGE)\n    srl: Optional[float] = Field(default=None, ge=0.0, le=1.0e10)\n    swrootradius: Optional[Literal[1, 2]] = None\n    dry_mat_cont_roots: Optional[float] = Field(default=None, **UNITRANGE)\n    air_filled_root_por: Optional[float] = Field(default=None, **UNITRANGE)\n    spec_weight_root_tissue: Optional[float] = Field(\n        default=None, ge=0.0, le=1.0e5)\n    var_a: Optional[float] = Field(default=None, **UNITRANGE)\n    root_radiuso2: Optional[float] = Field(default=None, ge=1.0e-6, le=0.1)\n    q10_root: Optional[float] = Field(default=None, ge=1.0, le=4.0)\n    f_senes: Optional[float] = Field(default=None, **UNITRANGE)\n    c_mroot: Optional[float] = Field(default=None, **UNITRANGE)\n    mrftb: Optional[Arrays] = None\n    wrtb: Optional[Arrays] = None\n\n    @model_validator(mode='after')\n    def _validate_oxygen(self) -&gt; Self:\n        if self.swoxygen == 1:\n            assert self.hlim1 is not None, \"hlim1 is required when swoxygen is 1.\"\n            assert self.hlim2u is not None, \"hlim2u is required when swoxygen is 1.\"\n            assert self.hlim2l is not None, \"hlim2l is required when swoxygen is 1.\"\n        elif self.swoxygen == 2:\n            assert self.q10_microbial is not None, \"q10_microbial is required when swoxygen is 2.\"\n            assert self.specific_resp_humus is not None, \"specific_resp_humus is required when swoxygen is 2.\"\n            assert self.srl is not None, \"srl is required when swoxygen is 2.\"\n            assert self.swrootradius is not None, \"swrootradius is required when swoxygen is 2.\"\n            if self.swrootradius == 1:\n                assert self.dry_mat_cont_roots is not None, \"dry_mat_cont_roots is required when swrootradius is 1.\"\n                assert self.air_filled_root_por is not None, \"air_filled_root_por is required when swrootradius is 1.\"\n                assert self.spec_weight_root_tissue is not None, \"spec_weight_root_tissue is required when swrootradius is 1.\"\n                assert self.var_a is not None, \"var_a is required when swrootradius is 1.\"\n            elif self.swrootradius == 2:\n                assert self.root_radiuso2 is not None, \"root_radiuso2 is required when swrootradius is 2.\"\n        if self.swwrtnonox == 1:\n            assert self.aeratecrit is not None, \"aeratecrit is required when swwrtnonox is 1.\"\n\n        return self\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.crpfile.Preparation","title":"<code>Preparation</code>","text":"<p>               Bases: <code>PySWAPBaseModel</code></p> <p>Preparation, sowing and germination settings for .crp file.</p> <p>Attributes:</p> Name Type Description <code>swprep</code> <code>Literal[0, 1]</code> <p>Switch for preparation</p> <code>swsow</code> <code>Literal[0, 1]</code> <p>Switch for sowing</p> <code>swgerm</code> <code>Literal[0, 1, 2]</code> <p>Switch for germination</p> <ul> <li>0 - No germination</li> <li>1 - Germination with temperature sum</li> <li>2 - Germination with temperature sum and water potential</li> </ul> <code>swharv</code> <code>Literal[0, 1]</code> <p>Switch for harvest</p> <ul> <li>0 - Timing of harvest depends on end of growing period (CROPEND)</li> <li>1 - Timing of harvest depends on development stage (DVSEND)</li> </ul> <code>dvsend</code> <code>Optional[float]</code> <p>Development stage at harvest</p> <code>zprep</code> <code>Optional[float]</code> <p>Z-level for monitoring work-ability for the crop</p> <code>hprep</code> <code>Optional[float]</code> <p>Maximum pressure head during preparation</p> <code>maxprepdelay</code> <code>Optional[int]</code> <p>Maximum delay of preparation from start of growing season</p> <code>zsow</code> <code>Optional[float]</code> <p>Z-level for monitoring work-ability for the crop</p> <code>hsow</code> <code>Optional[float]</code> <p>Maximum pressure head during sowing</p> <code>ztempsow</code> <code>Optional[float]</code> <p>Z-level for monitoring temperature for sowing</p> <code>tempsow</code> <code>Optional[float]</code> <p>Soil temperature needed for sowing</p> <code>maxsowdelay</code> <code>Optional[int]</code> <p>Maximum delay of sowing from start of growing season</p> <code>tsumemeopt</code> <code>Optional[float]</code> <p>Temperature sum needed for crop emergence</p> <code>tbasem</code> <code>Optional[float]</code> <p>Minimum temperature, used for germination trajectory</p> <code>teffmx</code> <code>Optional[float]</code> <p>Maximum temperature, used for germination trajectory</p> <code>hdrygerm</code> <code>Optional[float]</code> <p>Pressure head rootzone for dry germination trajectory</p> <code>hwetgerm</code> <code>Optional[float]</code> <p>Pressure head rootzone for wet germination trajectory</p> <code>zgerm</code> <code>Optional[float]</code> <p>Z-level for monitoring average pressure head</p> <code>agerm</code> <code>Optional[float]</code> <p>A-coefficient Eq. 24/25 Feddes &amp; Van Wijk</p> Source code in <code>pyswap/plant/crpfile.py</code> <pre><code>class Preparation(PySWAPBaseModel):\n    \"\"\"Preparation, sowing and germination settings for .crp file.\n\n    Attributes:\n        swprep (Literal[0, 1]): Switch for preparation\n        swsow (Literal[0, 1]): Switch for sowing\n        swgerm (Literal[0, 1, 2]): Switch for germination\n\n            * 0 - No germination\n            * 1 - Germination with temperature sum\n            * 2 - Germination with temperature sum and water potential\n\n        swharv (Literal[0, 1]): Switch for harvest\n\n            * 0 - Timing of harvest depends on end of growing period (CROPEND)\n            * 1 - Timing of harvest depends on development stage (DVSEND)\n\n        dvsend (Optional[float]): Development stage at harvest\n        zprep (Optional[float]): Z-level for monitoring work-ability for the crop\n        hprep (Optional[float]): Maximum pressure head during preparation\n        maxprepdelay (Optional[int]): Maximum delay of preparation from start of growing season\n        zsow (Optional[float]): Z-level for monitoring work-ability for the crop\n        hsow (Optional[float]): Maximum pressure head during sowing\n        ztempsow (Optional[float]): Z-level for monitoring temperature for sowing\n        tempsow (Optional[float]): Soil temperature needed for sowing\n        maxsowdelay (Optional[int]): Maximum delay of sowing from start of growing season\n        tsumemeopt (Optional[float]): Temperature sum needed for crop emergence\n        tbasem (Optional[float]): Minimum temperature, used for germination trajectory\n        teffmx (Optional[float]): Maximum temperature, used for germination trajectory\n        hdrygerm (Optional[float]): Pressure head rootzone for dry germination trajectory\n        hwetgerm (Optional[float]): Pressure head rootzone for wet germination trajectory\n        zgerm (Optional[float]): Z-level for monitoring average pressure head\n        agerm (Optional[float]): A-coefficient Eq. 24/25 Feddes &amp; Van Wijk\n    \"\"\"\n\n    swprep: Literal[0, 1]\n    swsow: Literal[0, 1]\n    swgerm: Literal[0, 1, 2]\n    swharv: Literal[0, 1]\n    dvsend: Optional[float] = Field(default=None, ge=0.0, le=3.0)\n    zprep: Optional[float] = Field(default=None, ge=-100.0, le=0.0)\n    hprep: Optional[float] = Field(default=None, ge=-200.0, le=0.0)\n    maxprepdelay: Optional[int] = Field(default=None, ge=1, le=366)\n    zsow: Optional[float] = Field(default=None, ge=-100.0, le=0.0)\n    hsow: Optional[float] = Field(default=None, ge=-200.0, le=0.0)\n    ztempsow: Optional[float] = Field(default=None,  ge=-100.0, le=0.0)\n    tempsow: Optional[float] = Field(default=None, ge=0.0, le=30.0)\n    maxsowdelay: Optional[int] = Field(default=None, ge=1, le=366)\n    tsumemeopt: Optional[float] = Field(default=None, ge=0.0, le=1000.0)\n    tbasem: Optional[float] = Field(default=None, ge=0.0, le=1000.0)\n    teffmx: Optional[float] = Field(default=None, ge=0.0, le=1000.0)\n    hdrygerm: Optional[float] = Field(default=None, ge=-1000.0, le=1000.0)\n    hwetgerm: Optional[float] = Field(default=None, ge=-100.0, le=1000.0)\n    zgerm: Optional[float] = Field(default=None, ge=-100.0, le=1000.0)\n    agerm: Optional[float] = Field(default=None, ge=0.0, le=1000.0)\n\n    @model_validator(mode='after')\n    def _validate_prepartion(self) -&gt; Self:\n        if self.swprep == 1:\n            assert self.zprep is not None, \"zprep is required when swprep is 1.\"\n            assert self.hprep is not None, \"hprep is required when swprep is 1.\"\n            assert self.maxprepdelay is not None, \"maxprepdelay is required when swprep is 1.\"\n\n        if self.swsow == 1:\n            assert self.zsow is not None, \"zsow is required when swsow is 1.\"\n            assert self.hsow is not None, \"hsow is required when swsow is 1.\"\n            assert self.ztempsow is not None, \"ztempsow is required when swsow is 1.\"\n            assert self.tempsow is not None, \"tempsow is required when swsow is 1.\"\n            assert self.maxsowdelay is not None, \"maxsowdelay is required when swsow is 1.\"\n\n        if self.swgerm in (1, 2):\n            assert self.tsumemeopt is not None, \"tsumemeopt is required when swgerm is 1 or 2.\"\n            assert self.tbasem is not None, \"tbasem is required when swgerm is 1 or 2.\"\n            assert self.teffmx is not None, \"teffmx is required when swgerm is 1 or 2.\"\n        elif self.swgerm == 2:\n            assert self.hdrygerm is not None, \"hdrygerm is required when swgerm is 2.\"\n            assert self.hwetgerm is not None, \"hwetgerm is required when swgerm is 2.\"\n            assert self.zgerm is not None, \"zgerm is required when swgerm is 2.\"\n            assert self.agerm is not None, \"agerm is required when swgerm is 2.\"\n\n        return self\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.crpfile.SaltStress","title":"<code>SaltStress</code>","text":"<p>               Bases: <code>PySWAPBaseModel</code></p> <p>Salt stress settings for .crp file.</p> <p>Attributes:</p> Name Type Description <code>swsalinity</code> <code>Literal[0, 1, 2]</code> <p>Switch for salt stress</p> <ul> <li>0 - No salt stress</li> <li>1 - Maas and Hoffman reduction function</li> <li>2 - Use osmotic head</li> </ul> <code>saltmax</code> <code>Optional[float]</code> <p>Threshold salt concentration in soil water</p> <code>saltslope</code> <code>Optional[float]</code> <p>Decline of root water uptake above threshold</p> <code>salthead</code> <code>Optional[float]</code> <p>Conversion factor salt concentration (mg/cm3) into osmotic head (cm)</p> Source code in <code>pyswap/plant/crpfile.py</code> <pre><code>class SaltStress(PySWAPBaseModel):\n    \"\"\"Salt stress settings for .crp file.\n\n    Attributes:\n        swsalinity (Literal[0, 1, 2]): Switch for salt stress\n\n            * 0 - No salt stress\n            * 1 - Maas and Hoffman reduction function\n            * 2 - Use osmotic head\n\n        saltmax (Optional[float]): Threshold salt concentration in soil water\n        saltslope (Optional[float]): Decline of root water uptake above threshold\n        salthead (Optional[float]): Conversion factor salt concentration (mg/cm3) into osmotic head (cm)\n    \"\"\"\n    swsalinity: Literal[0, 1, 2]\n    saltmax: Optional[float] = Field(default=None, ge=0.0, le=100.0)\n    saltslope: Optional[float] = Field(default=None, **UNITRANGE)\n    salthead: Optional[float] = Field(default=None, ge=0.0, le=1000.0)\n\n    @model_validator(mode='after')\n    def _validate_prepartion(self) -&gt; Self:\n        if self.swsalinity == 1:\n            assert self.saltmax is not None, \"saltmax is required when swsalinity is 1.\"\n            assert self.saltslope is not None, \"saltslope is required when swsalinity is 1.\"\n        elif self.swsalinity == 2:\n            assert self.salthead is not None, \"salthead is required when swsalinity is 2.\"\n\n        return self\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.read_yaml","title":"<code>read_yaml</code>","text":"<p>Script reading YAML crop settings files.</p>"},{"location":"reference/api-reference/#pyswap.plant.read_yaml.WOFOSTCrop","title":"<code>WOFOSTCrop</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Class for managing the library of WOFOST crop parameters from https://github.com/ajwdewit.</p> <p>The library is included as a submodule in pySWAP and is located at pyswap/libs/WOFOST_crop_parameters. All files in that library have .yaml extension and fairly uniform format so it made sense to set up a  pySWAP specific data structure for reading them.</p> Source code in <code>pyswap/plant/read_yaml.py</code> <pre><code>class WOFOSTCrop(BaseModel):\n    \"\"\"Class for managing the library of WOFOST crop parameters from https://github.com/ajwdewit.\n\n    The library is included as a submodule in pySWAP and is located at pyswap/libs/WOFOST_crop_parameters.\n    All files in that library have .yaml extension and fairly uniform format so it made sense to set up a \n    pySWAP specific data structure for reading them.\n    \"\"\"\n    libdir: Path = LIBDIR\n    yaml_content: dict\n\n    @computed_field(return_type=dict)\n    def metadata(self):\n        return self.yaml_content['Metadata']\n\n    @computed_field(return_type=dict)\n    def ecotypes(self):\n        return list(self.yaml_content['CropParameters']['EcoTypes'])\n\n    @computed_field(return_type=dict)\n    def genericc3(self):\n        \"\"\"Get generic settings for C3 crop types - plants that bind CO2 into \n        3-phosphoglycerate having three carbon atoms. E.g., wheat, rice\"\"\"\n        return self.yaml_content['CropParameters']['GenericC3']\n\n    @computed_field(return_type=dict)\n    def genericc4(self):\n        \"\"\"Get generic settings for C4 crop types - plants that bind CO2 into \n        oxaloacetate having four carbon atoms. E.g., maize, sugarcane\"\"\"\n        return self.yaml_content['CropParameters']['GenericC4']\n\n    @computed_field(return_type=dict)\n    def varieties(self):\n        return list(self.yaml_content['CropParameters']['Varieties'])\n\n    @staticmethod\n    def _serialize_variety(variety_dict: dict, what: str):\n        variety_dict.pop(\"Metadata\")\n        if what == \"parameters\":\n            return {k: v[0] for k, v in variety_dict.items()}\n        if what == \"explanation\":\n            return {k: f'{v[1]} {v[2]}' for k, v in variety_dict.items()}\n\n    def get_variety(self, variety: str, what: str = 'parameters'):\n        content = self.yaml_content['CropParameters']['Varieties'][variety]\n        return self._serialize_variety(content, what=what)\n\n    def get_variety_meta(self, variety: str):\n        content = self.yaml_content['CropParameters']['Varieties'][variety]\n        return content['Metadata']\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.read_yaml.WOFOSTCrop.genericc3","title":"<code>genericc3()</code>","text":"<p>Get generic settings for C3 crop types - plants that bind CO2 into  3-phosphoglycerate having three carbon atoms. E.g., wheat, rice</p> Source code in <code>pyswap/plant/read_yaml.py</code> <pre><code>@computed_field(return_type=dict)\ndef genericc3(self):\n    \"\"\"Get generic settings for C3 crop types - plants that bind CO2 into \n    3-phosphoglycerate having three carbon atoms. E.g., wheat, rice\"\"\"\n    return self.yaml_content['CropParameters']['GenericC3']\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.read_yaml.WOFOSTCrop.genericc4","title":"<code>genericc4()</code>","text":"<p>Get generic settings for C4 crop types - plants that bind CO2 into  oxaloacetate having four carbon atoms. E.g., maize, sugarcane</p> Source code in <code>pyswap/plant/read_yaml.py</code> <pre><code>@computed_field(return_type=dict)\ndef genericc4(self):\n    \"\"\"Get generic settings for C4 crop types - plants that bind CO2 into \n    oxaloacetate having four carbon atoms. E.g., maize, sugarcane\"\"\"\n    return self.yaml_content['CropParameters']['GenericC4']\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.read_yaml.croptypes","title":"<code>croptypes()</code>","text":"<p>Print the list of available files</p> Source code in <code>pyswap/plant/read_yaml.py</code> <pre><code>def croptypes():\n    \"\"\"Print the list of available files\"\"\"\n    pprint([file for file in os.listdir(LIBDIR)\n            if file.endswith('.yaml')])\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.tables","title":"<code>tables</code>","text":"<p>Tables for the crop settings</p> <p>Classes:</p> Name Description <code>RDTB</code> <p>Root depth table</p>"},{"location":"reference/api-reference/#pyswap.plant.tables.AMAXTB","title":"<code>AMAXTB</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>maximum CO2 assimilation rate [0..100 kg/ha/hr, R] as function of development stage [0..2 -, R]</p> <p>Attributes:</p> Name Type Description <code>DVS</code> <code>Series[float]</code> <p>Development stage of the crop.</p> <code>AMAX</code> <code>Series[float]</code> <p>Maximum CO2 assimilation rate.</p> Source code in <code>pyswap/plant/tables.py</code> <pre><code>class AMAXTB(BaseModel):\n    \"\"\"maximum CO2 assimilation rate [0..100 kg/ha/hr, R] as function of development stage [0..2 -, R]\n\n    Attributes:\n        DVS (Series[float]): Development stage of the crop.\n        AMAX (Series[float]): Maximum CO2 assimilation rate.\n    \"\"\"\n\n    DVS: Series[float] = pa.Field(**DVSRANGE)\n    AMAX: Series[float] = pa.Field(ge=0.0, le=100.0)\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.tables.AMAXTB_GRASS","title":"<code>AMAXTB_GRASS</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>maximum CO2 assimilation rate [0..100 kg/ha/hr, R] as function of development stage [0..2 -, R]</p> <p>Attributes:</p> Name Type Description <code>DNR</code> <code>Series[float]</code> <p>Day number.</p> <code>AMAX</code> <code>Series[float]</code> <p>Maximum CO2 assimilation rate.</p> Source code in <code>pyswap/plant/tables.py</code> <pre><code>class AMAXTB_GRASS(BaseModel):\n    \"\"\"maximum CO2 assimilation rate [0..100 kg/ha/hr, R] as function of development stage [0..2 -, R]\n\n    Attributes:\n        DNR (Series[float]): Day number.\n        AMAX (Series[float]): Maximum CO2 assimilation rate.\n    \"\"\"\n\n    DNR: Series[float] = pa.Field(**YEARRANGE)\n    AMAX: Series[float] = pa.Field(ge=0.0, le=100.0)\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.tables.CHTB","title":"<code>CHTB</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Crop Height [0..1.d4 cm, R], as function of dev. stage [0..2 -, R]</p> <p>Attributes:</p> Name Type Description <code>DVS</code> <code>Series[float]</code> <p>Development stage of the crop.</p> <code>CH</code> <code>Series[float]</code> <p>Crop height of the crop.</p> Source code in <code>pyswap/plant/tables.py</code> <pre><code>class CHTB(BaseModel):\n    \"\"\"Crop Height [0..1.d4 cm, R], as function of dev. stage [0..2 -, R]\n\n    Attributes:\n        DVS (Series[float]): Development stage of the crop.\n        CH (Series[float]): Crop height of the crop.\n    \"\"\"\n\n    DVS: Series[float] = pa.Field(**DVSRANGE)\n    CH: Series[float] = pa.Field(ge=0.0, le=1.0e4)\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.tables.CHTB_GRASS","title":"<code>CHTB_GRASS</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Crop Height [0..1.d4 cm, R], as function of dev. stage [0..2 -, R]</p> <p>Attributes:</p> Name Type Description <code>DNR</code> <code>Series[float]</code> <p>day number.</p> <code>CH</code> <code>Series[float]</code> <p>Crop height of the crop.</p> Source code in <code>pyswap/plant/tables.py</code> <pre><code>class CHTB_GRASS(BaseModel):\n    \"\"\"Crop Height [0..1.d4 cm, R], as function of dev. stage [0..2 -, R]\n\n    Attributes:\n        DNR (Series[float]): day number.\n        CH (Series[float]): Crop height of the crop.\n    \"\"\"\n\n    DNR: Series[float] = pa.Field(**YEARRANGE)\n    CH: Series[float] = pa.Field(ge=0.0, le=1.0e4)\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.tables.CROPROTATION","title":"<code>CROPROTATION</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Crop rotation settings</p> <p>Attributes:</p> Name Type Description <code>CROPSTART</code> <code>Series[DateTime]</code> <p>Start date of the crop.</p> <code>CROPEND</code> <code>Series[DateTime]</code> <p>End date of the crop.</p> <code>CROPFIL</code> <code>Series[str]</code> <p>Crop file name.</p> <code>CROPTYPE</code> <code>Series[int]</code> <p>Crop module type</p> <ul> <li>1 - simple</li> <li>2 - detailed, WOFOST general</li> <li>3 - detailed, WOFOST grass</li> </ul> Source code in <code>pyswap/plant/tables.py</code> <pre><code>class CROPROTATION(BaseModel):\n    \"\"\"Crop rotation settings\n\n    Attributes:\n        CROPSTART (Series[pa.DateTime]): Start date of the crop.\n        CROPEND (Series[pa.DateTime]): End date of the crop.\n        CROPFIL (Series[str]): Crop file name.\n        CROPTYPE (Series[int]): Crop module type\n\n            * 1 - simple\n            * 2 - detailed, WOFOST general\n            * 3 - detailed, WOFOST grass\n    \"\"\"\n    CROPSTART: Series[pa.DateTime]\n    CROPEND: Series[pa.DateTime]\n    CROPFIL: Series[str]\n    CROPTYPE: Series[int] = pa.Field(ge=1, le=3)\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.tables.DMGRZTB","title":"<code>DMGRZTB</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>threshold of above ground dry matter [0..1d6 kg DM/ha, R] to trigger grazing as function of daynumber [1..366 d, R]</p> <p>Attributes:</p> Name Type Description <code>DNR</code> <code>Series[float]</code> <p>Day number.</p> <code>DMGRZ</code> <code>Series[float]</code> <p>Dry matter growth rate of roots.</p> Source code in <code>pyswap/plant/tables.py</code> <pre><code>class DMGRZTB(BaseModel):\n    \"\"\"threshold of above ground dry matter [0..1d6 kg DM/ha, R] to trigger grazing as function of daynumber [1..366 d, R]\n\n    Attributes:\n        DNR (Series[float]): Day number.\n        DMGRZ (Series[float]): Dry matter growth rate of roots.\n    \"\"\"\n\n    DNR: Series[float] = pa.Field(**YEARRANGE)\n    DMGRZ: Series[float] = pa.Field(ge=0.0, le=1.0e6)\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.tables.DMMOWDELAY","title":"<code>DMMOWDELAY</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Relation between dry matter harvest [0..1d6 kg/ha, R] and days of delay in regrowth [0..366 d, I] after mowing</p> <p>Attributes:</p> Name Type Description <code>DMMOWDELAY</code> <code>Series[float]</code> <p>Dry matter harvest [0..1d6 kg/ha, R]</p> <code>DAYDELAY</code> <code>Series[int]</code> <p>days of delay in regrowth [0..366 d, I]</p> Source code in <code>pyswap/plant/tables.py</code> <pre><code>class DMMOWDELAY(BaseModel):\n    \"\"\"Relation between dry matter harvest [0..1d6 kg/ha, R] and days of delay in regrowth [0..366 d, I] after mowing\n\n    Attributes:\n        DMMOWDELAY (Series[float]): Dry matter harvest [0..1d6 kg/ha, R]\n        DAYDELAY (Series[int]): days of delay in regrowth [0..366 d, I]\n    \"\"\"\n\n    DMMOWDELAY: Series[float] = pa.Field(ge=0.0, le=1.0e6)\n    DAYDELAY: Series[int] = pa.Field(**YEARRANGE)\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.tables.DMMOWTB","title":"<code>DMMOWTB</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>List threshold of above ground dry matter [0..1d6 kg DM/ha, R] to trigger mowing as function of daynumber [1..366 d, R]</p> <p>Note</p> <p>maximum 20 records</p> <p>Attributes:</p> Name Type Description <code>DNR</code> <code>Series[float]</code> <p>Day number.</p> <code>DMMOW</code> <code>Series[float]</code> <p>threshold of above ground dry matter [0..1d6 kg DM/ha, R]</p> Source code in <code>pyswap/plant/tables.py</code> <pre><code>class DMMOWTB(BaseModel):\n    \"\"\"List threshold of above ground dry matter [0..1d6 kg DM/ha, R] to trigger mowing as function of daynumber [1..366 d, R]\n\n    !!! note\n\n        maximum 20 records\n\n\n    Attributes:\n        DNR (Series[float]): Day number.\n        DMMOW (Series[float]): threshold of above ground dry matter [0..1d6 kg DM/ha, R]\n    \"\"\"\n\n    DNR: Series[float] = pa.Field(**YEARRANGE)\n    DMMOW: Series[float] = pa.Field(ge=0.0, le=1.0e6)\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.tables.DTSMTB","title":"<code>DTSMTB</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>increase in temperature sum [0..60 oC, R] as function of daily average temperature [0..100 oC, R]</p> <p>Attributes:</p> Name Type Description <code>TAV</code> <code>Series[float]</code> <p>Daily average temperature.</p> <code>DTSM</code> <code>Series[float]</code> <p>Increase in temperature sum.</p> Source code in <code>pyswap/plant/tables.py</code> <pre><code>class DTSMTB(BaseModel):\n    \"\"\"increase in temperature sum [0..60 oC, R] as function of daily average temperature [0..100 oC, R]\n\n    Attributes:\n        TAV (Series[float]): Daily average temperature.\n        DTSM (Series[float]): Increase in temperature sum.\n    \"\"\"\n\n    TAV: Series[float] = pa.Field(ge=0.0, le=100.0)\n    DTSM: Series[float] = pa.Field(ge=0.0, le=60.0)\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.tables.FLTB","title":"<code>FLTB</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>fraction of total above ground dry matter increase partitioned to the leaves [kg/kg, R]</p> <p>Attributes:</p> Name Type Description <code>DVS</code> <code>Series[float]</code> <p>Development stage of the crop.</p> <code>FL</code> <code>Series[float]</code> <p>Fraction of total above ground dry matter increase partitioned to the leaves.</p> Source code in <code>pyswap/plant/tables.py</code> <pre><code>class FLTB(BaseModel):\n    \"\"\"fraction of total above ground dry matter increase partitioned to the leaves [kg/kg, R]\n\n    Attributes:\n        DVS (Series[float]): Development stage of the crop.\n        FL (Series[float]): Fraction of total above ground dry matter increase partitioned to the leaves.\n    \"\"\"\n\n    DVS: Series[float] = pa.Field(**DVSRANGE)\n    FL: Series[float] = pa.Field(ge=0.0, le=1.0)\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.tables.FLTB_GRASS","title":"<code>FLTB_GRASS</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>fraction of total above ground dry matter increase partitioned to the leaves [kg/kg, R]</p> <p>Attributes:</p> Name Type Description <code>DNR</code> <code>Series[float]</code> <p>Day number.</p> <code>FL</code> <code>Series[float]</code> <p>Fraction of total above ground dry matter increase partitioned to the leaves.</p> Source code in <code>pyswap/plant/tables.py</code> <pre><code>class FLTB_GRASS(BaseModel):\n    \"\"\"fraction of total above ground dry matter increase partitioned to the leaves [kg/kg, R]\n\n    Attributes:\n        DNR (Series[float]): Day number.\n        FL (Series[float]): Fraction of total above ground dry matter increase partitioned to the leaves.\n    \"\"\"\n\n    DNR: Series[float] = pa.Field(**YEARRANGE)\n    FL: Series[float] = pa.Field(**UNITRANGE)\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.tables.FOTB","title":"<code>FOTB</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>fraction of total above ground dry matter increase partitioned to the storage organs [kg/kg, R]</p> <p>Attributes:</p> Name Type Description <code>DVS</code> <code>Series[float]</code> <p>Development stage of the crop.</p> <code>FO</code> <code>Series[float]</code> <p>Fraction of total above ground dry matter increase partitioned to the storage organs.</p> Source code in <code>pyswap/plant/tables.py</code> <pre><code>class FOTB(BaseModel):\n    \"\"\"fraction of total above ground dry matter increase partitioned to the storage organs [kg/kg, R]\n\n    Attributes:\n        DVS (Series[float]): Development stage of the crop.\n        FO (Series[float]): Fraction of total above ground dry matter increase partitioned to the storage organs.\n    \"\"\"\n\n    DVS: Series[float] = pa.Field(**DVSRANGE)\n    FO: Series[float] = pa.Field(ge=0.0, le=1.0)\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.tables.FRTB","title":"<code>FRTB</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>fraction of total dry matter increase partitioned to the roots [kg/kg, R]</p> <p>Attributes:</p> Name Type Description <code>DVS</code> <code>Series[float]</code> <p>Development stage of the crop.</p> <code>FR</code> <code>Series[float]</code> <p>Fraction of total dry matter increase partitioned to the roots.</p> Source code in <code>pyswap/plant/tables.py</code> <pre><code>class FRTB(BaseModel):\n    \"\"\"fraction of total dry matter increase partitioned to the roots [kg/kg, R]\n\n    Attributes:\n        DVS (Series[float]): Development stage of the crop.\n        FR (Series[float]): Fraction of total dry matter increase partitioned to the roots.\n    \"\"\"\n\n    DVS: Series[float] = pa.Field(**DVSRANGE)\n    FR: Series[float] = pa.Field(ge=0.0, le=1.0)\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.tables.FRTB_GRASS","title":"<code>FRTB_GRASS</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>fraction of total dry matter increase partitioned to the roots [kg/kg, R]</p> <p>Attributes:</p> Name Type Description <code>DNR</code> <code>Series[float]</code> <p>Day number.</p> <code>FR</code> <code>Series[float]</code> <p>Fraction of total dry matter increase partitioned to the roots.</p> Source code in <code>pyswap/plant/tables.py</code> <pre><code>class FRTB_GRASS(BaseModel):\n    \"\"\"fraction of total dry matter increase partitioned to the roots [kg/kg, R]\n\n    Attributes:\n        DNR (Series[float]): Day number.\n        FR (Series[float]): Fraction of total dry matter increase partitioned to the roots.\n    \"\"\"\n\n    DNR: Series[float] = pa.Field(**YEARRANGE)\n    FR: Series[float] = pa.Field(**UNITRANGE)\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.tables.FSTB","title":"<code>FSTB</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>fraction of total above ground dry matter increase partitioned to the stems [kg/kg, R]</p> <p>Attributes:</p> Name Type Description <code>DVS</code> <code>Series[float]</code> <p>Development stage of the crop.</p> <code>FS</code> <code>Series[float]</code> <p>Fraction of total above ground dry matter increase partitioned to the stems.</p> Source code in <code>pyswap/plant/tables.py</code> <pre><code>class FSTB(BaseModel):\n    \"\"\"fraction of total above ground dry matter increase partitioned to the stems [kg/kg, R]\n\n    Attributes:\n        DVS (Series[float]): Development stage of the crop.\n        FS (Series[float]): Fraction of total above ground dry matter increase partitioned to the stems.\n    \"\"\"\n\n    DVS: Series[float] = pa.Field(**DVSRANGE)\n    FS: Series[float] = pa.Field(ge=0.0, le=1.0)\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.tables.FSTB_GRASS","title":"<code>FSTB_GRASS</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>fraction of total above ground dry matter increase partitioned to the stems [kg/kg, R]</p> <p>Attributes:</p> Name Type Description <code>DNR</code> <code>Series[float]</code> <p>Day number.</p> <code>FS</code> <code>Series[float]</code> <p>Fraction of total above ground dry matter increase partitioned to the stems.</p> Source code in <code>pyswap/plant/tables.py</code> <pre><code>class FSTB_GRASS(BaseModel):\n    \"\"\"fraction of total above ground dry matter increase partitioned to the stems [kg/kg, R]\n\n    Attributes:\n        DNR (Series[float]): Day number.\n        FS (Series[float]): Fraction of total above ground dry matter increase partitioned to the stems.\n    \"\"\"\n\n    DNR: Series[float] = pa.Field(**YEARRANGE)\n    FS: Series[float] = pa.Field(**UNITRANGE)\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.tables.GCTB","title":"<code>GCTB</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Leaf Area Index [0..12 (m2 leaf)/(m2 soil), R], as function of dev. stage [0..2 -, R]</p> <p>Attributes:</p> Name Type Description <code>DVS</code> <code>Series[float]</code> <p>Development stage of the crop.</p> <code>LAI</code> <code>Series[float]</code> <p>Leaf Area Index of the crop.</p> Source code in <code>pyswap/plant/tables.py</code> <pre><code>class GCTB(BaseModel):\n    \"\"\"Leaf Area Index [0..12 (m2 leaf)/(m2 soil), R], as function of dev. stage [0..2 -, R]\n\n    Attributes:\n        DVS (Series[float]): Development stage of the crop.\n        LAI (Series[float]): Leaf Area Index of the crop.\n    \"\"\"\n\n    DVS: Series[float] = pa.Field(**DVSRANGE)\n    LAI: Series[float] = pa.Field(ge=0.0, le=12.0)\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.tables.KYTB","title":"<code>KYTB</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Yield response factor [0..5 -, R], as function of dev. stage [0..2 -, R]</p> <p>Attributes:</p> Name Type Description <code>DVS</code> <code>Series[float]</code> <p>Development stage of the crop.</p> <code>KY</code> <code>Series[float]</code> <p>Yield response factor of the crop.</p> Source code in <code>pyswap/plant/tables.py</code> <pre><code>class KYTB(BaseModel):\n    \"\"\"Yield response factor [0..5 -, R], as function of dev. stage [0..2 -, R]\n\n    Attributes:\n        DVS (Series[float]): Development stage of the crop.\n        KY (Series[float]): Yield response factor of the crop.\n    \"\"\"\n    DVS: Series[float] = pa.Field(**DVSRANGE)\n    KY: Series[float] = pa.Field(ge=0.0, le=5.0)\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.tables.LSDATB","title":"<code>LSDATB</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Actual livestock density of each grazing period</p> <p>Note</p> <p>total number of periods should be equal to number of periods in SEQGRAZMOW</p> <p>Attributes:</p> Name Type Description <code>SEQNR</code> <code>Series[int]</code> <p>number of the sequence period with mowing/grazing [0..366 d, I]</p> <code>LSDA</code> <code>Series[float]</code> <p>Actual Live Stock Density of the grazing period [0.0..1000.0 LS/ha, R]</p> Source code in <code>pyswap/plant/tables.py</code> <pre><code>class LSDATB(BaseModel):\n    \"\"\"Actual livestock density of each grazing period\n\n    !!! note\n\n        total number of periods should be equal to number of periods in SEQGRAZMOW\n\n    Attributes:\n        SEQNR (Series[int]): number of the sequence period with mowing/grazing [0..366 d, I]\n        LSDA (Series[float]): Actual Live Stock Density of the grazing period [0.0..1000.0 LS/ha, R]\n    \"\"\"\n\n    SEQNR: Series[int] = pa.Field(**YEARRANGE)\n    LSDA: Series[float] = pa.Field(ge=0.0, le=1000.0)\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.tables.LSDBTB","title":"<code>LSDBTB</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Relation between livestock density, number of grazing days and dry matter uptake</p> <p>Attributes:</p> Name Type Description <code>LSDB</code> <code>Series[float]</code> <p>Basic Live Stock Density [0.0..1000.0 LS/ha, R]</p> <code>DAYSGRAZING</code> <code>Series[float]</code> <p>Maximum days of grazing [0.0..366.0 d, R]</p> <code>UPTGRAZING</code> <code>Series[float]</code> <p>Dry matter uptake by grazing [0.0..1000.0 kg/ha, R] (kg/ha DM)</p> <code>LOSSGRAZING</code> <code>Series[float]</code> <p>Dry matter loss during grazing due to droppings and treading [0.0..1000.0 kg/ha, R] (kg/ha DM)</p> Source code in <code>pyswap/plant/tables.py</code> <pre><code>class LSDBTB(BaseModel):\n    \"\"\"Relation between livestock density, number of grazing days and dry matter uptake\n\n    Attributes:\n        LSDB (Series[float]): Basic Live Stock Density [0.0..1000.0 LS/ha, R]\n        DAYSGRAZING (Series[float]): Maximum days of grazing [0.0..366.0 d, R]\n        UPTGRAZING (Series[float]): Dry matter uptake by grazing [0.0..1000.0 kg/ha, R] (kg/ha DM)\n        LOSSGRAZING (Series[float]): Dry matter loss during grazing due to droppings and treading [0.0..1000.0 kg/ha, R] (kg/ha DM)\n    \"\"\"\n\n    LSDB: Series[float] = pa.Field(ge=0.0, le=1000.0)\n    DAYSGRAZING: Series[float] = pa.Field(**YEARRANGE)\n    UPTGRAZING: Series[float] = pa.Field(ge=0.0, le=1000.0)\n    LOSSGRAZING: Series[float] = pa.Field(ge=0.0, le=1000.0)\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.tables.MRFTB","title":"<code>MRFTB</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Ratio root total respiration / maintenance respiration [1..5.0 -, R]</p> <p>Attributes:</p> Name Type Description <code>DVS</code> <code>Series[float]</code> <p>Development stage of the crop.</p> <code>MAX_RESP_FACTOR</code> <code>Series[float]</code> <p>Ratio root total respiration / maintenance respiration.</p> Source code in <code>pyswap/plant/tables.py</code> <pre><code>class MRFTB(BaseModel):\n    \"\"\"Ratio root total respiration / maintenance respiration [1..5.0 -, R]\n\n    Attributes:\n        DVS (Series[float]): Development stage of the crop.\n        MAX_RESP_FACTOR (Series[float]): Ratio root total respiration / maintenance respiration.\n    \"\"\"\n\n    DVS: Series[float] = pa.Field(**DVSRANGE)\n    MAX_RESP_FACTOR: Series[float] = pa.Field(ge=1.0, le=5.0)\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.tables.RDCTB","title":"<code>RDCTB</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>List root density [0..100 cm/cm3, R] as function of relative rooting depth [0..1 -, R]</p> <p>Attributes:</p> Name Type Description <code>RRD</code> <code>Series[float]</code> <p>Relative rooting depth of the crop.</p> <code>RDENS</code> <code>Series[float]</code> <p>Root density of the crop.</p> Source code in <code>pyswap/plant/tables.py</code> <pre><code>class RDCTB(BaseModel):\n    \"\"\"List root density [0..100 cm/cm3, R] as function of relative rooting depth [0..1 -, R]\n\n    Attributes:\n        RRD (Series[float]): Relative rooting depth of the crop.\n        RDENS (Series[float]): Root density of the crop.\n\n    \"\"\"\n    RRD: Series[float] = pa.Field(ge=0.0, le=100.0)\n    RDENS: Series[float] = pa.Field(**UNITRANGE)\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.tables.RDRRTB","title":"<code>RDRRTB</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>relative death rates of roots [kg/kg/d] as function of development stage [0..2 -, R]</p> <p>Attributes:</p> Name Type Description <code>DVS</code> <code>Series[float]</code> <p>Development stage of the crop.</p> <code>RDRR</code> <code>Series[float]</code> <p>Relative death rates of roots.</p> Source code in <code>pyswap/plant/tables.py</code> <pre><code>class RDRRTB(BaseModel):\n    \"\"\"relative death rates of roots [kg/kg/d] as function of development stage [0..2 -, R]\n\n    Attributes:\n        DVS (Series[float]): Development stage of the crop.\n        RDRR (Series[float]): Relative death rates of roots.\n    \"\"\"\n\n    DVS: Series[float] = pa.Field(**DVSRANGE)\n    RDRR: Series[float] = pa.Field(ge=0.0)\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.tables.RDRRTB_GRASS","title":"<code>RDRRTB_GRASS</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>relative death rates of roots [kg/kg/d] as function of development stage [0..2 -, R]</p> <p>Attributes:</p> Name Type Description <code>DNR</code> <code>Series[float]</code> <p>Day number.</p> <code>RDRR</code> <code>Series[float]</code> <p>Relative death rates of roots.</p> Source code in <code>pyswap/plant/tables.py</code> <pre><code>class RDRRTB_GRASS(BaseModel):\n    \"\"\"relative death rates of roots [kg/kg/d] as function of development stage [0..2 -, R]\n\n    Attributes:\n        DNR (Series[float]): Day number.\n        RDRR (Series[float]): Relative death rates of roots.\n    \"\"\"\n\n    DNR: Series[float] = pa.Field(**YEARRANGE)\n    RDRR: Series[float] = pa.Field(ge=0.0)\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.tables.RDRSTB","title":"<code>RDRSTB</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>relative death rates of stems [kg/kg/d] as function of development stage [0..2 -, R]</p> <p>Attributes:</p> Name Type Description <code>DVS</code> <code>Series[float]</code> <p>Development stage of the crop.</p> <code>RDRS</code> <code>Series[float]</code> <p>Relative death rates of stems.</p> Source code in <code>pyswap/plant/tables.py</code> <pre><code>class RDRSTB(BaseModel):\n    \"\"\"relative death rates of stems [kg/kg/d] as function of development stage [0..2 -, R]\n\n    Attributes:\n        DVS (Series[float]): Development stage of the crop.\n        RDRS (Series[float]): Relative death rates of stems.\n    \"\"\"\n\n    DVS: Series[float] = pa.Field(**DVSRANGE)\n    RDRS: Series[float] = pa.Field(ge=0.0)\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.tables.RDRSTB_GRASS","title":"<code>RDRSTB_GRASS</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>relative death rates of stems [kg/kg/d] as function of development stage [0..2 -, R]</p> <p>Attributes:</p> Name Type Description <code>DNR</code> <code>Series[float]</code> <p>Day number.</p> <code>RDRS</code> <code>Series[float]</code> <p>Relative death rates of stems.</p> Source code in <code>pyswap/plant/tables.py</code> <pre><code>class RDRSTB_GRASS(BaseModel):\n    \"\"\"relative death rates of stems [kg/kg/d] as function of development stage [0..2 -, R]\n\n    Attributes:\n        DNR (Series[float]): Day number.\n        RDRS (Series[float]): Relative death rates of stems.\n    \"\"\"\n\n    DNR: Series[float] = pa.Field(**YEARRANGE)\n    RDRS: Series[float] = pa.Field(ge=0.0)\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.tables.RDTB","title":"<code>RDTB</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Rooting Depth [0..1000 cm, R], as a function of development stage [0..2 -, R].</p> <p>Attributes:</p> Name Type Description <code>DVS</code> <code>Series[float]</code> <p>Development stage of the crop.</p> <code>RD</code> <code>Series[float]</code> <p>Rooting depth of the crop.</p> Source code in <code>pyswap/plant/tables.py</code> <pre><code>class RDTB(BaseModel):\n    \"\"\"Rooting Depth [0..1000 cm, R], as a function of development stage [0..2 -, R].\n\n    Attributes:\n        DVS (Series[float]): Development stage of the crop.\n        RD (Series[float]): Rooting depth of the crop.\n    \"\"\"\n\n    DVS: Series[float] = pa.Field(**DVSRANGE)\n    RD: Series[float] = pa.Field(ge=0.0, le=100.0)\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.tables.RFSETB","title":"<code>RFSETB</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>reduction factor of senescence [-, R] as function of development stage [0..2 -, R]</p> <p>Attributes:</p> Name Type Description <code>DVS</code> <code>Series[float]</code> <p>Development stage of the crop.</p> <code>RFSE</code> <code>Series[float]</code> <p>Reduction factor of senescence.</p> Source code in <code>pyswap/plant/tables.py</code> <pre><code>class RFSETB(BaseModel):\n    \"\"\"reduction factor of senescence [-, R] as function of development stage [0..2 -, R]\n\n    Attributes:\n        DVS (Series[float]): Development stage of the crop.\n        RFSE (Series[float]): Reduction factor of senescence.\n    \"\"\"\n\n    DVS: Series[float] = pa.Field(**DVSRANGE)\n    RFSE: Series[float] = pa.Field(ge=0.0, le=1.0)\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.tables.RFSETB_GRASS","title":"<code>RFSETB_GRASS</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>reduction factor of senescence [-, R] as function of development stage [0..2 -, R]</p> <p>Attributes:</p> Name Type Description <code>DNR</code> <code>Series[float]</code> <p>Day number.</p> <code>RFSE</code> <code>Series[float]</code> <p>Reduction factor of senescence.</p> Source code in <code>pyswap/plant/tables.py</code> <pre><code>class RFSETB_GRASS(BaseModel):\n    \"\"\"reduction factor of senescence [-, R] as function of development stage [0..2 -, R]\n\n    Attributes:\n        DNR (Series[float]): Day number.\n        RFSE (Series[float]): Reduction factor of senescence.\n    \"\"\"\n\n    DNR: Series[float] = pa.Field(**YEARRANGE)\n    RFSE: Series[float] = pa.Field(**UNITRANGE)\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.tables.RLWTB","title":"<code>RLWTB</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>rooting depth RL [0..5000 cm, R] as function of root weight RW [0..5000 kg DM/ha, R]</p> <p>Attributes:</p> Name Type Description <code>RW</code> <code>Series[float]</code> <p>rooting depth</p> <code>RL</code> <code>Series[float]</code> <p>root weight</p> Source code in <code>pyswap/plant/tables.py</code> <pre><code>class RLWTB(BaseModel):\n    \"\"\"rooting depth RL [0..5000 cm, R] as function of root weight RW [0..5000 kg DM/ha, R]\n\n    Attributes:\n        RW (Series[float]): rooting depth\n        RL (Series[float]): root weight\n    \"\"\"\n\n    RW: Series[float] = pa.Field(ge=0.0, le=5000.0)\n    RL: Series[float] = pa.Field(ge=0.0, le=5000.0)\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.tables.SLATB","title":"<code>SLATB</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>leaf area [0..1 ha/kg, R] as function of crop development stage [0..2 -, R]</p> <p>Attributes:</p> Name Type Description <code>DVS</code> <code>Series[float]</code> <p>Development stage of the crop.</p> <code>SLA</code> <code>Series[float]</code> <p>Leaf area.</p> Source code in <code>pyswap/plant/tables.py</code> <pre><code>class SLATB(BaseModel):\n    \"\"\"leaf area [0..1 ha/kg, R] as function of crop development stage [0..2 -, R]\n\n    Attributes:\n        DVS (Series[float]): Development stage of the crop.\n        SLA (Series[float]): Leaf area.\n    \"\"\"\n\n    DVS: Series[float] = pa.Field(**DVSRANGE)\n    SLA: Series[float] = pa.Field(ge=0.0, le=1.0)\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.tables.SLATB_GRASS","title":"<code>SLATB_GRASS</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>leaf area [0..1 ha/kg, R] as function of crop development stage [0..2 -, R]</p> <p>Attributes:</p> Name Type Description <code>DNR</code> <code>Series[float]</code> <p>Day number.</p> <code>SLA</code> <code>Series[float]</code> <p>Leaf area.</p> Source code in <code>pyswap/plant/tables.py</code> <pre><code>class SLATB_GRASS(BaseModel):\n    \"\"\"leaf area [0..1 ha/kg, R] as function of crop development stage [0..2 -, R]\n\n    Attributes:\n        DNR (Series[float]): Day number.\n        SLA (Series[float]): Leaf area.\n    \"\"\"\n\n    DNR: Series[float] = pa.Field(**YEARRANGE)\n    SLA: Series[float] = pa.Field(ge=0.0, le=1.0)\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.tables.TMNFTB","title":"<code>TMNFTB</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>reduction factor of AMAX [-, R] as function of minimum day temperature [-10..50 oC, R]</p> <p>Attributes:</p> Name Type Description <code>TMNR</code> <code>Series[float]</code> <p>Minimum temperature.</p> <code>TMNF</code> <code>Series[float]</code> <p>Reduction factor of AMAX.</p> Source code in <code>pyswap/plant/tables.py</code> <pre><code>class TMNFTB(BaseModel):\n    \"\"\"reduction factor of AMAX [-, R] as function of minimum day temperature [-10..50 oC, R]\n\n    Attributes:\n        TMNR (Series[float]): Minimum temperature.\n        TMNF (Series[float]): Reduction factor of AMAX.\n    \"\"\"\n\n    TMNR: Series[float] = pa.Field(ge=-10.0, le=50.0)\n    TMNF: Series[float] = pa.Field(ge=0.0, le=1.0)\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.tables.TMPFTB","title":"<code>TMPFTB</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>reduction factor of AMAX [-, R] as function of average day temperature [-10..50 oC, R]</p> <p>Attributes:</p> Name Type Description <code>TAVD</code> <code>Series[float]</code> <p>Minimum temperature.</p> <code>TMPF</code> <code>Series[float]</code> <p>Reduction factor of AMAX.</p> Source code in <code>pyswap/plant/tables.py</code> <pre><code>class TMPFTB(BaseModel):\n    \"\"\"reduction factor of AMAX [-, R] as function of average day temperature [-10..50 oC, R]\n\n    Attributes:\n        TAVD (Series[float]): Minimum temperature.\n        TMPF (Series[float]): Reduction factor of AMAX.\n    \"\"\"\n\n    TAVD: Series[float] = pa.Field(ge=-10.0, le=50.0)\n    TMPF: Series[float] = pa.Field(ge=0.0, le=1.0)\n</code></pre>"},{"location":"reference/api-reference/#pyswap.plant.tables.WRTB","title":"<code>WRTB</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>dry weight of roots at soil surface [0..10 kg/m3, R], as a function of development stage [0..2 -,R]</p> <p>Attributes:</p> Name Type Description <code>DVS</code> <code>Series[float]</code> <p>Development stage of the crop.</p> <code>W_ROOT_SS</code> <code>Series[float]</code> <p>Dry weight of roots at soil surface.</p> Source code in <code>pyswap/plant/tables.py</code> <pre><code>class WRTB(BaseModel):\n    \"\"\"dry weight of roots at soil surface [0..10 kg/m3, R], as a function of development stage [0..2 -,R]\n\n    Attributes:\n        DVS (Series[float]): Development stage of the crop.\n        W_ROOT_SS (Series[float]): Dry weight of roots at soil surface.\n    \"\"\"\n\n    DVS: Series[float] = pa.Field(**DVSRANGE)\n    W_ROOT_SS: Series[float] = pa.Field(ge=0.0, le=10.0)\n</code></pre>"},{"location":"reference/api-reference/#pyswap.irrigation--irrigation_subpackage","title":"Irrigation subpackage","text":"<p>Irrigation settings for the SWAP simulation.</p> <p>Modules:</p> Name Description <code>irrigation</code> <p>The irrigation settings.</p> <code>irgfile</code> <p>The irrigation file.</p>"},{"location":"reference/api-reference/#pyswap.irrigation.irgfile","title":"<code>irgfile</code>","text":"<p>Create the irrigation file for the SWAP model.</p> <p>Classes:</p> Name Description <code>IrrigationFile</code> <p>The irrigation file.</p>"},{"location":"reference/api-reference/#pyswap.irrigation.irgfile.IrgFile","title":"<code>IrgFile</code>","text":"<p>               Bases: <code>PySWAPBaseModel</code></p> <p>The irrigation file.</p> <p>Warning</p> <p>The irrigation file is the first to have pandera validation. However,  it is not yet complete. Some columns are set to non-required, but they might be required if solute transport is used.</p> <p>Attributes:</p> Name Type Description <code>irgfil</code> <code>str</code> <p>the name of the irgfile without .irg extension.</p> <code>content</code> <code>DataFrame</code> <p>The content of the irrigation file.</p> Source code in <code>pyswap/irrigation/irgfile.py</code> <pre><code>class IrgFile(PySWAPBaseModel):\n    \"\"\"The irrigation file.\n\n    !!! warning\n        The irrigation file is the first to have pandera validation. However, \n        it is not yet complete. Some columns are set to non-required, but they\n        might be required if solute transport is used.\n\n    Attributes:\n        irgfil (str): the name of the irgfile without .irg extension.\n        content (DataFrame): The content of the irrigation file.\n    \"\"\"\n\n    irgfil: str\n    content: DataFrame = Field(exclude=True)\n</code></pre>"},{"location":"reference/api-reference/#pyswap.irrigation.irgfile.irg_from_csv","title":"<code>irg_from_csv(irgfil, path)</code>","text":"<p>Load the irrigation file from a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>irgfil</code> <code>str</code> <p>the name of the irgfile without .irg extension.</p> required <code>path</code> <code>str</code> <p>The path to the CSV file.</p> required <p>Returns:</p> Name Type Description <code>IrgFile</code> <code>IrgFile</code> <p>The irrigation file.</p> Source code in <code>pyswap/irrigation/irgfile.py</code> <pre><code>def irg_from_csv(irgfil: str, path: str) -&gt; IrgFile:\n    \"\"\"Load the irrigation file from a CSV file.\n\n    Parameters:\n        irgfil (str): the name of the irgfile without .irg extension.\n        path (str): The path to the CSV file.\n\n    Returns:\n        IrgFile: The irrigation file.\n    \"\"\"\n    return IrgFile(content=read_csv(path), irgfil=irgfil)\n</code></pre>"},{"location":"reference/api-reference/#pyswap.irrigation.irrigation","title":"<code>irrigation</code>","text":"<p>\" Irrigation settings for the SWAP simuluation.</p> <p>Classes:</p> Name Description <code>FixedIrrigation</code> <p>Holds the settings for fixed irrigation.</p> <code>ScheduledIrrigation</code> <p>Holds the settings for scheduled irrigation.</p> <code>Irrigation</code> <p>Holds the irrigation settings of the simulation.</p>"},{"location":"reference/api-reference/#pyswap.irrigation.irrigation.FixedIrrigation","title":"<code>FixedIrrigation</code>","text":"<p>               Bases: <code>PySWAPBaseModel</code></p> <p>Fixed irrigation settings.</p> <p>Note</p> <p>This class is only used in the .swp file.</p> <p>Attributes:</p> Name Type Description <code>swirfix</code> <code>Literal[0, 1]</code> <p>Switch for fixed irrigation applications</p> <code>swirgfil</code> <code>Literal[0, 1]</code> <p>Switch for separate file with fixed irrigation applications</p> <code>table_irrigevents</code> <code>Optional[Table]</code> <code>irgfil</code> <code>Optional[str]</code> <code>irrigationdata</code> <code>Optional[IrrigationFile]</code> Source code in <code>pyswap/irrigation/irrigation.py</code> <pre><code>class FixedIrrigation(PySWAPBaseModel):\n    \"\"\"Fixed irrigation settings.\n\n    !!! note\n        This class is only used in the .swp file.\n\n    Attributes:\n        swirfix (Literal[0, 1]): Switch for fixed irrigation applications\n        swirgfil (Literal[0, 1]): Switch for separate file with fixed irrigation applications\n        table_irrigevents (Optional[Table]):\n        irgfil (Optional[str]):\n        irrigationdata (Optional[IrrigationFile]):\n    \"\"\"\n\n    swirfix: Literal[0, 1]\n    swirgfil: Optional[Literal[0, 1]] = None\n    table_irrigevents: Optional[Table] = None\n    irgfile: Optional[IrgFile] = Field(\n        default=None, repr=False)\n\n    @model_validator(mode='after')\n    def _validate_fixed_irrigation(self) -&gt; Self:\n        if self.swirfix == 1:\n            if self.swirgfil:\n                assert self.irgfile is not None, \"irgfile is required when swirgfil is True\"\n            else:\n                assert self.table_irrigevents is not None, \"irrigevents is required when swirgfil is False\"\n\n        return self\n</code></pre>"},{"location":"reference/api-reference/#pyswap.irrigation.irrigation.ScheduledIrrigation","title":"<code>ScheduledIrrigation</code>","text":"<p>               Bases: <code>PySWAPBaseModel</code></p> <p>Irrigation scheduling settings.</p> <p>Warning</p> <p>The docstring needs to be updated.</p> <p>Note</p> <p>This class is only used in the .crp file.</p> <p>Attributes:</p> Name Type Description <code>schedule</code> <code>Literal[0, 1]</code> <p>Switch for application irrigation scheduling</p> <code>startirr</code> <code>str</code> <p>Specify day and month at which irrigation scheduling starts</p> <code>endirr</code> <code>str</code> <p>Specify day and month at which irrigation scheduling stops</p> <code>cirrs</code> <code>float</code> <p>Solute concentration of irrigation water</p> <code>isuas</code> <code>int</code> <p>Switch for type of irrigation method</p> <ul> <li>0 - Sprinkler irrigation</li> <li>1 - Surface irrigation</li> </ul> <code>tcs</code> <code>int</code> <p>Choose one of the following timing criteria options</p> <ul> <li>1 - Ratio actual/potential transpiration</li> <li>2 - Depletion of Readily Available Water</li> <li>3 - Depletion of Totally Available Water</li> <li>4 - Depletion of absolute Water Amount</li> <li>6 - Fixed weekly irrigation</li> <li>7 - Pressure head</li> <li>8 - Moisture content</li> </ul> <code>phFieldCapacity</code> <code>float</code> <p>Soil water pressure head at field capacity</p> <code>irgthreshold</code> <code>Optional[float]</code> <p>Threshold value for weekly irrigation</p> <code>dcrit</code> <code>Optional[float]</code> <p>Depth of the sensor</p> <code>swcirrthres</code> <code>Optional[bool]</code> <p>Switch for over-irrigation</p> <code>cirrthres</code> <code>Optional[float]</code> <p>Threshold salinity concentration above which over-irrigation occur</p> <code>perirrsurp</code> <code>Optional[float]</code> <p>Over-irrigation of the usually scheduled irrigation depth</p> <code>tcsfix</code> <code>Optional[int]</code> <p>Switch for minimum time interval between irrigation applications</p> <code>irgdayfix</code> <code>Optional[int]</code> <p>Minimum number of days between irrigation applications</p> <code>phormc</code> <code>Optional[int]</code> <p>Switch for the use of pressure head or water content</p> <ul> <li>0 - Pressure head</li> <li>1 - Water content</li> </ul> <code>dvs_tc1</code> <code>Optional[Table]</code> <code>dvs_tc2</code> <code>Optional[Table]</code> <code>dvs_tc3</code> <code>Optional[Table]</code> <code>dvs_tc4</code> <code>Optional[Table]</code> <code>dvs_tc5</code> <code>Optional[Table]</code> Source code in <code>pyswap/irrigation/irrigation.py</code> <pre><code>class ScheduledIrrigation(PySWAPBaseModel):\n    \"\"\"Irrigation scheduling settings.\n\n    !!! warning\n        The docstring needs to be updated.\n\n    !!! note\n        This class is only used in the .crp file.\n\n    Attributes:\n        schedule (Literal[0, 1]): Switch for application irrigation scheduling\n        startirr (str): Specify day and month at which irrigation scheduling starts\n        endirr (str): Specify day and month at which irrigation scheduling stops\n        cirrs (float): Solute concentration of irrigation water\n        isuas (int): Switch for type of irrigation method\n\n            * 0 - Sprinkler irrigation\n            * 1 - Surface irrigation\n\n        tcs (int): Choose one of the following timing criteria options\n\n            * 1 - Ratio actual/potential transpiration\n            * 2 - Depletion of Readily Available Water\n            * 3 - Depletion of Totally Available Water\n            * 4 - Depletion of absolute Water Amount\n            * 6 - Fixed weekly irrigation\n            * 7 - Pressure head\n            * 8 - Moisture content\n\n        phFieldCapacity (float): Soil water pressure head at field capacity\n        irgthreshold (Optional[float]): Threshold value for weekly irrigation\n        dcrit (Optional[float]): Depth of the sensor\n        swcirrthres (Optional[bool]): Switch for over-irrigation\n        cirrthres (Optional[float]): Threshold salinity concentration above which over-irrigation occur\n        perirrsurp (Optional[float]): Over-irrigation of the usually scheduled irrigation depth\n        tcsfix (Optional[int]): Switch for minimum time interval between irrigation applications\n        irgdayfix (Optional[int]): Minimum number of days between irrigation applications\n        phormc (Optional[int]): Switch for the use of pressure head or water content\n\n            * 0 - Pressure head\n            * 1 - Water content\n\n        dvs_tc1 (Optional[Table]):\n        dvs_tc2 (Optional[Table]):\n        dvs_tc3 (Optional[Table]):\n        dvs_tc4 (Optional[Table]):\n        dvs_tc5 (Optional[Table]):\n    \"\"\"\n    schedule: Literal[0, 1]\n    startirr: Optional[DayMonth] = None\n    endirr: Optional[DayMonth] = None\n    cirrs: Optional[float] = Field(default=None, ge=0.0, le=100.0)\n    isuas: Optional[Literal[0, 1]] = None\n    tcs: Optional[Literal[1, 2, 3, 4, 6, 7, 8]] = None\n    phfieldcapacity: Optional[float] = Field(default=None, ge=-1000.0, le=0.0)\n    irgthreshold: Optional[float] = Field(default=None, ge=0.0, le=20.0)\n    dcrit: Optional[float] = Field(default=None, ge=-100.0, le=0.0)\n    swcirrthres: Optional[Literal[0, 1]] = None\n    cirrthres: Optional[float] = Field(default=None, ge=0.0, le=100.0)\n    perirrsurp: Optional[float] = Field(default=None, ge=0.0, le=100.0)\n    tcsfix: Optional[Literal[0, 1]] = None\n    irgdayfix: Optional[int] = Field(default=None, **YEARRANGE)\n    dcs: Optional[Literal[0, 1]] = None\n    dcslim: Optional[Literal[0, 1]] = None\n    irgdepmin: Optional[float] = Field(default=None, ge=0.0, le=100.0)\n    irgdepmax: Optional[float] = Field(default=None, ge=0.0, le=1.0e7)\n    table_tc1tb: Optional[Table] = None\n    table_tc2tb: Optional[Table] = None\n    table_tc3tb: Optional[Table] = None\n    table_tc4tb: Optional[Table] = None\n    table_tc7tb: Optional[Table] = None\n    table_tc8tb: Optional[Table] = None\n\n    @model_validator(mode='after')\n    def _validate_scheduled_irrigation(self) -&gt; Self:\n\n        if self.tcs == 1:\n            self.dvs_tc1 = {'dvs_tc1': [0.0, 2.0],\n                            'Trel': [0.95, 0.95]}\n        elif self.tcs == 2:\n            self.dvs_tc2 = {'dvs_tc2': [0.0, 2.0],\n                            'RAW': [0.95, 0.95]}\n        elif self.tcs == 3:\n            self.dvs_tc3 = {'dvs_tc3': [0.0, 2.0],\n                            'TAW': [0.50, 0.50]}\n        elif self.tcs == 4:\n            self.dvs_tc4 = {'dvs_tc4': [0.0, 2.0],\n                            'DWA': [0.40, 0.40]}\n        elif self.tcs == 5:\n            self.dvs_tc5 = {'dvs_tc5': [0.0, 2.0],\n                            'Value_tc5': [-1000.0, -1000.0]}\n        elif self.tcs == 6:\n            assert self.irgthreshold is not None, \"irgthreshold is required when tcs is 6\"\n            assert self.tcsfix is not None, \"tcsfix is required when tcs is 6\"\n            if self.tcsfix:\n                assert self.irgdayfix is not None, \"irgdayfix is required when tcsfix is True\"\n\n        return self\n</code></pre>"},{"location":"reference/api-reference/#pyswap.irrigation.tables","title":"<code>tables</code>","text":"<p>Tables for the irrigation settings.</p> <p>Classes:</p>"},{"location":"reference/api-reference/#pyswap.irrigation.tables.IRRIGATION","title":"<code>IRRIGATION</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>information for each fixed irrigation event.</p> <p>Attributes:</p> Name Type Description <code>IRDATE</code> <code>Series[datetime]</code> <p>date of irrigation.</p> <code>IRDEPTH</code> <code>Series[float]</code> <p>amount of water [0..1000 mm, R].</p> <code>IRCONC</code> <code>Series[float]</code> <p>concentration of irrigation water [0..1000 mg/cm3, R].</p> <code>IRTYPE</code> <code>Series[int]</code> <p>type of irrigation </p> <ul> <li>0 - sprinkling </li> <li>1 - surface</li> </ul> Source code in <code>pyswap/irrigation/tables.py</code> <pre><code>class IRRIGATION(BaseModel):\n    \"\"\"information for each fixed irrigation event.\n\n    Attributes:\n        IRDATE (Series[datetime]):date of irrigation.\n        IRDEPTH (Series[float]): amount of water [0..1000 mm, R].\n        IRCONC (Series[float]): concentration of irrigation water [0..1000 mg/cm3, R].\n        IRTYPE (Series[int]): type of irrigation \n\n            * 0 - sprinkling \n            * 1 - surface\n\n    \"\"\"\n\n    IRDATE: Series[pa.DateTime]\n    IRDEPTH: Series[float] = pa.Field(ge=0.0, le=1000.0)\n    IRCONC: Series[float] = pa.Field(ge=0.0, le=1000.0)\n    IRTYPE: Series[int] = pa.Field(ge=0, le=1)\n</code></pre>"},{"location":"reference/api-reference/#pyswap.soilwater--soil-water_subpackage","title":"Soil-water subpackage","text":"<p>Settings related to soil and water.</p> <p>Modules:</p> Name Description <code>evaporation</code> <p>Evaporation settings.</p> <code>soilmoisture</code> <p>Soil moisture settings.</p> <code>soilprofile</code> <p>Soil profile settings.</p> <code>surfaceflow</code> <p>Surface flow settings.</p> <code>snow</code> <p>Snow and frost settings.</p>"},{"location":"reference/api-reference/#pyswap.soilwater.evaporation","title":"<code>evaporation</code>","text":"<p>Settings for evaporation.</p> <p>Classes:</p> Name Description <code>Evaporation</code> <p>Evaporation settings.</p>"},{"location":"reference/api-reference/#pyswap.soilwater.evaporation.Evaporation","title":"<code>Evaporation</code>","text":"<p>               Bases: <code>PySWAPBaseModel</code></p> <p>Evaporation settings.</p> <p>Attributes:</p> Name Type Description <code>swcfbs</code> <code>int</code> <p>Switch for use of soil factor CFBS to calculate Epot from ETref</p> <code>swredu</code> <code>int</code> <p>Switch for the method for reduction of potential soil evaporation:</p> <ul> <li>0 - reduction to maximum Darcy flux.</li> <li>1 - reduction to maximum Darcy flux and to maximum Black (1969).</li> <li>2 - reduction to maximum Darcy flux and to maximum Boesten/Stroosnijder (1986).</li> </ul> <code>cfevappond</code> <code>Optional[float]</code> <p>hen ETref is used, evaporation coefficient in case of ponding.</p> <code>cfbs</code> <code>Optional[float]</code> <p>Coefficient for potential soil evaporation.</p> <code>rsoil</code> <code>Optional[float]</code> <p>Soil resistance of wet soil.</p> <code>cofredbl</code> <code>Optional[float]</code> <p>Soil evaporation coefficient of Black.</p> <code>rsigni</code> <code>Optional[float]</code> <p>Minimum rainfall to reset method of Black.</p> <code>cofredbo</code> <code>Optional[float]</code> <p>Soil evaporation coefficient of Boesten/Stroosnijder.</p> Source code in <code>pyswap/soilwater/evaporation.py</code> <pre><code>class Evaporation(PySWAPBaseModel):\n    \"\"\"Evaporation settings.\n\n    Attributes:\n        swcfbs (int): Switch for use of soil factor CFBS to calculate Epot from ETref\n        swredu (int): Switch for the method for reduction of potential soil evaporation:\n\n            * 0 - reduction to maximum Darcy flux.\n            * 1 - reduction to maximum Darcy flux and to maximum Black (1969).\n            * 2 - reduction to maximum Darcy flux and to maximum Boesten/Stroosnijder (1986).\n\n        cfevappond (Optional[float]): hen ETref is used, evaporation coefficient in case of ponding.\n        cfbs (Optional[float]): Coefficient for potential soil evaporation.\n        rsoil (Optional[float]): Soil resistance of wet soil.\n        cofredbl (Optional[float]): Soil evaporation coefficient of Black.\n        rsigni (Optional[float]): Minimum rainfall to reset method of Black.\n        cofredbo (Optional[float]): Soil evaporation coefficient of Boesten/Stroosnijder.\n    \"\"\"\n    swcfbs: Literal[0, 1]\n    swredu: Literal[0, 1, 2]\n    cfevappond: Optional[float] = None  # this is used if ETref is used\n    cfbs: Optional[float] = None\n    rsoil: Optional[float] = None\n    cofredbl: Optional[float] = None\n    rsigni: Optional[float] = None\n    cofredbo: Optional[float] = None\n\n    @model_validator(mode='after')\n    def _validate_evaporation(self) -&gt; Self:\n\n        if self.swcfbs:\n            assert self.cfbs is not None, \"cfbs is required when swcfbs is True\"\n\n        if self.swredu == 1:\n            assert self.cofredbl is not None, \"cofredbl is required when swredu is 1\"\n            assert self.rsigni is not None, \"rsigni is required when swredu is 1\"\n\n        elif self.swredu == 2:\n            assert self.cofredbo is not None, \"cofredbo is required when swredu is 2\"\n\n        return self\n</code></pre>"},{"location":"reference/api-reference/#pyswap.soilwater.snow","title":"<code>snow</code>","text":""},{"location":"reference/api-reference/#pyswap.soilwater.snow.SnowAndFrost","title":"<code>SnowAndFrost</code>","text":"<p>               Bases: <code>PySWAPBaseModel</code></p> <p>Snow and frost settings for the model.</p> <p>Attributes:</p> Name Type Description <code>swsnow</code> <code>Literal[0, 1]</code> <p>Switch for calculation of snow accumulation and melt.</p> <code>swfrost</code> <code>Literal[0, 1]</code> <p>Switch,  in case of frost reduce soil water flow</p> <code>snowinco</code> <code>Optional[float]</code> <p>Initial snow water equivalent</p> <code>teprrain</code> <code>Optional[float]</code> <p>Temperature above which all precipitation is rain</p> <code>teprsnow</code> <code>Optional[float]</code> <p>Temperature below which all precipitation is snow</p> <code>snowcoef</code> <code>Optional[float]</code> <p>Snowmelt calibration factor</p> <code>tfroststa</code> <code>Optional[float]</code> <p>Soil temperature (oC) where reduction of water fluxes starts</p> <code>tfrostend</code> <code>Optional[float]</code> <p>Soil temperature (oC) where reduction of water fluxes ends</p> Source code in <code>pyswap/soilwater/snow.py</code> <pre><code>class SnowAndFrost(PySWAPBaseModel):\n    \"\"\"Snow and frost settings for the model.\n\n    Attributes:\n        swsnow (Literal[0, 1]): Switch for calculation of snow accumulation and melt.\n        swfrost (Literal[0, 1]): Switch,  in case of frost reduce soil water flow\n        snowinco (Optional[float]): Initial snow water equivalent\n        teprrain (Optional[float]): Temperature above which all precipitation is rain\n        teprsnow (Optional[float]): Temperature below which all precipitation is snow\n        snowcoef (Optional[float]): Snowmelt calibration factor\n        tfroststa (Optional[float]): Soil temperature (oC) where reduction of water fluxes starts\n        tfrostend (Optional[float]): Soil temperature (oC) where reduction of water fluxes ends\n\n    \"\"\"\n\n    swsnow: Literal[0, 1]\n    swfrost: Literal[0, 1]\n    snowinco: Optional[float] = None\n    teprrain: Optional[float] = None\n    teprsnow: Optional[float] = None\n    snowcoef: Optional[float] = None\n    tfrostst: Optional[float] = None\n    tfrostend: Optional[float] = None\n\n    @model_validator(mode='after')\n    def _validate_snow_and_frost(self, v) -&gt; Self:\n\n        if self.swsnow == 1:\n            assert self.snowinco is not None, \"snowinco is required when swsnow is True\"\n            assert self.teprrain is not None, \"teprrain is required when swsnow is True\"\n            assert self.teprsnow is not None, \"teprsnow is required when swsnow is True\"\n            assert self.snowcoef is not None, \"snowcoef is required when swsnow is True\"\n\n        if self.swfrost == 1:\n            assert self.tfrostst is not None, \"tfrostst is required when swfrost is True\"\n            assert self.tfrostend is not None, \"tfrostend is required when swfrost is True\"\n\n        return self\n</code></pre>"},{"location":"reference/api-reference/#pyswap.soilwater.soilmoisture","title":"<code>soilmoisture</code>","text":""},{"location":"reference/api-reference/#pyswap.soilwater.soilmoisture.SoilMoisture","title":"<code>SoilMoisture</code>","text":"<p>               Bases: <code>PySWAPBaseModel</code></p> <p>Soil moisture content and water balance.</p> <p>Warning</p> <p>swinco = 3 is not yet implemented. The model will run, but the output will not be retrieved.</p> <p>Attributes:</p> Name Type Description <code>swinco</code> <code>int</code> <p>Switch for the type of initial soil moisture condition:</p> <ul> <li>1 - pressure head as function of soil depth.</li> <li>2 - pressure head of each compartment is in hydrostatic equilibrium with initial groundwater level.</li> <li>3 - read final pressure heads from output file of previous Swap simulation.</li> </ul> <code>table_head_soildepth</code> <code>Optional[Table]</code> <p>Table with head and soil depth data.</p> <code>gwli</code> <code>Optional[float]</code> <p>Initial groundwater level [cm].</p> <code>inifil</code> <code>Optional[str]</code> <p>name of output file *.END which contains initial values.</p> Source code in <code>pyswap/soilwater/soilmoisture.py</code> <pre><code>class SoilMoisture(PySWAPBaseModel):\n    \"\"\"Soil moisture content and water balance.\n\n    !!! warning\n        swinco = 3 is not yet implemented. The model will run, but the output will not be\n        retrieved.\n\n    Attributes:\n        swinco (int): Switch for the type of initial soil moisture condition:\n\n            * 1 - pressure head as function of soil depth.\n            * 2 - pressure head of each compartment is in hydrostatic equilibrium with initial groundwater level.\n            * 3 - read final pressure heads from output file of previous Swap simulation.\n\n        table_head_soildepth (Optional[Table]): Table with head and soil depth data.\n        gwli (Optional[float]): Initial groundwater level [cm].\n        inifil (Optional[str]): name of output file *.END which contains initial values.\n    \"\"\"\n\n    swinco: Literal[1, 2, 3]\n    table_head_soildepth: Optional[Table] = None\n    gwli: Optional[float] = None\n    inifil: Optional[str] = None\n\n    @model_validator(mode='after')\n    def _validate_soil_moisture(self) -&gt; Self:\n\n        if self.swinco == 1:\n            assert self.table_head_soildepth is not None, \"head_soildepth is required when swinco is 1\"\n\n        elif self.swinco == 2:\n            assert self.gwli is not None, \"gwli is required when swinco is 2\"\n\n        else:\n            assert self.inifil is not None, \"inifil is required when swinco is 3\"\n\n        return self\n</code></pre>"},{"location":"reference/api-reference/#pyswap.soilwater.soilprofile","title":"<code>soilprofile</code>","text":""},{"location":"reference/api-reference/#pyswap.soilwater.soilprofile.SoilProfile","title":"<code>SoilProfile</code>","text":"<p>               Bases: <code>PySWAPBaseModel</code></p> <p>Vertical discretization of soil profile, soil hydraulic functions and hysteresis of soil water retention.</p> <p>Covers parts 4, 5, 6 and 7 of the .swp file.</p> <p>Attributes:</p> Name Type Description <code>swsophy</code> <code>Literal[0, 1]</code> <p>Switch for analytical functions or tabular input</p> <ul> <li>0 - Analytical functions with input of Mualem - van Genuchten parameters</li> <li>1 - Soil physical tables</li> </ul> <code>swhyst</code> <code>Literal[0, 1, 2]</code> <p>Hysteresis of soil water retention function</p> <ul> <li>0 - No hysteresis</li> <li>1 - Hysteresis, initial conditions wetting</li> <li>2 - Hysteresis, initial conditions drying</li> </ul> <code>filenamesophy</code> <code>Optional[str]</code> <p>Names of input files with soil hydraulic tables for each soil layer</p> <code>tau</code> <code>Optional[float]</code> <p>Minimum pressure head difference to change wetting-drying</p> <code>swmacro</code> <code>Literal[0, 1]</code> <p>Switch for preferential flow due to macropores</p> <code>table_soilprofile</code> <code>Table</code> <p>Table with soil profile data</p> <code>table_soilhydrfunc</code> <code>Optional[Table]</code> <p>Table with soil hydraulic functions</p> Source code in <code>pyswap/soilwater/soilprofile.py</code> <pre><code>class SoilProfile(PySWAPBaseModel):\n    \"\"\"Vertical discretization of soil profile, soil hydraulic functions and hysteresis of soil water retention.\n\n    Covers parts 4, 5, 6 and 7 of the .swp file.\n\n    Attributes:\n        swsophy (Literal[0, 1]): Switch for analytical functions or tabular input\n\n            * 0 - Analytical functions with input of Mualem - van Genuchten parameters\n            * 1 - Soil physical tables\n\n        swhyst (Literal[0, 1, 2]): Hysteresis of soil water retention function\n\n            * 0 - No hysteresis\n            * 1 - Hysteresis, initial conditions wetting\n            * 2 - Hysteresis, initial conditions drying\n\n        filenamesophy (Optional[str]): Names of input files with soil hydraulic tables for each soil layer\n        tau (Optional[float]): Minimum pressure head difference to change wetting-drying\n        swmacro (Literal[0, 1]): Switch for preferential flow due to macropores\n        table_soilprofile (Table): Table with soil profile data\n        table_soilhydrfunc (Optional[Table]): Table with soil hydraulic functions\n    \"\"\"\n    swsophy: Literal[0, 1]\n    swhyst: Literal[0, 1, 2]\n    swmacro: Literal[0, 1]\n    filenamesophy: Optional[str] = None\n    tau: Optional[float] = None\n    table_soilprofile: Table\n    table_soilhydrfunc: Optional[Table] = None\n\n    @model_validator(mode='after')\n    def _validate_soil_profile(self) -&gt; Self:\n\n        if self.swsophy == 0:\n            assert self.table_soilhydrfunc is not None, \"table_soilhydrfunc is required when swsophy is True\"\n        else:\n            assert self.filenamesophy is not None, \"filenamesophy is required when swsophy is True\"\n        if self.swhyst in range(1, 3):\n            assert self.tau is not None, \"tau is required when swhyst is 1 or 2\"\n\n        return self\n</code></pre>"},{"location":"reference/api-reference/#pyswap.soilwater.surfaceflow","title":"<code>surfaceflow</code>","text":""},{"location":"reference/api-reference/#pyswap.soilwater.surfaceflow.SurfaceFlow","title":"<code>SurfaceFlow</code>","text":"<p>               Bases: <code>PySWAPBaseModel</code></p> <p>Surface flow settings (ponding, runoff and runon).</p> <p>Attributes:</p> Name Type Description <code>swpondmx</code> <code>Literal[0, 1]</code> <p>Switch for variation ponding threshold for runoff</p> <ul> <li>0 - Ponding threshold for runoff is constant</li> <li>1 - Ponding threshold for runoff varies in time</li> </ul> <code>swrunon</code> <code>Literal[0, 1]</code> <p>Switch for runon</p> <ul> <li>0 - No runon</li> <li>1 - Use runon data</li> </ul> <code>rsro</code> <code>float</code> <p>Drainage resistance for surface runoff</p> <code>rsroexp</code> <code>float</code> <p>Exponent for drainage equation of surface runoff</p> <code>pondmx</code> <code>Optional[float]</code> <p>In case of ponding, minimum thickness for runoff</p> <code>rufil</code> <code>Optional[str]</code> <p>Name of the runon file</p> <code>table_pondmxtb</code> <code>Optional[Table]</code> <p>Minimum thickness for runoff as a function of time</p> Source code in <code>pyswap/soilwater/surfaceflow.py</code> <pre><code>class SurfaceFlow(PySWAPBaseModel):\n    \"\"\"Surface flow settings (ponding, runoff and runon).\n\n    Attributes:\n        swpondmx (Literal[0, 1]): Switch for variation ponding threshold for runoff\n\n            * 0 - Ponding threshold for runoff is constant\n            * 1 - Ponding threshold for runoff varies in time\n\n        swrunon (Literal[0, 1]): Switch for runon\n\n            * 0 - No runon\n            * 1 - Use runon data\n\n        rsro (float): Drainage resistance for surface runoff\n        rsroexp (float): Exponent for drainage equation of surface runoff\n        pondmx (Optional[float]): In case of ponding, minimum thickness for runoff\n        rufil (Optional[str]): Name of the runon file\n        table_pondmxtb (Optional[Table]): Minimum thickness for runoff as a function of time\n    \"\"\"\n    swpondmx: Literal[0, 1]\n    swrunon: Literal[0, 1]\n    rsro: float = 0.5\n    rsroexp: float = 1.0\n    pondmx: Optional[float] = None\n    rufil: Optional[str] = None\n    table_pondmxtb: Optional[Table] = None\n\n    @model_validator(mode='after')\n    def _validate_surface_flow(self) -&gt; Self:\n\n        if self.swpondmx == 0:\n            assert self.pondmx is not None, \"pondmx is required when swpondmx is 0\"\n        else:\n            assert self.table_pondmxtb is not None, \"pondmxtb is required when swpondmx is 1\"\n\n        if self.swrunon == 1:\n            assert self.rufil is not None, \"runfil is required when swrunon is 1\"\n\n        return self\n</code></pre>"},{"location":"reference/api-reference/#pyswap.soilwater.tables","title":"<code>tables</code>","text":"<p>tables for the soil-water module</p>"},{"location":"reference/api-reference/#pyswap.soilwater.tables.INIPRESSUREHEAD","title":"<code>INIPRESSUREHEAD</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Initial pressure head [cm, R] as a function of soil layer [1..N, I].</p> <p>Attributes:</p> Name Type Description <code>ZI</code> <code>Series[int]</code> <p>Series[int]: soil depth [-1.d5..0 cm, R].</p> <code>H</code> <code>Series[float]</code> <p>Series[float]: Initial soil water pressure head [-1.d10..1.d4 cm, R].</p> Source code in <code>pyswap/soilwater/tables.py</code> <pre><code>class INIPRESSUREHEAD(BaseModel):\n    \"\"\"Initial pressure head [cm, R] as a function of soil layer [1..N, I].\n\n    Attributes:\n        ZI: Series[int]: soil depth [-1.d5..0 cm, R].\n        H: Series[float]: Initial soil water pressure head [-1.d10..1.d4 cm, R].\n    \"\"\"\n\n    ZI: Series[int] = pa.Field(ge=-1.0e5, le=0.0)\n    H: Series[float] = pa.Field(ge=-1.0e10, le=1.0e4)\n</code></pre>"},{"location":"reference/api-reference/#pyswap.soilwater.tables.MXPONDTB","title":"<code>MXPONDTB</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>minimum thickness for runoff PONDMXTB [0..1000 cm, R] as function of time</p> <p>Attributes:</p> Name Type Description <code>DATEPMX</code> <code>Series[DateTime]</code> <p>Series[pa.DateTime]: Date of the ponding threshold for runoff.</p> <code>PONDMXTB</code> <code>Series[float]</code> <p>Series[float]: Minimum thickness for runoff.</p> Source code in <code>pyswap/soilwater/tables.py</code> <pre><code>class MXPONDTB(BaseModel):\n    \"\"\"minimum thickness for runoff PONDMXTB [0..1000 cm, R] as function of time\n\n    Attributes:\n        DATEPMX: Series[pa.DateTime]: Date of the ponding threshold for runoff.\n        PONDMXTB: Series[float]: Minimum thickness for runoff.\n    \"\"\"\n    DATEPMX: Series[pa.DateTime]\n    PONDMXTB: Series[float]\n</code></pre>"},{"location":"reference/api-reference/#pyswap.soilwater.tables.SOILHYDRFUNC","title":"<code>SOILHYDRFUNC</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Soil hydraulic functions table.</p> <p>Warning</p> <p>ALFAW required only when the hysteresis option is set to 1 or 2. This column is set as optional column and (for now) is not checked.</p> <p>Attributes:</p> Name Type Description <code>ORES</code> <code>Series[float]</code> <p>Residual water content [0..1 cm3/cm3, R]</p> <code>OSAT</code> <code>Series[float]</code> <p>Saturated water content [0..1 cm3/cm3, R]</p> <code>ALFA</code> <code>Series[float]</code> <p>Parameter alfa of main drying curve [0.0001..100 /cm, R]</p> <code>NPAR</code> <code>Series[float]</code> <p>Parameter n [1.001..9 -, R]</p> <code>LEXP</code> <code>Series[float]</code> <p>Exponent in hydraulic conductivity function [-25..25 -, R]</p> <code>KSATFIT</code> <code>Series[float]</code> <p>Fitting parameter Ksat of hydraulic conductivity function [1.d-5..1d5 cm/d, R]</p> <code>H_ENPR</code> <code>Series[float]</code> <p>Air entry pressure head [-40.0..0.0 cm, R]</p> <code>KSATEXM</code> <code>Series[float]</code> <p>Measured hydraulic conductivity at saturated conditions [1.d-5..1d5 cm/d, R]</p> <code>BDENS</code> <code>Series[float]</code> <p>Dry soil bulk density [100..1d4 mg/cm3, R]</p> <code>ALFAW</code> <code>Optional[Series[float]]</code> <p>Alfa parameter of main wetting curve in case of hysteresis [0.0001..100 /cm, R]</p> Source code in <code>pyswap/soilwater/tables.py</code> <pre><code>class SOILHYDRFUNC(BaseModel):\n    \"\"\"Soil hydraulic functions table.\n\n    !!! warning\n        ALFAW required only when the hysteresis option is set to 1 or 2. This column is set as optional column and (for now) is not checked.\n\n    Attributes:\n        ORES (Series[float]): Residual water content [0..1 cm3/cm3, R]\n        OSAT (Series[float]): Saturated water content [0..1 cm3/cm3, R]\n        ALFA (Series[float]): Parameter alfa of main drying curve [0.0001..100 /cm, R]\n        NPAR (Series[float]): Parameter n [1.001..9 -, R]\n        LEXP (Series[float]): Exponent in hydraulic conductivity function [-25..25 -, R]\n        KSATFIT (Series[float]): Fitting parameter Ksat of hydraulic conductivity function [1.d-5..1d5 cm/d, R]\n        H_ENPR (Series[float]): Air entry pressure head [-40.0..0.0 cm, R]\n        KSATEXM (Series[float]): Measured hydraulic conductivity at saturated conditions [1.d-5..1d5 cm/d, R]\n        BDENS (Series[float]): Dry soil bulk density [100..1d4 mg/cm3, R]\n        ALFAW (Optional[Series[float]]): Alfa parameter of main wetting curve in case of hysteresis [0.0001..100 /cm, R]\n    \"\"\"\n\n    ORES: Series[float] = pa.Field(ge=0.0, le=1.0)\n    OSAT: Series[float] = pa.Field(ge=0.0, le=1.0)\n    ALFA: Series[float] = pa.Field(ge=0.0001, le=100.0)\n    NPAR: Series[float] = pa.Field(ge=1.001, le=9.0)\n    LEXP: Series[float] = pa.Field(ge=-25.0, le=25.0)\n    KSATFIT: Series[float] = pa.Field(ge=1.0e-5, le=1.0e5)\n    H_ENPR: Series[float] = pa.Field(ge=-40.0, le=0.0)\n    KSATEXM: Series[float] = pa.Field(ge=1.0e-5, le=1.0e5)\n    BDENS: Series[float] = pa.Field(ge=100.0, le=1.0e4)\n    ALFAW: Optional[Series[float]] = pa.Field(ge=0.0001, le=100.0)\n</code></pre>"},{"location":"reference/api-reference/#pyswap.soilwater.tables.SOILPROFILE","title":"<code>SOILPROFILE</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Vertical discretization of soil profile</p> <p>Attributes:</p> Name Type Description <code>ISUBLAY</code> <code>Series[int]</code> <p>Series[int]: number of sub layer, start with 1 at soil surface [1..MACP, I].</p> <code>ISOILLAY</code> <code>Series[int]</code> <p>Series[int]: number of soil physical layer, start with 1 at soil surface [1..MAHO, I].</p> <code>HSUBLAY</code> <code>Series[float]</code> <p>Series[float]: height of sub layer [0..1.d4 cm, R].</p> <code>HCOMP</code> <code>Series[float]</code> <p>Series[float]: height of compartments in the sub layer [0.0..1000.0 cm, R].</p> <code>NCOMP</code> <code>Series[int]</code> <p>Series[int]: number of compartments in the sub layer (Mind NCOMP = HSUBLAY/HCOMP) [1..MACP, I].</p> Source code in <code>pyswap/soilwater/tables.py</code> <pre><code>class SOILPROFILE(BaseModel):\n    \"\"\"Vertical discretization of soil profile\n\n    Attributes:\n        ISUBLAY: Series[int]: number of sub layer, start with 1 at soil surface [1..MACP, I].\n        ISOILLAY: Series[int]: number of soil physical layer, start with 1 at soil surface [1..MAHO, I].\n        HSUBLAY: Series[float]: height of sub layer [0..1.d4 cm, R].\n        HCOMP: Series[float]: height of compartments in the sub layer [0.0..1000.0 cm, R].\n        NCOMP: Series[int]: number of compartments in the sub layer (Mind NCOMP = HSUBLAY/HCOMP) [1..MACP, I].\n    \"\"\"\n\n    ISUBLAY: Series[int] = pa.Field(ge=1)\n    ISOILLAY: Series[int] = pa.Field(ge=1)\n    HSUBLAY: Series[float] = pa.Field(ge=0.0, le=1.0e4)\n    HCOMP: Series[float] = pa.Field(ge=0.0, le=1.0e3)\n    NCOMP: Series[int] = pa.Field(ge=1)\n</code></pre>"},{"location":"reference/api-reference/#pyswap.drainage--drainage_subpackage","title":"Drainage subpackage","text":"<p>Handling drainage settings and creation of the .dra file.</p> <p>Modules:</p> Name Description <code>drainage</code> <p>Holds the drainage settings for the SWAP model.</p> <code>drafile</code> <p>Create the .dra file.</p>"},{"location":"reference/api-reference/#pyswap.drainage.drafile","title":"<code>drafile</code>","text":"<p>Compose the .dra file for SWAP simulation.</p> <p>Classes:</p> Name Description <code>DraFile</code> <p>Class for the .dra file.</p> <code>DraSettings</code> <p>Class for the settings of the drainage module.</p> <code>DrainageFluxTable</code> <p>Class for the drainage flux table.</p> <code>DrainageFormula</code> <p>Class for the drainage formula.</p> <code>DrainageInfiltrationResitance</code> <p>Class for the drainage infiltration resistance.</p> <code>Flux</code> <p>Class for the flux.</p>"},{"location":"reference/api-reference/#pyswap.drainage.drafile.DraFile","title":"<code>DraFile</code>","text":"<p>               Bases: <code>PySWAPBaseModel</code></p> <p>Main class representing the drainage file (.dra) for SWAP.</p> <p>Attributes:</p> Name Type Description <code>drfil</code> <code>str</code> <p>Name of the file.</p> <code>general</code> <code>Any</code> <p>General settings.</p> <code>fluxtable</code> <code>Optional[Any]</code> <p>Flux table.</p> <code>drainageformula</code> <code>Optional[Any]</code> <p>Drainage formula.</p> <code>drainageinfiltrationres</code> <code>Optional[Any]</code> <p>Drainage infiltration resistance.</p> Source code in <code>pyswap/drainage/drafile.py</code> <pre><code>class DraFile(PySWAPBaseModel):\n    \"\"\"Main class representing the drainage file (.dra) for SWAP.\n\n    Attributes:\n        drfil (str): Name of the file.\n        general (Any): General settings.\n        fluxtable (Optional[Any]): Flux table.\n        drainageformula (Optional[Any]): Drainage formula.\n        drainageinfiltrationres (Optional[Any]): Drainage infiltration resistance.\n    \"\"\"\n\n    drfil: str\n    general: DraSettings = Field(exclude=True)\n    fluxtable: Optional[DrainageFluxTable] = Field(default=None, exclude=True)\n    drainageformula: Optional[DrainageFormula] = Field(\n        default=None, exclude=True)\n    drainageinfiltrationres: Optional[DrainageInfiltrationResitance] = Field(\n        default=None, exclude=True)\n\n    @property\n    def content(self):\n        return self._concat_sections()\n</code></pre>"},{"location":"reference/api-reference/#pyswap.drainage.drafile.DraSettings","title":"<code>DraSettings</code>","text":"<p>               Bases: <code>PySWAPBaseModel</code></p> <p>General settings for the drainage file</p> <p>Attributes:</p> Name Type Description <code>dramet</code> <code>Literal[1, 2, 3]</code> <p>Method of lateral drainage calculation</p> <ul> <li>1 - Use table of drainage flux - groundwater level relation.</li> <li>2 - Use drainage formula of Hooghoudt or Ernst.</li> <li>3 - Use drainage/infiltration resistance, multi-level if needed.</li> </ul> <code>swdivd</code> <code>Literal[1, 2]</code> <p>Calculate vertical distribution of drainage flux in groundwater.</p> <code>cofani</code> <code>Optional[FloatList]</code> <p>specify anisotropy factor COFANI (horizontal/vertical saturated hydraulic conductivity) for each soil layer (maximum MAHO)</p> <code>swdislay</code> <code>Literal[0, 1, 2, 3, '-']</code> <p>Switch to adjust upper boundary of model discharge layer.</p> <ul> <li>0 - No adjustment</li> <li>1 - Adjusment based on depth of top of model discharge</li> <li>2 - Adjusment based on factor of top of model discharge</li> </ul> Source code in <code>pyswap/drainage/drafile.py</code> <pre><code>class DraSettings(PySWAPBaseModel):\n    \"\"\"General settings for the drainage file\n\n    Attributes:\n        dramet (Literal[1, 2, 3]): Method of lateral drainage calculation\n\n            * 1 - Use table of drainage flux - groundwater level relation.\n            * 2 - Use drainage formula of Hooghoudt or Ernst.\n            * 3 - Use drainage/infiltration resistance, multi-level if needed.\n\n        swdivd (Literal[1, 2]): Calculate vertical distribution of drainage flux in groundwater.\n        cofani (Optional[FloatList]): specify anisotropy factor COFANI (horizontal/vertical saturated hydraulic conductivity) for each soil layer (maximum MAHO)\n        swdislay (Literal[0, 1, 2, 3, '-']): Switch to adjust upper boundary of model discharge layer.\n\n            * 0 - No adjustment\n            * 1 - Adjusment based on depth of top of model discharge\n            * 2 - Adjusment based on factor of top of model discharge\n\n    \"\"\"\n    dramet: Literal[1, 2, 3]\n    swdivd: Literal[1, 2]\n    cofani: Optional[FloatList]\n    swdislay: Literal[0, 1, 2, 3, '-']\n</code></pre>"},{"location":"reference/api-reference/#pyswap.drainage.drafile.DrainageFluxTable","title":"<code>DrainageFluxTable</code>","text":"<p>               Bases: <code>PySWAPBaseModel</code></p> <p>Settings for the case when dramet is 1.</p> <p>Attributes:</p> Name Type Description <code>lm1</code> <code>float</code> <p>Drain spacing</p> <code>table_qdrntb</code> <code>Table</code> <p>Table of drainage flux - groundwater level.</p> Source code in <code>pyswap/drainage/drafile.py</code> <pre><code>class DrainageFluxTable(PySWAPBaseModel):\n    \"\"\"Settings for the case when dramet is 1.\n\n    Attributes:\n        lm1 (float): Drain spacing\n        table_qdrntb (Table): Table of drainage flux - groundwater level.\n    \"\"\"\n    lm1: float = Field(ge=1.0, le=1000.0)\n    table_qdrntb: Table\n</code></pre>"},{"location":"reference/api-reference/#pyswap.drainage.drafile.DrainageFormula","title":"<code>DrainageFormula</code>","text":"<p>               Bases: <code>PySWAPBaseModel</code></p> <p>Settings for the case when dramet is 2.</p> <p>Attributes:</p> Name Type Description <code>lm2</code> <code>float</code> <p>Drain spacing.</p> <code>shape</code> <code>float</code> <p>Shape factor to account for actual location between drain and water divide.</p> <code>wetper</code> <code>float</code> <p>Wet perimeter of the drain.</p> <code>zbotdr</code> <code>float</code> <p>Level of drain bottom.</p> <code>entres</code> <code>float</code> <p>Drain entry resistance.</p> <code>ipos</code> <code>Literal[1, 2, 3, 4, 5]</code> <p>Position of drain</p> <ul> <li>1 - On top of an impervious layer in a homogeneous profile</li> <li>2 - Above an impervious layer in a homogeneous profile</li> <li>3 - At the interface of a fine upper and a coarse lower soil layer</li> <li>4 - In the lower, more coarse soil layer</li> <li>5 - In the upper, more fine soil layer</li> </ul> <code>basegw</code> <code>float</code> <p>Level of impervious layer.</p> <code>khtop</code> <code>float</code> <p>Horizontal hydraulic conductivity of the top layer.</p> <code>khbot</code> <code>Optional[float]</code> <p>Horizontal hydraulic conductivity of the bottom layer.</p> <code>zintf</code> <code>Optional[float]</code> <p>Interface level of the coarse and fine soil layer.</p> <code>kvtop</code> <code>Optional[float]</code> <p>Vertical hydraulic conductivity of the top layer.</p> <code>kvbot</code> <code>Optional[float]</code> <p>Vertical hydraulic conductivity of the bottom layer.</p> <code>geofac</code> <code>Optional[float]</code> <p>Geometric factor of Ernst.</p> Source code in <code>pyswap/drainage/drafile.py</code> <pre><code>class DrainageFormula(PySWAPBaseModel):\n    \"\"\"Settings for the case when dramet is 2.\n\n    Attributes:\n        lm2 (float): Drain spacing.\n        shape (float): Shape factor to account for actual location between drain and water divide.\n        wetper (float): Wet perimeter of the drain.\n        zbotdr (float): Level of drain bottom.\n        entres (float): Drain entry resistance.\n        ipos (Literal[1, 2, 3, 4, 5]): Position of drain\n\n            * 1 - On top of an impervious layer in a homogeneous profile\n            * 2 - Above an impervious layer in a homogeneous profile\n            * 3 - At the interface of a fine upper and a coarse lower soil layer\n            * 4 - In the lower, more coarse soil layer\n            * 5 - In the upper, more fine soil layer\n        basegw (float): Level of impervious layer.\n        khtop (float): Horizontal hydraulic conductivity of the top layer.\n        khbot (Optional[float]): Horizontal hydraulic conductivity of the bottom layer.\n        zintf (Optional[float]): Interface level of the coarse and fine soil layer.\n        kvtop (Optional[float]): Vertical hydraulic conductivity of the top layer.\n        kvbot (Optional[float]): Vertical hydraulic conductivity of the bottom layer.\n        geofac (Optional[float]): Geometric factor of Ernst.\n    \"\"\"\n\n    lm2: float = Field(ge=1.0, le=1000.0)\n    shape: float = Field(**UNITRANGE)\n    wetper: float = Field(ge=0.0, le=1000.0)\n    zbotdr: float = Field(ge=-1000.0, le=0.0)\n    entres: float = Field(ge=0.0, le=1000.0)\n    ipos: Literal[1, 2, 3, 4, 5]\n    basegw: float = Field(ge=-1.0e4, le=0.0)\n    khtop: float = Field(ge=0.0, le=1000.0)\n    khbot: Optional[float] = Field(default=None, ge=0.0, le=1000.0)\n    zintf: Optional[float] = Field(default=None, ge=-1.0e4, le=0.0)\n    kvtop: Optional[float] = Field(default=None, ge=0.0, le=1000.0)\n    kvbot: Optional[float] = Field(default=None, ge=0.0, le=1000.0)\n    geofac: Optional[float] = Field(default=None, ge=0.0, le=100.0)\n\n    @model_validator(mode='after')\n    def _validate_draformula(self) -&gt; Self:\n        if self.ipos in [3, 4, 5]:\n            assert self.khbot is not None, 'khbot has to be provided if IPOS is 3.'\n            assert self.zintf is not None, 'zintf has to be provided if IPOS is 3.'\n        if self.ipos in [4, 5]:\n            assert self.kvtop is not None, 'kvtop has to be provided if IPOS is 3.'\n            assert self.kvbot is not None, 'kvbot has to be provided if IPOS is 3.'\n        if self.ipos == 5:\n            assert self.geofac is not None, 'geofac has to be provided if IPOS is 3.'\n\n        return self\n</code></pre>"},{"location":"reference/api-reference/#pyswap.drainage.drafile.DrainageInfiltrationResitance","title":"<code>DrainageInfiltrationResitance</code>","text":"<p>               Bases: <code>PySWAPBaseModel</code></p> <p>Settings for the case when dramet is 3.</p> <p>Attributes:</p> Name Type Description <code>nrlevs</code> <code>int</code> <p>Number of drainage levels.</p> <code>swintfl</code> <code>Literal[0, 1]</code> <p>Option for interflow in highest drainage level (shallow system with short residence time).</p> <code>cofintflb</code> <code>float</code> <p>Coefficient for interflow relation.</p> <code>expintflb</code> <code>float</code> <p>Exponent for interflow relation.</p> <code>swtopnrsrf</code> <code>Literal[0, 1]</code> <p>Switch to enable adjustment of model discharge layer.</p> <code>list_levelfluxes</code> <code>ObjectList</code> <p>List of level fluxes.</p> Source code in <code>pyswap/drainage/drafile.py</code> <pre><code>class DrainageInfiltrationResitance(PySWAPBaseModel):\n    \"\"\"Settings for the case when dramet is 3.\n\n    Attributes:\n        nrlevs (int): Number of drainage levels.\n        swintfl (Literal[0, 1]): Option for interflow in highest drainage level (shallow system with short residence time).\n        cofintflb (float): Coefficient for interflow relation.\n        expintflb (float): Exponent for interflow relation.\n        swtopnrsrf (Literal[0, 1]): Switch to enable adjustment of model discharge layer.\n        list_levelfluxes (ObjectList): List of level fluxes.\n    \"\"\"\n    nrlevs: int = Field(ge=1, le=5)\n    swintfl: Literal[0, 1]\n    cofintflb: Optional[float] = Field(default=None, ge=0.01, le=10.0)\n    expintflb: Optional[float] = Field(default=None, ge=0.1, le=1.0)\n    swtopnrsrf: Optional[Literal[0, 1]] = None\n    list_levelfluxes: Optional[ObjectList] = None\n\n    @model_validator(mode='after')\n    def _validate_drainfiltrationres(self) -&gt; Self:\n        if self.swintfl == 1:\n            assert self.cofintflb is not None, 'cofintflb has to be provided if swintfl is 1.'\n            assert self.expintflb is not None, 'expintflb has to be provided if swintfl is 1.'\n\n        return self\n</code></pre>"},{"location":"reference/api-reference/#pyswap.drainage.drafile.Flux","title":"<code>Flux</code>","text":"<p>               Bases: <code>PySWAPBaseModel</code></p> <p>These objects are needed for the DrainageInfiltrationResitance class. Flux object should be  created for each level of drainage.</p> <p>Attributes:</p> Name Type Description <code>level_number</code> <code>int</code> <p>Number of the level.</p> <code>drares</code> <code>float</code> <p>Drainage resistance.</p> <code>infres</code> <code>float</code> <p>Infiltration resistance.</p> <code>swallo</code> <code>Literal[1, 2]</code> <p>Switch to allow drainage from this level.</p> <code>l</code> <code>Optional[float]</code> <p>Drain spacing.</p> <code>zbotdr</code> <code>float</code> <p>Level of the bottom of the drain.</p> <code>swdtyp</code> <code>Literal[1, 2]</code> <p>Drainage type.</p> <ul> <li>1 - drain tube.</li> <li>2 - open channel.</li> </ul> <code>table_datowltb</code> <code>Table</code> <p>date DATOWL [date] and channel water level LEVEL. Add suffix to the  dataframe headers according to the level number.</p> Source code in <code>pyswap/drainage/drafile.py</code> <pre><code>class Flux(PySWAPBaseModel):\n    \"\"\"These objects are needed for the DrainageInfiltrationResitance class. Flux object should be \n    created for each level of drainage.\n\n    Attributes:\n        level_number (int): Number of the level.\n        drares (float): Drainage resistance.\n        infres (float): Infiltration resistance.\n        swallo (Literal[1, 2]): Switch to allow drainage from this level.\n        l (Optional[float]): Drain spacing.\n        zbotdr (float): Level of the bottom of the drain.\n        swdtyp (Literal[1, 2]): Drainage type.\n\n            * 1 - drain tube.\n            * 2 - open channel.\n\n        table_datowltb (Table): date DATOWL [date] and channel water level LEVEL. Add suffix to the \n            dataframe headers according to the level number.\n    \"\"\"\n    level_number: int = Field(exclude=True, ge=1, le=5)\n    drares: float = Field(ge=10.0, le=1.0e5)\n    infres: float = Field(ge=10.0, le=1.0e5)\n    swallo: Literal[1, 2, 3]\n    l: Optional[float] = Field(ge=1.0, le=1.0e5)\n    zbotdr: float = Field(ge=-1000.0, le=0.0)\n    swdtyp: Literal[1, 2]\n    table_datowltb: Table\n\n    @model_validator(mode='after')\n    def _validate_flux(self) -&gt; Self:\n        if self.swallo == 1:\n            assert self.l is not None, 'l has to be provided if swallo is 1.'\n\n        return self\n\n    def model_dump(self, **kwargs):\n\n        d = super().model_dump(**kwargs)\n\n        # If level_number is set, modify the key names.\n        if self.level_number is not None:\n            new_d = {}\n            suffix = str(self.level_number)\n            for key, value in d.items():\n                new_d[key + suffix] = value\n            return new_d\n        return d\n</code></pre>"},{"location":"reference/api-reference/#pyswap.drainage.drainage","title":"<code>drainage</code>","text":"<p>Lateral drainage settings.</p> <p>Classes:</p> Name Description <code>Drainage</code> <p>The lateral drainage settings.</p>"},{"location":"reference/api-reference/#pyswap.drainage.drainage.Drainage","title":"<code>Drainage</code>","text":"<p>               Bases: <code>PySWAPBaseModel</code></p> <p>The lateral drainage settings of the simulation.</p> <p>Attributes:</p> Name Type Description <code>swdra</code> <code>Literal[0, 1, 2]</code> <p>Switch for lateral drainage.</p> <ul> <li>0 - No drainage.</li> <li>1 - Simulate with a basic drainage routine.</li> <li>2 - Simulate with surface water management.</li> </ul> <code>drafile</code> <code>Optional[Any]</code> <p>Content of the drainage file.</p> Source code in <code>pyswap/drainage/drainage.py</code> <pre><code>class Drainage(PySWAPBaseModel):\n    \"\"\"The lateral drainage settings of the simulation.\n\n    Attributes:\n        swdra (Literal[0, 1, 2]): Switch for lateral drainage.\n\n            * 0 - No drainage.\n            * 1 - Simulate with a basic drainage routine.\n            * 2 - Simulate with surface water management.\n\n        drafile (Optional[Any]): Content of the drainage file.\n    \"\"\"\n\n    swdra: Literal[0, 1, 2]\n    drafile: Optional[DraFile] = Field(default=None)\n\n    @model_validator(mode='after')\n    def _validate_drainage(self) -&gt; Self:\n        if self.swdra &gt; 0:\n            assert self.drafile is not None, \"drafile is required when swdra is 1 or 2\"\n\n        return self\n\n    def write_dra(self, path: str):\n        save_file(\n            string=self.drafile.content,\n            extension='dra',\n            fname=self.drafile.drfil,\n            path=path\n        )\n</code></pre>"},{"location":"reference/api-reference/#pyswap.boundary--boundary_subpackage","title":"Boundary subpackage","text":"<p>This subpackage deals with boundary conditions for the SWAP model.</p> <p>Modules:</p> Name Description <code>bottomboundary</code> <p>Bottom boundary condition settings for the SWAP model.</p>"},{"location":"reference/api-reference/#pyswap.boundary.boundary","title":"<code>boundary</code>","text":"<p>Bottom boundary condition settings for the SWAP model.</p> <p>Classes:</p> Name Description <code>BottomBoundary</code> <p>Holds the settings of the bottom boundary conditions of the .swp file.</p>"},{"location":"reference/api-reference/#pyswap.boundary.boundary.BottomBoundary","title":"<code>BottomBoundary</code>","text":"<p>               Bases: <code>PySWAPBaseModel</code></p> <p>Bottom boundary settings for SWAP model.</p> <p>Attributes:</p> Name Type Description <code>swbbcfile</code> <code>Literal[0, 1]</code> <p>Switch for file with bottom boundary data:</p> <ul> <li>0 - data are specified in current file</li> <li>1 - data are specified in separate file</li> </ul> <code>swbotb</code> <code>Literal[1, 2, 3, 4, 5, 6, 7, 8]</code> <p>Switch for type of bottom boundary.</p> <ul> <li>1 - prescribe groundwater level;</li> <li>2 - prescribe bottom flux;</li> <li>3 - calculate bottom flux from hydraulic head of deep aquifer;</li> <li>4 - calculate bottom flux as function of groundwater level;</li> <li>5 - prescribe soil water pressure head of bottom compartment;</li> <li>6 - bottom flux equals zero;</li> <li>7 - free drainage of soil profile;</li> <li>8 - free outflow at soil-air interface.</li> </ul> <code>sw2</code> <code>Optional[Literal[1, 2]]</code> <p>Specify whether a sinus function or a table are used for the bottom flux.</p> <ul> <li>1 - sinus function;</li> <li>2 - table.</li> </ul> <code>sw3</code> <code>Optional[Literal[1, 2]]</code> <p>Specify whether a sinus function or a table are used for the hydraulic head in the deep aquifer.</p> <ul> <li>1 - sinus function;</li> <li>2 - table.</li> </ul> <code>sw4</code> <code>Optional[Literal[0, 1]]</code> <p>An extra groundwater flux can be specified which is added to above specified flux.</p> <ul> <li>0 - no extra flux;</li> <li>1 - extra flux.</li> </ul> <code>swbotb3resvert</code> <code>Optional[Literal[0, 1]]</code> <p>Switch for vertical hydraulic resistance between bottom boundary and groundwater level.</p> <ul> <li>0 - Include vertical hydraulic resistance</li> <li>1 - Suppress vertical hydraulic resistance</li> </ul> <code>swbotb3impl</code> <code>Optional[Literal[0, 1]]</code> <p>Switch for numerical solution of bottom flux.</p> <ul> <li>0 - Explicit solution (choose always when SHAPE &lt; 1.0);</li> <li>1 - Implicit solution.</li> </ul> <code>swqhbot</code> <code>Optional[Literal[1, 2]]</code> <p>Specify whether an exponential relation or a table is used.</p> <ul> <li>1 - bottom flux is calculated with an exponential relation</li> <li>2 - bottom flux is derived from a table</li> </ul> <code>bbcfile</code> <code>Optional[str]</code> <p>Name of file with bottom boundary data (without .BBC extension).</p> <code>sinave</code> <code>Optional[float]</code> <p>Average value of bottom flux.</p> <code>sinamp</code> <code>Optional[float]</code> <p>Amplitude of bottom flux sine function.</p> <code>sinmax</code> <code>Optional[float]</code> <p>Time of the year with maximum bottom flux.</p> <code>shape</code> <code>Optional[float]</code> <p>Shape factor to derive average groundwater level.</p> <code>hdrain</code> <code>Optional[float]</code> <p>Mean drain base to correct for average groundwater level.</p> <code>rimlay</code> <code>Optional[float]</code> <p>Vertical resistance of aquitard.</p> <code>aqave</code> <code>Optional[float]</code> <p>Average hydraulic head in underlaying aquifer.</p> <code>aqamp</code> <code>Optional[float]</code> <p>Amplitude hydraulic head sinus wave.</p> <code>aqtmax</code> <code>Optional[float]</code> <p>First time of the year with maximum hydraulic head.</p> <code>aqper</code> <code>Optional[float]</code> <p>Period of hydraulic head sinus wave.</p> <code>cofqha</code> <code>Optional[float]</code> <p>Coefficient A for exponential relation for bottom flux.</p> <code>cofqhb</code> <code>Optional[float]</code> <p>Coefficient B for exponential relation for bottom flux.</p> <code>cofqhc</code> <code>Optional[float]</code> <p>Coefficient C for exponential relation for bottom flux.</p> <code>gwlevel</code> <code>Optional[Table]</code> <p>Table with groundwater level data.</p> <code>table_qbot</code> <code>Optional[Table]</code> <p>Table with bottom flux data.</p> <code>table_haquif</code> <code>Optional[Table]</code> <p>Table with average pressure head in underlaying aquifer.</p> <code>table_qbot4</code> <code>Optional[Table]</code> <p>Table with bottom flux data.</p> <code>table_qtab</code> <code>Optional[Table]</code> <p>Table with groundwater level-bottom flux relation</p> <code>table_hbot</code> <code>Optional[Table]</code> <p>Table with the bottom compartment pressure head.</p> Source code in <code>pyswap/boundary/boundary.py</code> <pre><code>class BottomBoundary(PySWAPBaseModel):\n    \"\"\"\n    Bottom boundary settings for SWAP model.\n\n    Attributes:\n        swbbcfile (Literal[0, 1]): Switch for file with bottom boundary data:\n\n            * 0 - data are specified in current file\n            * 1 - data are specified in separate file\n\n        swbotb (Literal[1, 2, 3, 4, 5, 6, 7, 8]): Switch for type of bottom boundary.\n\n            * 1 - prescribe groundwater level;\n            * 2 - prescribe bottom flux;\n            * 3 - calculate bottom flux from hydraulic head of deep aquifer;\n            * 4 - calculate bottom flux as function of groundwater level;\n            * 5 - prescribe soil water pressure head of bottom compartment;\n            * 6 - bottom flux equals zero;\n            * 7 - free drainage of soil profile;\n            * 8 - free outflow at soil-air interface.\n\n        sw2 (Optional[Literal[1, 2]]): Specify whether a sinus function or a table are used for the bottom flux.\n\n            * 1 - sinus function;\n            * 2 - table.\n\n        sw3 (Optional[Literal[1, 2]]): Specify whether a sinus function or a table are used for the hydraulic head in the deep aquifer.\n\n            * 1 - sinus function;\n            * 2 - table.\n\n        sw4 (Optional[Literal[0, 1]]): An extra groundwater flux can be specified which is added to above specified flux.\n\n            * 0 - no extra flux;\n            * 1 - extra flux.\n\n        swbotb3resvert (Optional[Literal[0, 1]]): Switch for vertical hydraulic resistance between bottom boundary and groundwater level.\n\n            * 0 - Include vertical hydraulic resistance\n            * 1 - Suppress vertical hydraulic resistance\n\n        swbotb3impl (Optional[Literal[0, 1]]): Switch for numerical solution of bottom flux.\n\n            * 0 - Explicit solution (choose always when SHAPE &lt; 1.0);\n            * 1 - Implicit solution.\n\n        swqhbot (Optional[Literal[1, 2]]): Specify whether an exponential relation or a table is used.\n\n            * 1 - bottom flux is calculated with an exponential relation\n            * 2 - bottom flux is derived from a table\n\n        bbcfile (Optional[str]): Name of file with bottom boundary data (without .BBC extension).\n        sinave (Optional[float]): Average value of bottom flux.\n        sinamp (Optional[float]): Amplitude of bottom flux sine function.\n        sinmax (Optional[float]): Time of the year with maximum bottom flux.\n        shape (Optional[float]): Shape factor to derive average groundwater level.\n        hdrain (Optional[float]): Mean drain base to correct for average groundwater level.\n        rimlay (Optional[float]): Vertical resistance of aquitard.\n        aqave (Optional[float]): Average hydraulic head in underlaying aquifer.\n        aqamp (Optional[float]): Amplitude hydraulic head sinus wave.\n        aqtmax (Optional[float]): First time of the year with maximum hydraulic head.\n        aqper (Optional[float]): Period of hydraulic head sinus wave.\n        cofqha (Optional[float]): Coefficient A for exponential relation for bottom flux.\n        cofqhb (Optional[float]): Coefficient B for exponential relation for bottom flux.\n        cofqhc (Optional[float]): Coefficient C for exponential relation for bottom flux.\n        gwlevel (Optional[Table]): Table with groundwater level data.\n        table_qbot (Optional[Table]): Table with bottom flux data.\n        table_haquif (Optional[Table]): Table with average pressure head in underlaying aquifer.\n        table_qbot4 (Optional[Table]): Table with bottom flux data.\n        table_qtab (Optional[Table]): Table with groundwater level-bottom flux relation\n        table_hbot (Optional[Table]): Table with the bottom compartment pressure head.\n    \"\"\"\n\n    swbbcfile: Literal[0, 1]\n    swbotb: Literal[1, 2, 3, 4, 5, 6, 7, 8]\n    sw2: Optional[Literal[1, 2]] = None\n    sw3: Optional[Literal[1, 2]] = None\n    sw4: Optional[Literal[0, 1]] = None\n    swbotb3resvert: Optional[Literal[0, 1]] = None\n    swbotb3impl: Optional[Literal[0, 1]] = None\n    swqhbot: Optional[Literal[1, 2]] = None\n    bbcfile: Optional[str] = None\n    sinave: Optional[float] = Field(ge=-10.0, le=10.0, default=None)\n    sinamp: Optional[float] = Field(ge=-10.0, le=10.0, default=None)\n    sinmax: Optional[float] = Field(ge=0.0, le=366.0, default=None)\n    shape: Optional[float] = None\n    hdrain: Optional[float] = None\n    rimlay: Optional[float] = None\n    aqave: Optional[float] = None\n    aqamp: Optional[float] = None\n    aqtmax: Optional[float] = None\n    aqper: Optional[float] = None\n    cofqha: Optional[float] = None\n    cofqhb: Optional[float] = None\n    cofqhc: Optional[float] = None\n    table_gwlevel: Optional[Table] = None\n    table_qbot: Optional[Table] = None\n    table_haquif: Optional[Table] = None\n    table_qbot4: Optional[Table] = None\n    table_qtab: Optional[Table] = None\n    table_hbot5: Optional[Table] = None\n\n    @model_validator(mode='after')\n    def _check_swbotb(self) -&gt; Self:\n        if self.swbotb == 1:\n            assert self.gwlevel, 'gwlevel must be provided if swbotb is 1'\n        elif self.swbotb == 2:\n            assert self.sw2, 'sw2 must be provided if swbotb is 2'\n            if self.sw2 == 1:\n                assert self.sinave, 'sinave must be provided if sw2 is 1'\n                assert self.sinamp, 'sinamp must be provided if sw2 is 1'\n                assert self.sinmax, 'sinmax must be provided if sw2 is 1'\n            elif self.sw2 == 2:\n                assert self.table_qbot, 'qbot must be provided if sw2 is 2'\n        elif self.swbotb == 3:\n            assert self.sw3, 'sw3 must be provided if swbotb is 3'\n            if self.sw3 == 1:\n                assert self.aqave, 'aqave must be provided if sw3 is 1'\n                assert self.aqamp, 'auamp must be provided if sw3 is 1'\n                assert self.aqtmax, 'aqtmax must be provided if sw3 is 1'\n                assert self.aqper, 'aqper must be provided if sw3 is 1'\n            elif self.sw3 == 2:\n                assert self.table_haquif, 'haquif must be provided if sw3 is 2'\n        elif self.swbotb == 4:\n            assert self.swqhbot, 'swqhbot must be provided if swbotb is 4'\n            if self.swqhbot == 1:\n                assert self.cofqha, 'cofqha must be provided if swqhbot is 1'\n                assert self.cofqhb, 'cofqhb must be provided if swqhbot is 1'\n                assert self.cofqhc, 'cofqhc must be provided if swqhbot is 1'\n            elif self.swqhbot == 2:\n                assert self.table_qtab, 'qtab must be provided if swqhbot is 2'\n        elif self.swbotb == 5:\n            assert self.table_hbot5, 'hbot5 must be provided if swbotb is 5'\n\n        return self\n</code></pre>"},{"location":"reference/api-reference/#pyswap.extras--additional_settings","title":"Additional settings","text":""},{"location":"reference/api-reference/#pyswap.extras.heatflow","title":"<code>heatflow</code>","text":"<p>Heat flow settings for SWAP simulation.</p> <p>Classes:</p> Name Description <code>HeatFlow</code> <p>Heat flow settings for SWAP simulation.</p>"},{"location":"reference/api-reference/#pyswap.extras.heatflow.HeatFlow","title":"<code>HeatFlow</code>","text":"<p>               Bases: <code>PySWAPBaseModel</code></p> <p>Heat flow settings for SWAP simulation.</p> <p>Warning</p> <p>table_initsoil is not validated because it depends of swinco setting.</p> <p>Attributes:</p> Name Type Description <code>swhea</code> <code>Literal[0, 1]</code> <p>Switch for heat flow.</p> <code>swcalt</code> <code>Optional[Literal[1, 2]]</code> <ul> <li>1 - analytical method</li> <li>2 - numerical method</li> </ul> <code>tampli</code> <code>Optional[float]</code> <p>Amplitude of annual temperature wave at soil surface [0..50 oC, R]</p> <code>tmean</code> <code>Optional[float]</code> <p>Mean annual temperature at soil surface [-10..30 oC, R]</p> <code>timref</code> <code>Optional[float]</code> <p>Time at which the sinus temperature wave reaches it's top [0..366.0 d, R]</p> <code>ddamp</code> <code>Optional[float]</code> <p>Damping depth of soil temperature wave [1..500 cm, R]</p> <code>swtopbhea</code> <code>Optional[Literal[1, 2]]</code> <p>Define top boundary condition</p> <ul> <li>1 - use air temperature of meteo input file as top boundary</li> <li>2 - use measured top soil temperature as top boundary</li> </ul> <code>tsoilfile</code> <code>Optional[str]</code> <p>name of input file with soil surface temperatures without extension .TSS</p> <code>swbotbhea</code> <code>Optional[Literal[1, 2]]</code> <p>Define bottom boundary condition</p> <ul> <li>1 - no heat flux</li> <li>2 - prescribe bottom temperature</li> </ul> <code>table_soiltextures</code> <code>Optional[Table]</code> <p>for each physical soil layer the soil texture (g/g mineral parts) and the organic matter content (g/g dry soil)</p> <code>table_initsoil</code> <code>Optional[Table]</code> <p>initial temperature TSOIL [-50..50 oC, R] as function of soil depth ZH [-100000..0 cm, R]</p> <code>table_bbctsoil</code> <code>Optional[Table]</code> <p>bottom boundary temperature TBOT [-50..50 oC, R] as function of date DATET [date]</p> Source code in <code>pyswap/extras/heatflow.py</code> <pre><code>class HeatFlow(PySWAPBaseModel):\n    \"\"\"Heat flow settings for SWAP simulation.\n\n    !!! warning\n\n        table_initsoil is not validated because it depends of swinco setting.\n\n    Attributes:\n        swhea (Literal[0, 1]): Switch for heat flow.\n        swcalt (Optional[Literal[1, 2]]):\n\n            * 1 - analytical method\n            * 2 - numerical method\n\n        tampli (Optional[float]): Amplitude of annual temperature wave at soil surface [0..50 oC, R]\n        tmean (Optional[float]): Mean annual temperature at soil surface [-10..30 oC, R]\n        timref (Optional[float]): Time at which the sinus temperature wave reaches it's top [0..366.0 d, R]\n        ddamp (Optional[float]): Damping depth of soil temperature wave [1..500 cm, R]\n        swtopbhea (Optional[Literal[1, 2]]): Define top boundary condition\n\n            * 1 - use air temperature of meteo input file as top boundary\n            * 2 - use measured top soil temperature as top boundary\n\n        tsoilfile (Optional[str]): name of input file with soil surface temperatures without extension .TSS\n        swbotbhea (Optional[Literal[1, 2]]): Define bottom boundary condition\n\n            * 1 - no heat flux\n            * 2 - prescribe bottom temperature\n\n        table_soiltextures (Optional[Table]): for each physical soil layer the soil texture (g/g mineral parts) and the organic matter content (g/g dry soil)\n        table_initsoil (Optional[Table]): initial temperature TSOIL [-50..50 oC, R] as function of soil depth ZH [-100000..0 cm, R]\n        table_bbctsoil (Optional[Table]): bottom boundary temperature TBOT [-50..50 oC, R] as function of date DATET [date]\n    \"\"\"\n\n    swhea: Literal[0, 1]\n    swcalt: Optional[Literal[1, 2]] = None\n    tampli: Optional[float] = None\n    tmean: Optional[float] = None\n    timref: Optional[float] = None\n    ddamp: Optional[float] = None\n    swtopbhea: Optional[Literal[1, 2]] = None\n    tsoilfile: Optional[str] = None\n    swbotbhea: Optional[Literal[1, 2]] = None\n    table_soiltextures: Optional[Table] = None\n    table_initsoil: Optional[Table] = None\n    table_bbctsoil: Optional[Table] = None\n\n    @model_validator(mode='after')\n    def _check_heatflow(self) -&gt; Self:\n        if self.swhea == 1:\n            assert self.swcalt is not None, \"swcalt must be specified if swhea is 1\"\n            if self.swcalt == 1:\n                assert self.tampli is not None, \"tampli must be specified if swcalt is 1\"\n                assert self.tmean is not None, \"tmean must be specified if swcalt is 1\"\n                assert self.timref is not None, \"timref must be specified if swcalt is 1\"\n                assert self.ddamp is not None, \"ddamp must be specified if swcalt is 1\"\n            elif self.swcalt == 2:\n                assert self.table_soiltextures is not None, \"table_soiltextures must be specified if swcalt is 2\"\n                if self.swtopbhea == 2:\n                    assert self.tsoilfile is not None, \"tsoilfile must be specified if swtopbhea is 2\"\n                if self.swbotbhea == 2:\n                    assert self.table_bbctsoil is not None, \"table_bbctsoil must be specified if swbotbhea is 2\"\n        return self\n</code></pre>"},{"location":"reference/api-reference/#pyswap.extras.solutetransport","title":"<code>solutetransport</code>","text":"<p>Solute transport settings for the SWAP simulation.</p> <p>Classes:</p> Name Description <code>SoluteTransport</code> <p>Solute transport settings.</p>"},{"location":"reference/api-reference/#pyswap.extras.solutetransport.SoluteTransport","title":"<code>SoluteTransport</code>","text":"<p>               Bases: <code>PySWAPBaseModel</code></p> <p>Solute transport settings.</p> <p>Warning</p> <p>Validation not yet included in the current release.</p> <p>Attributes:</p> Name Type Description <code>swsolu</code> <code>Literal[0, 1]</code> <code>cpre</code> <code>Optional[float]</code> <code>cdrain</code> <code>Optional[float]</code> <code>swbotbc</code> <code>Optional[Literal[0, 1]]</code> <code>cseep</code> <code>Optional[float]</code> <code>ddif</code> <code>Optional[float]</code> <code>tscf</code> <code>Optional[float]</code> <code>swsp</code> <code>Optional[Literal[0, 1]]</code> <code>frexp</code> <code>Optional[float]</code> <code>cref</code> <code>Optional[float]</code> <code>swdc</code> <code>Optional[Literal[0, 1]]</code> <code>gampar</code> <code>Optional[float]</code> <code>rtheta</code> <code>Optional[float]</code> <code>bexp</code> <code>Optional[float]</code> <code>swbr</code> <code>Optional[Literal[0, 1]]</code> <code>daquif</code> <code>Optional[float]</code> <code>poros</code> <code>Optional[float]</code> <code>kfsat</code> <code>Optional[float]</code> <code>decsat</code> <code>Optional[float]</code> <code>cdraini</code> <code>Optional[float]</code> <code>table_cseeparrtb</code> <code>Optional[Table]</code> <code>table_inissoil</code> <code>Optional[Table]</code> <code>table_miscellaneous</code> <code>Optional[Table]</code> Source code in <code>pyswap/extras/solutetransport.py</code> <pre><code>class SoluteTransport(PySWAPBaseModel):\n    \"\"\"\n    Solute transport settings.\n\n    !!! warning\n\n        Validation not yet included in the current release.\n\n    Attributes:\n        swsolu (Literal[0, 1]): \n        cpre (Optional[float]):\n        cdrain (Optional[float]):\n        swbotbc (Optional[Literal[0, 1]]):\n        cseep (Optional[float]):\n        ddif (Optional[float]):\n        tscf (Optional[float]):\n        swsp (Optional[Literal[0, 1]]):\n        frexp (Optional[float]):\n        cref (Optional[float]):\n        swdc (Optional[Literal[0, 1]]):\n        gampar (Optional[float]):\n        rtheta (Optional[float]):\n        bexp (Optional[float]):\n        swbr (Optional[Literal[0, 1]]):\n        daquif (Optional[float]):\n        poros (Optional[float]):\n        kfsat (Optional[float]):\n        decsat (Optional[float]):\n        cdraini (Optional[float]):\n        table_cseeparrtb (Optional[Table]):\n        table_inissoil (Optional[Table]):\n        table_miscellaneous (Optional[Table]):\n    \"\"\"\n    swsolu: Literal[0, 1]\n    cpre: Optional[float] = None\n    cdrain: Optional[float] = None\n    swbotbc: Optional[Literal[0, 1]] = None\n    cseep: Optional[float] = None\n    ddif: Optional[float] = None\n    tscf: Optional[float] = None\n    swsp: Optional[Literal[0, 1]] = None\n    frexp: Optional[float] = None\n    cref: Optional[float] = None\n    swdc: Optional[Literal[0, 1]] = None\n    gampar: Optional[float] = None\n    rtheta: Optional[float] = None\n    bexp: Optional[float] = None\n    swbr: Optional[Literal[0, 1]] = None\n    daquif: Optional[float] = None\n    poros: Optional[float] = None\n    kfsat: Optional[float] = None\n    decsat: Optional[float] = None\n    cdraini: Optional[float] = None\n    table_cseeparrtb: Optional[Table] = None\n    table_inissoil: Optional[Table] = None\n    table_miscellaneous: Optional[Table] = None\n</code></pre>"},{"location":"reference/api-reference/#pyswap.extras.tables","title":"<code>tables</code>","text":"<p>These are tables for the extras module</p>"},{"location":"reference/api-reference/#pyswap.extras.tables.INITSOILTEMP","title":"<code>INITSOILTEMP</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Table for initial soil temperature.</p> <p>Attributes:</p> Name Type Description <code>ZH</code> <code>float</code> <p>Depth of soil layer [cm, R]</p> <code>TSOIL</code> <code>float</code> <p>Initial temperature [oC, R]</p> Source code in <code>pyswap/extras/tables.py</code> <pre><code>class INITSOILTEMP(BaseModel):\n    \"\"\"Table for initial soil temperature.\n\n    Attributes:\n        ZH (float): Depth of soil layer [cm, R]\n        TSOIL (float): Initial temperature [oC, R]\n    \"\"\"\n    ZH: float = pa.Field(ge=-100000, le=0)\n    TSOIL: float = pa.Field(ge=-50, le=50)\n</code></pre>"},{"location":"reference/api-reference/#pyswap.extras.tables.SOILTEXTURES","title":"<code>SOILTEXTURES</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Table for soil textures.</p> <p>Attributes:</p> Name Type Description <code>PSAND</code> <code>float</code> <p>Depth of soil layer [cm, R]</p> <code>PSILT</code> <code>float</code> <p>Sand content [g/g mineral parts, R]</p> <code>PCLAY</code> <code>float</code> <p>Clay content [g/g mineral parts, R]</p> <code>ORGMAT</code> <code>float</code> <p>Organic matter content [g/g dry soil, R]</p> Source code in <code>pyswap/extras/tables.py</code> <pre><code>class SOILTEXTURES(BaseModel):\n    \"\"\"Table for soil textures.\n\n    Attributes:\n        PSAND (float): Depth of soil layer [cm, R]\n        PSILT (float): Sand content [g/g mineral parts, R]\n        PCLAY (float): Clay content [g/g mineral parts, R]\n        ORGMAT (float): Organic matter content [g/g dry soil, R]\n    \"\"\"\n    PSAND: float\n    PSILT: float\n    PCLAY: float\n    ORGMAT: float\n</code></pre>"},{"location":"reference/api-reference/#pyswap.model--swap_model_package","title":"SWAP model package","text":"<p>The main subpackage for the SWAP model. </p> <p>Modules:</p> Name Description <code>model</code> <p>SWAP model class</p> <code>result</code> <p>SWAP result class</p>"},{"location":"reference/api-reference/#pyswap.model.model","title":"<code>model</code>","text":"<p>The main model class.</p> <p>Classes:</p> Name Description <code>Model</code> <p>Main class that runs the SWAP model.</p>"},{"location":"reference/api-reference/#pyswap.model.model.Model","title":"<code>Model</code>","text":"<p>               Bases: <code>PySWAPBaseModel</code></p> <p>Main class that runs the SWAP model.</p> <p>The attributes must be valid pySWAP classes. For avoiding validation errors, for now the attributes are defined as Any.</p> <p>Attributes:</p> Name Type Description <code>metadata</code> <code>Any</code> <p>Metadata of the model.</p> <code>general_settings</code> <code>Any</code> <p>Simulation settings.</p> <code>meteorology</code> <code>Any</code> <p>Meteorological data.</p> <code>crop</code> <code>Any</code> <p>Crop data.</p> <code>fixedirrigation</code> <code>Any</code> <p>Fixed irrigation settings.</p> <code>soilmoisture</code> <code>Any</code> <p>Soil moisture data.</p> <code>surfaceflow</code> <code>Any</code> <p>Surface flow data.</p> <code>evaporation</code> <code>Any</code> <p>Evaporation data.</p> <code>soilprofile</code> <code>Any</code> <p>Soil profile data.</p> <code>snowandfrost</code> <code>Optional[Any]</code> <p>Snow and frost data. Default is <code>SnowAndFrost(swsnow=0, swfrost=0)</code>.</p> <code>richards</code> <code>Optional[Any]</code> <p>Richards data.</p> <code>lateraldrainage</code> <code>Any</code> <p>Lateral drainage data.</p> <code>bottomboundary</code> <code>Any</code> <p>Bottom boundary data.</p> <code>heatflow</code> <code>Optional[Any]</code> <p>Heat flow data.</p> <code>solutetransport</code> <code>Optional[Any]</code> <p>Solute transport data.</p> <p>Methods:</p> Name Description <code>write_swp</code> <p>Write the .swp input file.</p> <code>_copy_executable</code> <p>Copy the appropriate SWAP executable to the temporary directory.</p> <code>_run_swap</code> <p>Run the SWAP executable.</p> <code>_read_output</code> <p>Read the output file.</p> <code>_read_output_tz</code> <p>Read the output file with time zone.</p> <code>_read_vap</code> <p>Read the .vap output file.</p> <code>_write_inputs</code> <p>Write the input files.</p> <code>_identify_warnings</code> <p>Identify warnings in the log file.</p> <code>_raise_swap_warning</code> <p>Raise a warning.</p> <code>_read_output_old</code> <p>Save the old output files.</p> <code>run</code> <p>Run the model.</p> Source code in <code>pyswap/model/model.py</code> <pre><code>class Model(PySWAPBaseModel):\n    \"\"\"Main class that runs the SWAP model.\n\n    The attributes must be valid pySWAP classes. For avoiding validation errors,\n    for now the attributes are defined as Any.\n\n    Attributes:\n        metadata (Any): Metadata of the model.\n        general_settings (Any): Simulation settings.\n        meteorology (Any): Meteorological data.\n        crop (Any): Crop data.\n        fixedirrigation (Any): Fixed irrigation settings.\n        soilmoisture (Any): Soil moisture data.\n        surfaceflow (Any): Surface flow data.\n        evaporation (Any): Evaporation data.\n        soilprofile (Any): Soil profile data.\n        snowandfrost (Optional[Any]): Snow and frost data. Default is `SnowAndFrost(swsnow=0, swfrost=0)`.\n        richards (Optional[Any]): Richards data.\n        lateraldrainage (Any): Lateral drainage data.\n        bottomboundary (Any): Bottom boundary data.\n        heatflow (Optional[Any]): Heat flow data.\n        solutetransport (Optional[Any]): Solute transport data.\n\n    Methods:\n        write_swp: Write the .swp input file.\n        _copy_executable: Copy the appropriate SWAP executable to the temporary directory.\n        _run_swap: Run the SWAP executable.\n        _read_output: Read the output file.\n        _read_output_tz: Read the output file with time zone.\n        _read_vap: Read the .vap output file.\n        _write_inputs: Write the input files.\n        _identify_warnings: Identify warnings in the log file.\n        _raise_swap_warning: Raise a warning.\n        _read_output_old: Save the old output files.\n        run: Run the model.\n    \"\"\"\n\n    metadata: Metadata\n    version: str = Field(exclude=True, default='base')\n    general_settings: GeneralSettings\n    meteorology: Meteorology\n    crop: Crop\n    fixedirrigation: FixedIrrigation\n    soilmoisture: SoilMoisture\n    surfaceflow: SurfaceFlow\n    evaporation: Evaporation\n    soilprofile: SoilProfile\n    snowandfrost: Optional[SnowAndFrost] = SnowAndFrost(swsnow=0, swfrost=0)\n    richards: Optional[RichardsSettings] = RichardsSettings(\n        swkmean=1, swkimpl=0)\n    lateraldrainage: Drainage\n    bottomboundary: BottomBoundary\n    heatflow: Optional[HeatFlow] = HeatFlow(swhea=0)\n    solutetransport: Optional[SoluteTransport] = SoluteTransport(swsolu=0)\n\n    def write_swp(self, path: str) -&gt; None:\n        \"\"\"Write the .swp input file.\"\"\"\n\n        string = self._concat_sections()\n        self.save_element(string=string, path=path,\n                          filename='swap', extension='swp')\n        print('swap.swp saved.')\n\n    @staticmethod\n    def _copy_executable(tempdir: Path):\n        \"\"\"Copy the appropriate SWAP executable to the temporary directory.\"\"\"\n        if IS_WINDOWS:\n            exec_path = resources.files(\n                \"pyswap.libs.swap420-exe\").joinpath(\"swap.exe\")\n            shutil.copy(str(exec_path), str(tempdir))\n            print('Copying the windows version of SWAP into temporary directory...')\n        else:\n            exec_path = resources.files(\n                \"pyswap.libs.swap420-linux\").joinpath(\"swap420\")\n            shutil.copy(str(exec_path), str(tempdir))\n            print('Copying linux executable into temporary directory...')\n\n    def _write_inputs(self, path: str) -&gt; None:\n        print('Preparing files...')\n        self.write_swp(path)\n        if self.lateraldrainage.drafile:\n            self.lateraldrainage.write_dra(path)\n        if self.crop.cropfiles:\n            self.crop.write_crop(path)\n        if self.meteorology.metfile:\n            self.meteorology.write_met(path)\n        if self.fixedirrigation.irgfile:\n            self.irrigation.fixedirrig.write_irg(path)\n\n    @staticmethod\n    def _run_swap(tempdir: Path) -&gt; str:\n        \"\"\"Run the SWAP executable.\n\n        I do not decode the sterror because the SWAP executable\n        writes errors to stdout. It will be easy to implement reading\n        stderr later if needed.\n\n        Returns:\n            str: stdout.\n        \"\"\"\n\n        swap_path = Path(tempdir, 'swap.exe') if IS_WINDOWS else './swap420'\n\n        p = subprocess.Popen(swap_path,\n                             stdout=subprocess.PIPE,\n                             stdin=subprocess.PIPE,\n                             stderr=subprocess.STDOUT,\n                             cwd=tempdir)\n\n        stdout = p.communicate(input=b'\\n')[0]\n\n        return stdout.decode()\n\n    @staticmethod\n    def _read_output(path: Path):\n        \"\"\"Read the output csv file.\"\"\"\n        df = read_csv(path, comment='*', index_col='DATETIME')\n        df.index = to_datetime(df.index)\n\n        return df\n\n    @staticmethod\n    def _read_output_tz(path: Path):\n        \"\"\"Read the output csv file with the depth information.\"\"\"\n        df = read_csv(path, comment='*', index_col='DATE')\n        df.index = to_datetime(df.index)\n\n        return df\n\n    @staticmethod\n    def _read_vap(path: Path):\n        df = read_csv(path, skiprows=11, encoding_errors='replace')\n        df.columns = df.columns.str.strip()\n        df.replace(r'^\\s*$', nan, regex=True, inplace=True)\n        return df\n\n    def _read_log_file(self, directory: Path) -&gt; str:\n        \"\"\"Read the log file.\"\"\"\n        log_files = [f for f in Path(directory).glob(\n            '*.log') if f.name != 'reruns.log']\n\n        if len(log_files) == 0:\n            raise FileNotFoundError(\"No .log file found in the directory.\")\n        elif len(log_files) &gt; 1:\n            raise FileExistsError(\n                \"Multiple .log files found in the directory.\")\n\n        log_file = log_files[0]\n\n        with open(log_file, 'r') as file:\n            log_content = file.read()\n\n        return log_content\n\n    @staticmethod\n    def _identify_warnings(log: str) -&gt; list[Warning]:\n        \"\"\"Read through the log file and catch warnings emitted by the SWAP executable.\"\"\"\n        lines = log.split('\\n')\n        warnings = [line for line in lines\n                    if line.strip().lower().startswith('warning')]\n\n        return warnings\n\n    def _raise_swap_warning(self, message):\n        warnings.warn(message, Warning, stacklevel=3)\n\n    def _read_output_old(self, tempdir: Path):\n        \"\"\"Read all output files that are not in csv format as strings.\"\"\"\n        list_dir = os.listdir(tempdir)\n        list_dir = [f for f in list_dir if not f.find(\n            self.general_settings.outfil) and not f.endswith('.csv')]\n\n        if list_dir:\n            dict_files = {f.split('.')[1]: open_file(Path(tempdir, f))\n                          for f in list_dir}\n\n        return dict_files\n\n    def run(self, path: str | Path, silence_warnings: bool = False, old_output: bool = False):\n        \"\"\"Main function that runs the model.\n\n        Parameters:\n            path (str): Path to the working directory.\n            silence_warnings (bool): If True, warnings will not be printed.\n            old_output (bool): If True, the old output files (like .vap) will be saved to a dictionary.\n\n        !!! todo\n\n            It would be nice to have a nice output string that will concatenate all output\n            including warnings and/or errors.\n\n\n        !!! warning\n\n            Reruns are for now not supported. Multiple runs of the model can be achieved by running\n            model.run() multiple times.\n        \"\"\"\n        with tempfile.TemporaryDirectory(dir=path) as tempdir:\n\n            self._copy_executable(tempdir)\n            self._write_inputs(tempdir)\n\n            result = self._run_swap(tempdir)\n\n            if 'normal completion' not in result:\n                raise Exception(\n                    f'Model run failed. \\n {result}')\n\n            print(result)\n\n            log = self._read_log_file(tempdir)\n            warnings = self._identify_warnings(log)\n\n            if warnings and not silence_warnings:\n                print('Warnings:')\n                for warning in warnings:\n                    self._raise_swap_warning(message=warning)\n\n            if old_output:\n                dict_files = self._read_output_old(tempdir)\n\n            result = Result(\n                output=self._read_output(\n                    Path(tempdir, f'{self.general_settings.outfil}_output.csv')) if self.general_settings.inlist_csv else None,\n                output_tz=self._read_output_tz(\n                    Path(tempdir, f'{self.general_settings.outfil}_output_tz.csv')) if self.general_settings.inlist_csv_tz else None,\n                log=log,\n                output_old=dict_files if old_output else None,\n                warning=warnings\n            )\n\n            return result\n</code></pre>"},{"location":"reference/api-reference/#pyswap.model.model.Model.run","title":"<code>run(path, silence_warnings=False, old_output=False)</code>","text":"<p>Main function that runs the model.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the working directory.</p> required <code>silence_warnings</code> <code>bool</code> <p>If True, warnings will not be printed.</p> <code>False</code> <code>old_output</code> <code>bool</code> <p>If True, the old output files (like .vap) will be saved to a dictionary.</p> <code>False</code> <p>Todo</p> <p>It would be nice to have a nice output string that will concatenate all output including warnings and/or errors.</p> <p>Warning</p> <p>Reruns are for now not supported. Multiple runs of the model can be achieved by running model.run() multiple times.</p> Source code in <code>pyswap/model/model.py</code> <pre><code>def run(self, path: str | Path, silence_warnings: bool = False, old_output: bool = False):\n    \"\"\"Main function that runs the model.\n\n    Parameters:\n        path (str): Path to the working directory.\n        silence_warnings (bool): If True, warnings will not be printed.\n        old_output (bool): If True, the old output files (like .vap) will be saved to a dictionary.\n\n    !!! todo\n\n        It would be nice to have a nice output string that will concatenate all output\n        including warnings and/or errors.\n\n\n    !!! warning\n\n        Reruns are for now not supported. Multiple runs of the model can be achieved by running\n        model.run() multiple times.\n    \"\"\"\n    with tempfile.TemporaryDirectory(dir=path) as tempdir:\n\n        self._copy_executable(tempdir)\n        self._write_inputs(tempdir)\n\n        result = self._run_swap(tempdir)\n\n        if 'normal completion' not in result:\n            raise Exception(\n                f'Model run failed. \\n {result}')\n\n        print(result)\n\n        log = self._read_log_file(tempdir)\n        warnings = self._identify_warnings(log)\n\n        if warnings and not silence_warnings:\n            print('Warnings:')\n            for warning in warnings:\n                self._raise_swap_warning(message=warning)\n\n        if old_output:\n            dict_files = self._read_output_old(tempdir)\n\n        result = Result(\n            output=self._read_output(\n                Path(tempdir, f'{self.general_settings.outfil}_output.csv')) if self.general_settings.inlist_csv else None,\n            output_tz=self._read_output_tz(\n                Path(tempdir, f'{self.general_settings.outfil}_output_tz.csv')) if self.general_settings.inlist_csv_tz else None,\n            log=log,\n            output_old=dict_files if old_output else None,\n            warning=warnings\n        )\n\n        return result\n</code></pre>"},{"location":"reference/api-reference/#pyswap.model.model.Model.write_swp","title":"<code>write_swp(path)</code>","text":"<p>Write the .swp input file.</p> Source code in <code>pyswap/model/model.py</code> <pre><code>def write_swp(self, path: str) -&gt; None:\n    \"\"\"Write the .swp input file.\"\"\"\n\n    string = self._concat_sections()\n    self.save_element(string=string, path=path,\n                      filename='swap', extension='swp')\n    print('swap.swp saved.')\n</code></pre>"},{"location":"reference/api-reference/#pyswap.model.result","title":"<code>result</code>","text":"<p>Capturing model results.</p> Tip <p>The Result class is now focusing on the output in CSV format and the log file. the other result files are also retrieved as a list of strings which user can access if needed.</p> <p>Classes:</p> Name Description <code>Result</code> <p>Stores the result of a model run.</p>"},{"location":"reference/api-reference/#pyswap.model.result.Result","title":"<code>Result</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Class to store the result of a model run.</p> <p>Attributes:</p> Name Type Description <code>log</code> <code>str</code> <p>The log file of the model run.</p> <code>summary</code> <code>str</code> <p>The summary file of the model run.</p> <code>output</code> <code>DataFrame</code> <p>The output file of the model run.</p> <code>output_tz</code> <code>DataFrame</code> <p>The output file of the model run with timezone.</p> <code>output_old</code> <code>Dict[str, str]</code> <p>The old output files of the model run.</p> <code>warning</code> <code>List[str]</code> <p>The warnings of the model run.</p> <code>model_config</code> <code>ConfigDict</code> <p>The configuration for the model.</p> <p>Methods:</p> Name Description <code>iteration_stats </code> <p>The part of the log file that describes the iteration statistics.</p> <code>blc_summary </code> <p>The .blc file if it exists.</p> <code>water_balance </code> <p>The water balance of the model run.</p> Source code in <code>pyswap/model/result.py</code> <pre><code>class Result(BaseModel):\n    \"\"\"Class to store the result of a model run.\n\n    Attributes:\n        log (str): The log file of the model run.\n        summary (str, optional): The summary file of the model run.\n        output (DataFrame, optional): The output file of the model run.\n        output_tz (DataFrame, optional): The output file of the model run with timezone.\n        output_old (Dict[str, str], optional): The old output files of the model run.\n        warning (List[str], optional): The warnings of the model run.\n        model_config (ConfigDict): The configuration for the model.\n\n    Methods:\n        iteration_stats (str): The part of the log file that describes the iteration statistics.\n        blc_summary (str): The .blc file if it exists.\n        water_balance (str): The water balance of the model run.\n    \"\"\"\n\n    log: str\n    output: Optional[DataFrame] = Field(default=None, repr=False)\n    output_tz: Optional[DataFrame] = Field(default=None, repr=False)\n    output_old: Optional[Dict[str, str]] = Field(default=None, repr=False)\n    warning: Optional[List[str]] = Field(default=None, repr=False)\n\n    model_config = ConfigDict(\n        arbitrary_types_allowed=True,\n        validate_assignment=True,\n        extra='forbid'\n    )\n\n    @computed_field(return_type=str)\n    def iteration_stats(self):\n        \"\"\"Return the part of the string that describes the iteration statistics.\"\"\"\n        return re.search(r'.*(Iteration statistics\\s*.*)$', self.log, re.DOTALL)[1]\n\n    @computed_field(return_type=str)\n    def blc_summary(self):\n        \"\"\"Return the .blc file if it exists.\"\"\"\n        return self.output_old.get('blc') if self.output_old else None\n\n    def yearly_summary(self):\n        \"\"\"Return yearly sums of all output variables.\"\"\"\n        return self.output.resample('YE').sum()\n</code></pre>"},{"location":"reference/api-reference/#pyswap.model.result.Result.blc_summary","title":"<code>blc_summary()</code>","text":"<p>Return the .blc file if it exists.</p> Source code in <code>pyswap/model/result.py</code> <pre><code>@computed_field(return_type=str)\ndef blc_summary(self):\n    \"\"\"Return the .blc file if it exists.\"\"\"\n    return self.output_old.get('blc') if self.output_old else None\n</code></pre>"},{"location":"reference/api-reference/#pyswap.model.result.Result.iteration_stats","title":"<code>iteration_stats()</code>","text":"<p>Return the part of the string that describes the iteration statistics.</p> Source code in <code>pyswap/model/result.py</code> <pre><code>@computed_field(return_type=str)\ndef iteration_stats(self):\n    \"\"\"Return the part of the string that describes the iteration statistics.\"\"\"\n    return re.search(r'.*(Iteration statistics\\s*.*)$', self.log, re.DOTALL)[1]\n</code></pre>"},{"location":"reference/api-reference/#pyswap.model.result.Result.yearly_summary","title":"<code>yearly_summary()</code>","text":"<p>Return yearly sums of all output variables.</p> Source code in <code>pyswap/model/result.py</code> <pre><code>def yearly_summary(self):\n    \"\"\"Return yearly sums of all output variables.\"\"\"\n    return self.output.resample('YE').sum()\n</code></pre>"},{"location":"reference/api-reference/#pyswap.core--core_subpackage","title":"Core subpackage","text":"<p>Core package containing the main classes and functions for the SWAP model.</p> <p>Modules:</p> Name Description <code>basemodel</code> <p>Base model class for pySWAP.</p> <code>fields</code> <p>Field types for pyswap used for serialization.</p> <code>files</code> <p>Functions to interact with file system.</p> <code>serializers</code> <p>Functions to fine tune the serializatino of pySWAP objects.</p> <code>valueranges</code> <p>Objects containing value ranges used is validation of pySWAP objects.</p> <code>model</code> <p>Contains the classes for the model of the simulation.</p> <code>result</code> <p>Contains the classes for the results of the simulation.</p>"},{"location":"reference/api-reference/#pyswap.core.basemodel","title":"<code>basemodel</code>","text":""},{"location":"reference/api-reference/#pyswap.core.basemodel.PySWAPBaseModel","title":"<code>PySWAPBaseModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class for PySWAP models.</p> <p>Attributes:</p> Name Type Description <code>model_config</code> <code>ConfigDict</code> <p>Overriding Pydantic model configuration.</p> <p>Methods:</p> Name Description <code>save_element</code> <p>Saves model element to a file.</p> <code>model_string</code> <p>Returns a custom model string representation that matches the requirements of .swp file.</p> <code>_concat_sections</code> <p>Concatenate a string from individual sections.</p> <code>model_string</code> <p>Returns a custom model string representation that matches the requirements of .swp file.</p> Source code in <code>pyswap/core/basemodel.py</code> <pre><code>class PySWAPBaseModel(BaseModel):\n    \"\"\"Base class for PySWAP models.\n\n    Attributes:\n        model_config (ConfigDict): Overriding Pydantic model configuration.\n\n    Methods:\n        save_element: Saves model element to a file.\n        model_string: Returns a custom model string representation that matches the requirements of .swp file.\n        _concat_sections: Concatenate a string from individual sections.\n        model_string: Returns a custom model string representation that matches the requirements of .swp file.\n    \"\"\"\n\n    model_config = ConfigDict(\n        arbitrary_types_allowed=True,\n        validate_assignment=True,\n        extra='forbid'\n    )\n\n    @staticmethod\n    def save_element(string: str, path: str, filename: str, extension: str | None = None) -&gt; str:\n        \"\"\"Saves model element to a file.\n\n        Args:\n            string (str): String to be saved.\n            path (str): Path to the file.\n            filename (str): File name.\n\n        Returns:\n            str: Success message.\n        \"\"\"\n        save_file(\n            string=string,\n            fname=filename,\n            extension=extension,\n            path=path\n        )\n        return f'{filename}.{extension} saved successfully.'\n\n    def model_string(self) -&gt; str:\n        \"\"\"Returns a custom model string representation that matches the requirements of .swp file.\n\n        Note:\n            If values are simple types, they are formatted as 'ATTR = VALUE'. If the valies are\n            tables (in pySWAP pd.DataFrame are used), they are formatted simply as 'TABLE_VALUE'. Additionally,\n            a custom serializer (pyswap.core.utils.serializers.quote_string) is used to quote strings.\n\n        Returns:\n            str: Custom model string representation.\n        \"\"\"\n        string = ''\n\n        def formatter(attr, value, string):\n            if attr.startswith('table_') or attr.startswith('list_'):\n                return string + value\n            else:\n                return string + f'{attr.upper()} = {quote_string(value)}\\n'\n\n        for attr, value in self.model_dump(\n                mode='json', exclude_none=True).items():\n            if isinstance(value, dict):\n                for k, v in value.items():\n                    string = formatter(k, v, string)\n            else:\n                string = formatter(attr, value, string)\n\n        return string\n\n    def _concat_sections(self) -&gt; str:\n        \"\"\"Concatenate a string from individual sections.\n\n        This method is meant to be used on models that collect other\n        models, like DraFile, or Model.\n        \"\"\"\n\n        string = ''\n        for k, v in dict(self).items():\n            if v is None or isinstance(v, str):\n                continue\n            string += v.model_string()\n        return string\n</code></pre>"},{"location":"reference/api-reference/#pyswap.core.basemodel.PySWAPBaseModel.model_string","title":"<code>model_string()</code>","text":"<p>Returns a custom model string representation that matches the requirements of .swp file.</p> Note <p>If values are simple types, they are formatted as 'ATTR = VALUE'. If the valies are tables (in pySWAP pd.DataFrame are used), they are formatted simply as 'TABLE_VALUE'. Additionally, a custom serializer (pyswap.core.utils.serializers.quote_string) is used to quote strings.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Custom model string representation.</p> Source code in <code>pyswap/core/basemodel.py</code> <pre><code>def model_string(self) -&gt; str:\n    \"\"\"Returns a custom model string representation that matches the requirements of .swp file.\n\n    Note:\n        If values are simple types, they are formatted as 'ATTR = VALUE'. If the valies are\n        tables (in pySWAP pd.DataFrame are used), they are formatted simply as 'TABLE_VALUE'. Additionally,\n        a custom serializer (pyswap.core.utils.serializers.quote_string) is used to quote strings.\n\n    Returns:\n        str: Custom model string representation.\n    \"\"\"\n    string = ''\n\n    def formatter(attr, value, string):\n        if attr.startswith('table_') or attr.startswith('list_'):\n            return string + value\n        else:\n            return string + f'{attr.upper()} = {quote_string(value)}\\n'\n\n    for attr, value in self.model_dump(\n            mode='json', exclude_none=True).items():\n        if isinstance(value, dict):\n            for k, v in value.items():\n                string = formatter(k, v, string)\n        else:\n            string = formatter(attr, value, string)\n\n    return string\n</code></pre>"},{"location":"reference/api-reference/#pyswap.core.basemodel.PySWAPBaseModel.save_element","title":"<code>save_element(string, path, filename, extension=None)</code>  <code>staticmethod</code>","text":"<p>Saves model element to a file.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>String to be saved.</p> required <code>path</code> <code>str</code> <p>Path to the file.</p> required <code>filename</code> <code>str</code> <p>File name.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Success message.</p> Source code in <code>pyswap/core/basemodel.py</code> <pre><code>@staticmethod\ndef save_element(string: str, path: str, filename: str, extension: str | None = None) -&gt; str:\n    \"\"\"Saves model element to a file.\n\n    Args:\n        string (str): String to be saved.\n        path (str): Path to the file.\n        filename (str): File name.\n\n    Returns:\n        str: Success message.\n    \"\"\"\n    save_file(\n        string=string,\n        fname=filename,\n        extension=extension,\n        path=path\n    )\n    return f'{filename}.{extension} saved successfully.'\n</code></pre>"},{"location":"reference/api-reference/#pyswap.core.database","title":"<code>database</code>","text":"<p>All modules related to the database connection and models.</p> <p>Warning</p> <p>This module is in review and may be significantly changed or removed in the future.</p> <p>Tip</p> <p>pySWAP is meant to enable saving model runs to a SQLite database. That way, the users will be  able to easily exchange models they built and run them on their own machines.</p>"},{"location":"reference/api-reference/#pyswap.core.database.connection","title":"<code>connection</code>","text":"<p>This module is responsible for creating a connection to the database.</p> <p>Classes:</p> Name Description <code>DatabaseConnection</code> <p>Creates a connection to the database.</p>"},{"location":"reference/api-reference/#pyswap.core.database.connection.DatabaseConnection","title":"<code>DatabaseConnection</code>","text":"<p>Creates a connection to the database.</p> <p>Upon calling the connect method, a check is made to see if the database file exists. If it does not, the file is created. The tables are then checked and created if they do not exist.</p> <p>Attributes:</p> Name Type Description <code>engine</code> <p>The database engine.</p> <code>session</code> <p>The database session.</p> <code>db_path</code> <p>The path to the database file.</p> <p>Methods:</p> Name Description <code>connect</code> <p>Connect to the database.</p> Source code in <code>pyswap/core/database/connection.py</code> <pre><code>class DatabaseConnection:\n    \"\"\"Creates a connection to the database.\n\n    Upon calling the connect method, a check is made to see if the database file\n    exists. If it does not, the file is created. The tables are then checked\n    and created if they do not exist.\n\n    Attributes:\n        engine: The database engine.\n        session: The database session.\n        db_path: The path to the database file.\n\n    Methods:\n        connect: Connect to the database.\n    \"\"\"\n\n    def __init__(self, db_path: str = 'pyswap.db'):\n        self.engine = None\n        self.session = None\n        self.db_path = db_path\n        self.connect()\n\n    def connect(self):\n        \"\"\"Connect to the dabase or create a new one.\"\"\"\n        if os.path.exists(self.db_path):\n            if os.path.isfile(self.db_path):\n                print(\"Database exists. Connecting...\")\n\n        else:\n            print(\"Database does not exist. Creating...\")\n\n        self.engine = create_engine(f'sqlite:///{self.db_path}')\n        session = sessionmaker(bind=self.engine)\n        self.session = session()\n\n        # Check if tables exist in the database\n        inspector = inspect(self.engine)\n        table_names = inspector.get_table_names()\n\n        for table in Base.metadata.tables.keys():\n            if table not in table_names:\n                print(\n                    f\"Table {table} does not exist in the database. Creating...\")\n                Base.metadata.tables[table].create(self.engine)\n            else:\n                print(f\"Table {table} exists in the database.\")\n</code></pre>"},{"location":"reference/api-reference/#pyswap.core.database.connection.DatabaseConnection.connect","title":"<code>connect()</code>","text":"<p>Connect to the dabase or create a new one.</p> Source code in <code>pyswap/core/database/connection.py</code> <pre><code>def connect(self):\n    \"\"\"Connect to the dabase or create a new one.\"\"\"\n    if os.path.exists(self.db_path):\n        if os.path.isfile(self.db_path):\n            print(\"Database exists. Connecting...\")\n\n    else:\n        print(\"Database does not exist. Creating...\")\n\n    self.engine = create_engine(f'sqlite:///{self.db_path}')\n    session = sessionmaker(bind=self.engine)\n    self.session = session()\n\n    # Check if tables exist in the database\n    inspector = inspect(self.engine)\n    table_names = inspector.get_table_names()\n\n    for table in Base.metadata.tables.keys():\n        if table not in table_names:\n            print(\n                f\"Table {table} does not exist in the database. Creating...\")\n            Base.metadata.tables[table].create(self.engine)\n        else:\n            print(f\"Table {table} exists in the database.\")\n</code></pre>"},{"location":"reference/api-reference/#pyswap.core.database.hdf5","title":"<code>hdf5</code>","text":"<p>This file contains classes and functions for handling HDF5 integration.</p>"},{"location":"reference/api-reference/#pyswap.core.database.hdf5.HDF5","title":"<code>HDF5</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>pyswap/core/database/hdf5.py</code> <pre><code>class HDF5(BaseModel):\n\n    filename: str\n    models: Optional[dict] = Field(default_factory=dict)\n\n    @computed_field(return_type=dict)\n    def list_projects(self):\n        with h5py.File(self.filename, 'a') as f:\n            # Use the visititems method to traverse the file structure\n            projects = list(f.keys())\n        return projects\n\n    @staticmethod\n    def _get_or_create_group(f, group_name):\n        if group_name not in f:\n            try:\n                f.create_group(group_name)\n            except ValueError:\n                raise ValueError(\n                    f'Cannot create group {group_name}. It may already exist. If you want to overwrite it, set overwrite=True.')\n        return f[group_name]\n\n    def save_model(self,\n                   model: Model,\n                   result: Optional[Result] = None,\n                   overwrite_datasets: bool = False,\n                   overwrite_project: bool = False,\n                   mode: Literal['python', 'json', 'yaml'] = 'python'):\n        \"\"\"Sava a model and its results to an HDF5 file.\n\n        Each model in its metadata attribute stores the project name. That is used as the name for the main group. If that name already exists,\n        a new group is not created. Then the check is made if the version of the model already exists. If it does, the group is not created.\n        \"\"\"\n\n        def _overwrite_datasets(group):\n            for key in list(group.keys()):\n                try:\n                    del group[key]\n                except KeyError:\n                    pass\n\n        def _overwrite_project(f, project_name):\n            try:\n                del f[project_name]\n            except KeyError:\n                pass\n\n        def _save_pickled(group, name, data):\n            try:\n                pickle_data = pickle.dumps(data)\n                group.create_dataset(name, data=np.void(pickle_data))\n            except ValueError:\n                raise ValueError(\n                    f'Cannot create dataset {name}. It may already exist. If you want to overwrite it, set overwrite=True.')\n\n        with h5py.File(self.filename, 'a') as f:\n\n            if overwrite_project:\n                _overwrite_project(f, model.metadata.project)\n            # create a project and add attributes\n            project_group = self._get_or_create_group(\n                f, model.metadata.project)\n            project_attrs = model.metadata.__dict__\n            project_attrs = {k: v for k,\n                             v in project_attrs.items() if v is not None}\n\n            project_group.attrs.update(project_attrs)\n\n            # create a model group with input and output datasets\n            model_group = self._get_or_create_group(\n                project_group, model.version)\n\n            if overwrite_datasets:\n                _overwrite_datasets(model_group)\n\n            if mode == 'python':\n                # For the python option there is no need for an additional group\n                _save_pickled(model_group, 'input', model)\n                if result:\n                    _save_pickled(model_group, 'output', result)\n\n            if mode == 'json':\n                raise NotImplementedError('JSON mode is not yet implemented')\n\n            if mode == 'yaml':\n                raise NotImplementedError('YAML mode is not yet implemented')\n\n    def load(self, project: str, model: Optional[str] = None, load_results: bool = False, mode: Literal['python', 'json', 'yaml'] = 'python') -&gt; Tuple[Model, Result]:\n        \"\"\"Load a single model or all models within a specific project.\"\"\"\n\n        def _load_pickled(group: h5py.Group, name: str, load_results: bool) -&gt; Tuple[Model, Result]:\n            pickle_in = group[name]['input'][()].tobytes()\n            pickle_out = group[name]['output'][()].tobytes(\n            ) if load_results else None\n\n            model = pickle.loads(pickle_in)\n            result = pickle.loads(pickle_out) if load_results else None\n            return model, result\n\n        with h5py.File(self.filename, 'r') as f:\n            project_grp = f[project]\n\n            if mode == 'python':\n                if model is None:\n                    all_models = list(project_grp.keys())\n                    for item in all_models:\n                        self.models[item] = _load_pickled(\n                            group=project_grp, name=item, load_results=load_results)\n\n                else:\n                    self.models[model] = _load_pickled(\n                        group=project_grp, name=model, load_results=load_results)\n\n            if mode == 'json':\n                raise NotImplementedError('JSON mode is not yet implemented')\n\n            if mode == 'yaml':\n                raise NotImplementedError('YAML mode is not yet implemented')\n</code></pre>"},{"location":"reference/api-reference/#pyswap.core.database.hdf5.HDF5.load","title":"<code>load(project, model=None, load_results=False, mode='python')</code>","text":"<p>Load a single model or all models within a specific project.</p> Source code in <code>pyswap/core/database/hdf5.py</code> <pre><code>def load(self, project: str, model: Optional[str] = None, load_results: bool = False, mode: Literal['python', 'json', 'yaml'] = 'python') -&gt; Tuple[Model, Result]:\n    \"\"\"Load a single model or all models within a specific project.\"\"\"\n\n    def _load_pickled(group: h5py.Group, name: str, load_results: bool) -&gt; Tuple[Model, Result]:\n        pickle_in = group[name]['input'][()].tobytes()\n        pickle_out = group[name]['output'][()].tobytes(\n        ) if load_results else None\n\n        model = pickle.loads(pickle_in)\n        result = pickle.loads(pickle_out) if load_results else None\n        return model, result\n\n    with h5py.File(self.filename, 'r') as f:\n        project_grp = f[project]\n\n        if mode == 'python':\n            if model is None:\n                all_models = list(project_grp.keys())\n                for item in all_models:\n                    self.models[item] = _load_pickled(\n                        group=project_grp, name=item, load_results=load_results)\n\n            else:\n                self.models[model] = _load_pickled(\n                    group=project_grp, name=model, load_results=load_results)\n\n        if mode == 'json':\n            raise NotImplementedError('JSON mode is not yet implemented')\n\n        if mode == 'yaml':\n            raise NotImplementedError('YAML mode is not yet implemented')\n</code></pre>"},{"location":"reference/api-reference/#pyswap.core.database.hdf5.HDF5.save_model","title":"<code>save_model(model, result=None, overwrite_datasets=False, overwrite_project=False, mode='python')</code>","text":"<p>Sava a model and its results to an HDF5 file.</p> <p>Each model in its metadata attribute stores the project name. That is used as the name for the main group. If that name already exists, a new group is not created. Then the check is made if the version of the model already exists. If it does, the group is not created.</p> Source code in <code>pyswap/core/database/hdf5.py</code> <pre><code>def save_model(self,\n               model: Model,\n               result: Optional[Result] = None,\n               overwrite_datasets: bool = False,\n               overwrite_project: bool = False,\n               mode: Literal['python', 'json', 'yaml'] = 'python'):\n    \"\"\"Sava a model and its results to an HDF5 file.\n\n    Each model in its metadata attribute stores the project name. That is used as the name for the main group. If that name already exists,\n    a new group is not created. Then the check is made if the version of the model already exists. If it does, the group is not created.\n    \"\"\"\n\n    def _overwrite_datasets(group):\n        for key in list(group.keys()):\n            try:\n                del group[key]\n            except KeyError:\n                pass\n\n    def _overwrite_project(f, project_name):\n        try:\n            del f[project_name]\n        except KeyError:\n            pass\n\n    def _save_pickled(group, name, data):\n        try:\n            pickle_data = pickle.dumps(data)\n            group.create_dataset(name, data=np.void(pickle_data))\n        except ValueError:\n            raise ValueError(\n                f'Cannot create dataset {name}. It may already exist. If you want to overwrite it, set overwrite=True.')\n\n    with h5py.File(self.filename, 'a') as f:\n\n        if overwrite_project:\n            _overwrite_project(f, model.metadata.project)\n        # create a project and add attributes\n        project_group = self._get_or_create_group(\n            f, model.metadata.project)\n        project_attrs = model.metadata.__dict__\n        project_attrs = {k: v for k,\n                         v in project_attrs.items() if v is not None}\n\n        project_group.attrs.update(project_attrs)\n\n        # create a model group with input and output datasets\n        model_group = self._get_or_create_group(\n            project_group, model.version)\n\n        if overwrite_datasets:\n            _overwrite_datasets(model_group)\n\n        if mode == 'python':\n            # For the python option there is no need for an additional group\n            _save_pickled(model_group, 'input', model)\n            if result:\n                _save_pickled(model_group, 'output', result)\n\n        if mode == 'json':\n            raise NotImplementedError('JSON mode is not yet implemented')\n\n        if mode == 'yaml':\n            raise NotImplementedError('YAML mode is not yet implemented')\n</code></pre>"},{"location":"reference/api-reference/#pyswap.core.database.models","title":"<code>models</code>","text":"<p>SQLAlchemy models for the pySWAP database.</p> Important assumptions <ol> <li>There is always an initial SWAP model which is saved in the SWAPModel table.</li> <li>Each SWAPModel belongs to only one project.</li> <li>Each SWAPModel has one or mode runs which are saved in the ModelRun table.</li> <li>One ModelRun has exactly one ModelOutput</li> </ol>"},{"location":"reference/api-reference/#pyswap.core.database.models.Data","title":"<code>Data</code>","text":"<p>               Bases: <code>Base</code></p> <p>Stores data files like meteo data or crop data.</p> Source code in <code>pyswap/core/database/models.py</code> <pre><code>class Data(Base):\n    \"\"\"Stores data files like meteo data or crop data.\"\"\"\n\n    __tablename__ = 'data'\n\n    did = Column(Integer, primary_key=True)\n    fname = Column(String(50), nullable=False, unique=True)\n    datafile = Column(LargeBinary)\n    swapruns = relationship(\n        'SWAPRun', secondary=data_swaprun_association, back_populates='data')\n</code></pre>"},{"location":"reference/api-reference/#pyswap.core.database.models.SWAPRun","title":"<code>SWAPRun</code>","text":"<p>               Bases: <code>Base</code></p> <p>This model stores sections of the .swp file</p> Source code in <code>pyswap/core/database/models.py</code> <pre><code>class SWAPRun(Base):\n    \"\"\"This model stores sections of the .swp file\"\"\"\n\n    __tablename__ = 'swapmodel'\n\n    mid = Column(String(50), primary_key=True)\n    rid = Column(String(50), default='initial', primary_key=True)\n    swp = Column(LargeBinary, nullable=True)\n    data = relationship(\n        'Data', secondary=data_swaprun_association, back_populates='swapruns')\n    result = Column(LargeBinary, nullable=True)\n\n    __table_args__ = (UniqueConstraint('mid', 'rid', name='uq_model_run'),)\n</code></pre>"},{"location":"reference/api-reference/#pyswap.core.defaults","title":"<code>defaults</code>","text":"<p>Default values for the Richards' equation</p>"},{"location":"reference/api-reference/#pyswap.core.fields","title":"<code>fields</code>","text":"<p>Custom field types used for serilization in the model_dump(mode='json').</p> <p>Other Parameters:</p> Name Type Description <code>Table</code> <code>DataFrame</code> <p>A DataFrame object serialized as a string with just the headers and the data.</p> <code>Arrays</code> <code>DataFrame</code> <p>A DataFrame object serialized as a string with just the columns of data (no headers), but with the variable name in front (e.g., FLUXTB = 0.0 0.0/n 1.0 1.0 )</p> <code>CSVTable</code> <code>DataFrame</code> <p>A DataFrame object serialized as a string with the headers and data in CSV format,  specifically tailored for the .met file format.</p> <code>DayMonth</code> <code>date</code> <p>A date object serialized as a string with just the day and month (e.g., '01 01').</p> <code>StringList</code> <code>List[str]</code> <p>A list of strings serialized as a string with the elements separated by commas, enclosed in quotation marks (e.g., 'string1, string2, string3').</p> <code>FloatList</code> <code>List[float]</code> <p>A list of floats serialized as a string with the elements separated by spaces.</p> <code>DateList</code> <code>List[date]</code> <p>A list of date objects serialized as a string with the elements separated by newlines.</p> <code>Switch</code> <code>bool | int</code> <p>A boolean or integer serialized as an integer (0 or 1).</p> <code>ObjectList</code> <code>list</code> <p>A list of objects serialized as a string with the elements separated by newlines.</p>"},{"location":"reference/api-reference/#pyswap.core.files","title":"<code>files</code>","text":"<p>Simple module to interact with files.</p>"},{"location":"reference/api-reference/#pyswap.core.files.open_file","title":"<code>open_file(file_path)</code>","text":"<p>Open file and detect encoding.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to the file to be opened.</p> required Source code in <code>pyswap/core/files.py</code> <pre><code>def open_file(file_path: str) -&gt; str:\n    \"\"\"Open file and detect encoding.\n\n    Arguments:\n        file_path (str): Path to the file to be opened.\n    \"\"\"\n    with open(file_path, 'rb') as f:\n        raw_data = f.read()\n    encoding = chardet.detect(raw_data)['encoding']\n\n    return raw_data.decode(encoding)\n</code></pre>"},{"location":"reference/api-reference/#pyswap.core.files.save_file","title":"<code>save_file(string, fname, path, mode='w', extension=None, encoding='ascii')</code>","text":"<p>Saves a string to a file.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>The string to be saved to a file.</p> required <code>extension</code> <code>str | None</code> <p>The extension that the file should have (e.g. 'txt', 'csv', etc.).</p> <code>None</code> <code>fname</code> <code>str</code> <p>The name of the file.</p> required <code>path</code> <code>str</code> <p>The path where the file should be saved.</p> required <code>mode</code> <code>str</code> <p>The mode in which the file should be opened (e.g. 'w' for write, 'a' for append, etc.).</p> <code>'w'</code> <code>encoding</code> <code>str</code> <p>The encoding to use for the file (default is 'ascii').</p> <code>'ascii'</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pyswap/core/files.py</code> <pre><code>def save_file(string: str,\n              fname: str,\n              path: str,\n              mode: str = 'w',\n              extension: str | None = None,\n              encoding: str = 'ascii') -&gt; None:\n    \"\"\"\n    Saves a string to a file.\n\n    Arguments:\n        string: The string to be saved to a file.\n        extension: The extension that the file should have (e.g. 'txt', 'csv', etc.).\n        fname: The name of the file.\n        path: The path where the file should be saved.\n        mode: The mode in which the file should be opened (e.g. 'w' for write, 'a' for append, etc.).\n        encoding: The encoding to use for the file (default is 'ascii').\n\n    Returns:\n        None\n    \"\"\"\n\n    if extension is not None:\n        fname = f'{fname}.{extension}'\n\n    with open(f'{path}/{fname}', f'{mode}', encoding=f'{encoding}') as f:\n        f.write(string)\n</code></pre>"},{"location":"reference/api-reference/#pyswap.core.plot","title":"<code>plot</code>","text":"<p>Plotting functionality for pySWAP.</p> <p>Modules:</p> Name Description <code>evapotranspiration</code> <p>Functions for plotting evapotranspiration data.</p> <code>gwl</code> <p>Functions for plotting groundwater level data.</p> <code>watercontent</code> <p>Functions for plotting water content data.</p>"},{"location":"reference/api-reference/#pyswap.core.plot.watercontent","title":"<code>watercontent</code>","text":""},{"location":"reference/api-reference/#pyswap.core.plot.watercontent.water_content","title":"<code>water_content(df_vap, title='Water content')</code>","text":"<p>Plot water content as heatmap with time on the x-axis and depth on the y-axis.</p> <p>Parameters:</p> Name Type Description Default <code>df_vap</code> <code>DataFrame</code> <p>DataFrame containing the water content data</p> required <code>title</code> <code>str</code> <p>Title of the plot. Defaults to 'Water content'.</p> <code>'Water content'</code> Source code in <code>pyswap/core/plot/watercontent.py</code> <pre><code>def water_content(df_vap: pd.DataFrame, title: str = 'Water content'):\n    \"\"\"Plot water content as heatmap with time on the x-axis and depth on the y-axis.\n\n    Parameters:\n        df_vap (pd.DataFrame): DataFrame containing the water content data\n        title (str, optional): Title of the plot. Defaults to 'Water content'.\n    \"\"\"\n    sns.set_context('poster')\n\n    df_wcont = df_vap[['depth', 'date', 'wcontent']]\n    df_wcont['date'] = pd.to_datetime(\n        df_wcont['date'])\n    df_wcont['date'] = df_wcont['date'].dt.strftime('%Y-%m')\n    df_wcont['depth'] = df_wcont['depth'].astype(float)\n    df_wcont['wcontent'] = df_wcont['wcontent'].astype(float)\n    pivot_table = df_wcont.pivot(\n        columns='date', index='depth', values='wcontent')\n\n    pivot_table.sort_index(ascending=True, inplace=True)\n    plt.figure(figsize=(34, 8))\n    ax = sns.heatmap(pivot_table, cmap=\"YlGnBu\")\n    plt.title(title)\n    plt.xlabel('Date')\n    plt.ylabel('Depth (cm)')\n\n    plt.gca().invert_yaxis()\n\n    plt.xticks(rotation=45)\n    plt.tight_layout(pad=20)\n    plt.show()\n</code></pre>"},{"location":"reference/api-reference/#pyswap.core.serializers","title":"<code>serializers</code>","text":"<p>Functions serializing obects to the appropriate format used in the custom pyswap fields  (pyswap.core.utils.fields)</p>"},{"location":"reference/api-reference/#pyswap.core.serializers.is_scientific_notation","title":"<code>is_scientific_notation(s)</code>","text":"<p>Check if a string represents a number in scientific notation.</p> <p>The pattern matches strings in scientific notation, e.g., '1.23e-4', '2E+2'</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>The string to be checked.</p> required Source code in <code>pyswap/core/serializers.py</code> <pre><code>def is_scientific_notation(s: str) -&gt; str:\n    \"\"\"Check if a string represents a number in scientific notation.\n\n    The pattern matches strings in scientific notation, e.g., '1.23e-4', '2E+2'\n\n    Args:\n        s: The string to be checked.\n    \"\"\"\n    pattern = r'^[+-]?(\\d+(\\.\\d*)?|\\.\\d+)[eE][+-]?\\d+$'\n    return re.match(pattern, s) is not None\n</code></pre>"},{"location":"reference/api-reference/#pyswap.core.serializers.quote_string","title":"<code>quote_string(string)</code>","text":"<p>Quote the string if it contains alphabetic characters or './', except for scientific notation.</p> Source code in <code>pyswap/core/serializers.py</code> <pre><code>def quote_string(string) -&gt; str:\n    \"\"\"Quote the string if it contains alphabetic characters or './', except for scientific notation.\"\"\"\n\n    string = str(string)\n\n    # Check for scientific notation first\n    if is_scientific_notation(string):\n        return string.upper()\n\n    if re.search(\"[a-zA-Z/]\", string):\n        return f\"'{string}'\"\n    if re.search(r\".\\\\\", string):\n        return f\"'{string}'\"\n    else:\n        return string\n</code></pre>"},{"location":"reference/api-reference/#pyswap.core.serializers.serialize_arrays","title":"<code>serialize_arrays(table)</code>","text":"<p>Convert the DataFrame to a string without headers and newline in front</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>DataFrame</code> <p>The DataFrame to be serialized.</p> required Source code in <code>pyswap/core/serializers.py</code> <pre><code>def serialize_arrays(table: DataFrame) -&gt; str:\n    \"\"\"Convert the DataFrame to a string without headers and newline in front\n\n    Args:\n        table: The DataFrame to be serialized.\n    \"\"\"\n    return f'\\n{table.to_string(index=False, header=False)}\\n'\n</code></pre>"},{"location":"reference/api-reference/#pyswap.core.serializers.serialize_csv_table","title":"<code>serialize_csv_table(table)</code>","text":"<p>Convert the DataFrame to a string in CSV format.</p> <p>This serializer is specifically tailored to output the data in the format of the ,met files used in SWAP.</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>DataFrame</code> <p>The DataFrame to be serialized.</p> required Source code in <code>pyswap/core/serializers.py</code> <pre><code>def serialize_csv_table(table: DataFrame) -&gt; str:\n    \"\"\"Convert the DataFrame to a string in CSV format.\n\n    This serializer is specifically tailored to output the data in the\n    format of the ,met files used in SWAP.\n\n    Args:\n        table: The DataFrame to be serialized.\n    \"\"\"\n    if isinstance(table.index, DatetimeIndex):\n        table['DD'] = table.index.day\n        table['MM'] = table.index.month\n        table['YYYY'] = table.index.year\n        required_order = ['Station', 'DD', 'MM', 'YYYY', 'RAD',\n                          'Tmin', 'Tmax', 'HUM', 'WIND', 'RAIN', 'ETref', 'WET']\n        table = table[required_order]\n\n    table.loc[:, 'Station'] = table.Station.apply(\n        lambda x: f\"'{x}'\" if not str(x).startswith(\"'\") else x)\n    return table.to_csv(index=False, lineterminator='\\n')\n</code></pre>"},{"location":"reference/api-reference/#pyswap.core.serializers.serialize_object_list","title":"<code>serialize_object_list(list)</code>","text":"<p>Serialize a list of objects to a string.</p> Source code in <code>pyswap/core/serializers.py</code> <pre><code>def serialize_object_list(list) -&gt; str:\n    \"\"\"Serialize a list of objects to a string.\"\"\"\n    string = ''\n    for item in list:\n        string += item.model_string()\n\n    return string\n</code></pre>"},{"location":"reference/api-reference/#pyswap.core.serializers.serialize_table","title":"<code>serialize_table(table)</code>","text":"<p>Convert the DataFrame to a string with the headers in uppercase.</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>DataFrame</code> <p>The DataFrame to be serialized.</p> required Source code in <code>pyswap/core/serializers.py</code> <pre><code>def serialize_table(table: DataFrame) -&gt; str:\n    \"\"\"Convert the DataFrame to a string with the headers in uppercase.\n\n    Args:\n        table: The DataFrame to be serialized.\n    \"\"\"\n    table.columns = [header.upper() for header in table.columns]\n    return f'{table.to_string(index=False)}\\n'\n</code></pre>"},{"location":"reference/api-reference/#pyswap.core.tablevalidation","title":"<code>tablevalidation</code>","text":"<p>Pandera schemas for validating tables in pySWAP.</p> <p>The schemas are used to validate pandas DataFrames used in the pySWAP models. They also help to enforce the appropriate data types required by the SWAP model.</p> <p>Warning</p> <p>This is an experimental feature and is currently only implemented in the  irrigation subpackage. If no bugs are found, it will be implemented in the other subpackages.</p> <p>Classes:</p> Name Description <code>BaseModel</code> <p>Base class for all pySWAP schemas.</p>"},{"location":"reference/api-reference/#pyswap.core.tablevalidation.BaseModel","title":"<code>BaseModel</code>","text":"<p>               Bases: <code>DataFrameModel</code></p> <p>Base model with create method for preprocessing and validation.</p> Source code in <code>pyswap/core/tablevalidation.py</code> <pre><code>class BaseModel(pa.DataFrameModel):\n    \"\"\"Base model with create method for preprocessing and validation.\"\"\"\n\n    class Config:\n        coerce = True\n\n    @classmethod\n    def create(cls, data: dict) -&gt; DataFrame:\n        df = pd.DataFrame(data)\n        df.columns = df.columns.str.upper()\n        validated_df = cls.validate(df)\n        return validated_df\n</code></pre>"},{"location":"reference/api-reference/#pyswap.core.valueranges","title":"<code>valueranges</code>","text":"<p>Commonly used ranges of values for pydantic Field() objects.</p> <p>Other Parameters:</p> Name Type Description <code>UNITRANGE</code> <code>dict</code> <p>Range of values between 0.0 and 1.0.</p> <code>YEARRANGE</code> <code>dict</code> <p>Range of values for year (0 &lt;= x &lt;= 366).</p> <code>DVSRANGE</code> <code>dict</code> <p>Range of values for development stage (0 &lt;= x &lt;= 2).</p>"},{"location":"reference/api-reference/#pyswap.core.valueranges.DVSRANGE","title":"<code>DVSRANGE = {'ge': 0.0, 'le': 2.0}</code>  <code>module-attribute</code>","text":"<p>Range of values for development stage (0 &lt;= x &lt;= 2).</p>"},{"location":"reference/api-reference/#pyswap.core.valueranges.UNITRANGE","title":"<code>UNITRANGE = {'ge': 0.0, 'le': 1.0}</code>  <code>module-attribute</code>","text":"<p>Range of values between 0.0 and 1.0.</p>"},{"location":"reference/api-reference/#pyswap.core.valueranges.YEARRANGE","title":"<code>YEARRANGE = {'ge': 0, 'le': 366}</code>  <code>module-attribute</code>","text":"<p>Range of values for year (0 &lt;= x &lt;= 366).</p>"},{"location":"reference/api-reference/#pyswap.core.plot.watercontent","title":"<code>watercontent</code>","text":""},{"location":"reference/api-reference/#pyswap.core.plot.watercontent.water_content","title":"<code>water_content(df_vap, title='Water content')</code>","text":"<p>Plot water content as heatmap with time on the x-axis and depth on the y-axis.</p> <p>Parameters:</p> Name Type Description Default <code>df_vap</code> <code>DataFrame</code> <p>DataFrame containing the water content data</p> required <code>title</code> <code>str</code> <p>Title of the plot. Defaults to 'Water content'.</p> <code>'Water content'</code> Source code in <code>pyswap/core/plot/watercontent.py</code> <pre><code>def water_content(df_vap: pd.DataFrame, title: str = 'Water content'):\n    \"\"\"Plot water content as heatmap with time on the x-axis and depth on the y-axis.\n\n    Parameters:\n        df_vap (pd.DataFrame): DataFrame containing the water content data\n        title (str, optional): Title of the plot. Defaults to 'Water content'.\n    \"\"\"\n    sns.set_context('poster')\n\n    df_wcont = df_vap[['depth', 'date', 'wcontent']]\n    df_wcont['date'] = pd.to_datetime(\n        df_wcont['date'])\n    df_wcont['date'] = df_wcont['date'].dt.strftime('%Y-%m')\n    df_wcont['depth'] = df_wcont['depth'].astype(float)\n    df_wcont['wcontent'] = df_wcont['wcontent'].astype(float)\n    pivot_table = df_wcont.pivot(\n        columns='date', index='depth', values='wcontent')\n\n    pivot_table.sort_index(ascending=True, inplace=True)\n    plt.figure(figsize=(34, 8))\n    ax = sns.heatmap(pivot_table, cmap=\"YlGnBu\")\n    plt.title(title)\n    plt.xlabel('Date')\n    plt.ylabel('Depth (cm)')\n\n    plt.gca().invert_yaxis()\n\n    plt.xticks(rotation=45)\n    plt.tight_layout(pad=20)\n    plt.show()\n</code></pre>"},{"location":"user-guide/1-main-concepts/","title":"Main concepts","text":""},{"location":"user-guide/1-main-concepts/#swap_model_settings","title":"SWAP model settings","text":"<p>A SWAP model requires a number of input variables in several different files. Traditionally, those variables are groupped into distinct sections and section parts in the input file templates. Below is an example of the :</p> <pre><code>**********************************************************************************\n* Part 8: Snow and frost\n\n* Switch, calculate snow accumulation and melt:\n  SWSNOW = {{SWSNOW}}        ! 0 = no simulation of snow\n                             ! 1 = simulation of snow accumulation and melt\n\n{{#SWITCH_SWSNOW_OPTION_1}}\n* If SWSNOW = 1, specify:\n  SNOWINCO = {{SNOWINCO}}    ! Initial snow water equivalent [0..1000 cm, R]\n  TEPRRAIN = {{TEPRRAIN}}    ! Temperature above which all precipitation is rain[ 0..10 oC, R]\n  TEPRSNOW = {{TEPRSNOW}}    ! Temperature below which all precipitation is snow[-10..0 oC, R]\n  SNOWCOEF = {{SNOWCOEF}}    ! Snowmelt calibration factor [0...10 -, R]\n\n{{/SWITCH_SWSNOW_OPTION_1}}\n* Switch, in case of frost reduce soil water flow:\n  SWFROST = {{SWFROST}}      ! 0 = no simulation of frost\n                             ! 1 = simulation of frost reduce soil water flow\n\n{{#SWITCH_SWFROST_OPTION_1}}\n* If SWFROST = 1, then specify soil temperature to start end end flux-reduction\n  TFROSTSTA = {{TFROSTSTA}}  ! Soil temperature (oC) where reduction of water fluxes starts [-10.0,5.0, oC, R]\n  TFROSTEND = {{TFROSTEND}}  ! Soil temperature (oC) where reduction of water fluxes ends [-10.0,5.0, oC, R]\n\n{{/SWITCH_SWFROST_OPTION_1}}\n**********************************************************************************\n</code></pre>"},{"location":"user-guide/1-main-concepts/#pyswap_generic_classes","title":"pySWAP Generic classes","text":"<p>In pySWAP, the specific settings are groupped into generic classes. Each class, just like the section/section part, collects related settings together. An example of a class for snow and frost snow settings is presented below:</p> <pre><code>class SnowAndFrost(PySWAPBaseModel):\n    \"\"\"Snow and frost settings for the model.\n\n    Attributes:\n        swsnow (Literal[0, 1]): Switch for calculation of snow accumulation and melt.\n        swfrost (Literal[0, 1]): Switch,  in case of frost reduce soil water flow\n        snowinco (Optional[float]): Initial snow water equivalent\n        teprrain (Optional[float]): Temperature above which all precipitation is rain\n        teprsnow (Optional[float]): Temperature below which all precipitation is snow\n        snowcoef (Optional[float]): Snowmelt calibration factor\n        tfroststa (Optional[float]): Soil temperature (oC) where reduction of water fluxes starts\n        tfrostend (Optional[float]): Soil temperature (oC) where reduction of water fluxes ends\n\n    \"\"\"\n\n    swsnow: Literal[0, 1]\n    swfrost: Literal[0, 1]\n    snowinco: Optional[float] = None\n    teprrain: Optional[float] = None\n    teprsnow: Optional[float] = None\n    snowcoef: Optional[float] = None\n    tfrostst: Optional[float] = None\n    tfrostend: Optional[float] = None\n</code></pre> <p>Some classes have additional methods, but some just serve as \"containers\" for the variables. The purpose of that simple structure is mostly giving the model creation script a structure and validation.</p>"},{"location":"user-guide/2-quick-start/","title":"Quickstart","text":"<p>If you know a lot already about SWAP and pySWAP, feel free to jump straight to the installation, running the test case and setting up your own model.</p>"},{"location":"user-guide/2-quick-start/#installation","title":"Installation","text":"<p>Currently the package is only distributed through GitHub (<code>pip install pyswap</code> will come soon). To get pyswap up and running type:</p> <pre><code>git clone --recurse-submodules https://github.com/zawadzkim/pySWAP.git\n</code></pre> <p>Note</p> <p>Please note that it is necessary to use <code>--recurse-submodule</code> flag to make sure that additional submodules in the library are also cloned along with pySWAP.</p> <p>Once you are in the freshly cloned repo, type:</p> <pre><code>pip install .\n</code></pre> <p>You can also install it in development mode in case you would like to make changes (and hopefully submit PRs):</p> <pre><code>pip install -e .\n</code></pre>"},{"location":"user-guide/2-quick-start/#run_a_test_case","title":"Run a test case","text":"<p>To see if everything is working fine, open the Python shell and type:</p> <pre><code>&gt;&gt;&gt; from pyswap import testcase\n\n&gt;&gt;&gt; hupsel = testcase.get('hupsel')  # retrieves the hupsel model settings\n&gt;&gt;&gt; result = hupsel.run()\n&gt;&gt;&gt; print(result.summary)\n</code></pre> <p>You should get back the formatted string with water balance summary (here given just for one year):</p> <pre><code>* Project:       pySWAP test - hupsel brook\n* File content:  detailed overview of water balance components (cm)\n* File name:     ./result.blc\n* Model version: Swap 4.2.0\n* Generated at:  2024-04-17 00:47:13\n\nPeriod             :  2002-01-01  until  2002-12-31\nDepth soil profile :  200.00 cm\n=================================================+=================================================\nINPUT                                            | OUTPUT\n                   PLANT    SNOW    POND    SOIL |                   PLANT    SNOW    POND    SOIL\n=================================================+=================================================\nInitially Present           0.00    0.00   71.60 | Finally present            0.00    0.00   76.02\nGross Rainfall     84.03                         |\nNett Rainfall               0.00   80.29         | Nett Rainfall     80.29\nGross Irrigation    0.50                         |\nNett Irrigation                     0.50         | Nett Irrigation    0.50\n                                                 | Interception       3.74\nSnowfall                    0.00                 |\nSnowmelt                            0.00         | Snowmelt                   0.00\n                                                 | Sublimation                0.00\nSSDI                                        0.00 | Plant Transpiration                        0.75\n                                                 | Soil Evaporation                   1.82\nRunon                               0.00         | Runoff                             0.00\nInundation                          0.00         |\nInfiltr. Soil Surf.                        80.46 | Infiltr. Soil Surf.               80.46\nExfiltr. Soil Surf.                 1.49         | Exfiltr. Soil Surf.                        1.49\nInfiltr. subsurf.                                | Drainage\n- system 1                                  0.00 | - system 1                                73.79\nUpward seepage                              0.00 | Downward seepage                           0.00\n=================================================+=================================================\nSum                84.53    0.00   82.28  152.05 | Sum               84.53    0.00   82.28  152.05\n=================================================+=================================================\nStorage Change              0.00    0.00    4.43\nBalance Deviation   0.00    0.00    0.00   -0.00\n===================================================================================================\n</code></pre>"},{"location":"user-guide/2-quick-start/#dependencies","title":"Dependencies","text":"<pre><code>pandas&gt;=2.2\nnumpy&gt;=1.26\npydantic&gt;=2.5\nknmi-py&gt;=0.1.0\njupyter\n</code></pre>"},{"location":"user-guide/4-subpackages/","title":"Subpackages","text":""},{"location":"user-guide/4-subpackages/#core_package","title":"Core package","text":"<p>This package contains modules &amp; classes dealing with the basic setup of the model.</p>"},{"location":"user-guide/4-subpackages/#simulation_settiings","title":"Simulation settiings","text":""},{"location":"user-guide/4-subpackages/#atmosphere_package","title":"Atmosphere package","text":""},{"location":"user-guide/4-subpackages/#crop_package","title":"Crop package","text":""},{"location":"user-guide/4-subpackages/#drainage_package","title":"Drainage package","text":""},{"location":"user-guide/4-subpackages/#irrigation_package","title":"Irrigation package","text":""},{"location":"user-guide/4-subpackages/#soil-water_package","title":"Soil-water package","text":""},{"location":"user-guide/CONTRIBUTING/","title":"CONTRIBUTING","text":"<p>This is how to contribute.</p>"},{"location":"user-guide/data-structures/","title":"Data structures","text":"<p>pySWAP heavily relies on pandas DataFrames, but also defines a number of its own data structures. Here is a summary of the data types and when to use them.</p>"},{"location":"user-guide/data-structures/#tables","title":"Tables","text":"<p>Generally pySWAP classes are validated before creation. Variable ranges and types are checked. The same goes for DataFrames, but their validation is a little bit less straighforward. Below you see a class representing the table of initial pressure head as a function of soil depth.</p> <pre><code>class INIPRESSUREHEAD(BaseModel):\n    \"\"\"Initial pressure head [cm, R] as a function of soil layer [1..N, I].\n\n    Attributes:\n        ZI: Series[int]: soil depth [-1.d5..0 cm, R].\n        H: Series[float]: Initial soil water pressure head [-1.d10..1.d4 cm, R].\n    \"\"\"\n\n    ZI: Series[int] = pa.Field(ge=-1.0e5, le=0.0)\n    H: Series[float] = pa.Field(ge=-1.0e10, le=1.0e4)\n</code></pre> <p>This is how you create the table:</p> <pre><code>from pyswap.irrigation import IRRIGATION\n\n\nirrigation_events = IRRIGATION.create({\n    'IRDATE': ['2017-04-01', '2017-05-01', '2017-06-01', '2017-07-01', '2017-08-01'],\n    'IRDEPTH': [0.0, 0.0, 0.0, 0.0, 0.0],\n    'IRCONC': [0.0, 0.0, 0.0, 0.0, 0.0],\n    'IRTYPE': [0, 0, 0, 0, 0],\n})\n</code></pre> <p><code>irrigation_events</code> variable now stores a validated pandas DataFrame. it means that pandera will check if all required columns are there and whether the column types are correct. In case, for example, string is passed for the datetime type, pandera will try to coerce the string to a datetime format. If that is not possible, an error is raised:</p> <pre><code>from pyswap.irrigation import IRRIGATION\n\n\nirrigation_events = IRRIGATION.create({\n    'IRDATE': ['2017-13-32', '2017-05-01', '2017-06-01', '2017-07-01', '2017-08-01'],\n    'IRDEPTH': [0.0, 0.0, 0.0, 0.0, 0.0],\n    'IRCONC': [0.0, 0.0, 0.0, 0.0, 0.0],\n    'IRTYPE': [0, 0, 0, 0, 0],\n})\n\n# output:\n# &gt;&gt;&gt;     SchemaError: Error while coercing 'IRDATE' to type datetime64[ns]: Could not coerce &lt;class 'pandas.core.series.Series'&gt; data_container into type datetime64[ns]:\n# &gt;&gt;&gt;     index failure_case\n# &gt;&gt;&gt; 0      0   2017-13-32\n</code></pre>"},{"location":"user-guide/using-hdf5-database/","title":"HDF5 database","text":"<p>This package would not be worth much if it did not contain any way of preserving generated models. For this purpose several technologies were considered. Primary concerns were:</p> <ul> <li>Wide-spread use</li> <li>Simple structure</li> <li>cross-platform</li> <li>programming-lanuage-agnostic</li> </ul> <p>Initiall, SQLite database was considered as a good option. That would indeed be true if there was a need for simple tabilar and related data. With SWAP, however, the inputs and outpus comming in various formats would pose a challage for SQLite and would require bending the best practices of RDBSM to make it fit. Why push a cilinder through a square hole?</p> <p>Another good option widely used in science is hdf5 file format. It accepts almost any format, is compatible with multiple languages (R, Python, Fortran) and has a fairly simple, folder-like structure. Hence in pySWAP we chose to build on top of the <code>h5py</code> library.</p> <p>The ultimate objective is that the hdf5 database is easily and directly sharable with modellers using different programming languages. However, for now, pySWAP is only capable of saving and retrieving Python-specific format: pickle.</p>"},{"location":"user-guide/using-hdf5-database/#modepython","title":"<code>mode='python'</code>","text":"<p>In the python mode, the data is stored in the hdf5 database as binary pickle objects. This is a very straightforward approach and allowes for storage of the entire models and its results as a single object. To demonstrate how this works, let's pickle and store the testcase from hupselbrook:</p> <pre><code>from pyswap import testcase\n\n# get the Model object and run it\nmodel = testcase.get('hupselbrook')\nresult = model.run('./')\n\n# now, let's create an inteface object and save the model and the result\nf = HDF5(filename='data.h5')\nf.save_model(model=model, result=result)\n</code></pre> <p>after running the above commands, you should see an .h5 file appearing in your working directory. You can inpect the database with VSCode plugins or check its content with:</p> <pre><code>print(f.model_list)\n#&gt; ['base']\n</code></pre> <p>by default, the first model ever run gets the <code>Model.version</code> attribute set to 'base'. For the subsequent models, you should change the version attribute.</p> <p>You can also load objects back from the database:</p> <pre><code>f.load('pySWAP test - hupsel brook', load_results=True)\n</code></pre> <p>The above line will load all models from a given project to the <code>f.models</code> attribute. If you only want one specific version, specify it through <code>model</code> parameter.</p> <pre><code>f.load('pySWAP test - hupsel brook', model='base', load_results=True)\n</code></pre>"},{"location":"wiki/standard-array-lengths/","title":"Standard array lengths","text":"<p>These settings are predefined in the SWAP code. The list of the parameters can be found in the Kroes et al. 2017 user manual, appendix 12.</p>"},{"location":"wiki/input-files/1-input-files/","title":"SWAP model input files","text":"<p>Even though all the template provided by the model development team are comprehensive, there is still quite a lot missing. The templates provided here come from the R package distributed with the software from the main webpage of the model (alterra website)</p>"},{"location":"wiki/input-files/2-swp-file/","title":".SWP","text":"<p>.swp file is the main configuration file for the SWAP model. It contains all the settings for the simulation and indicates which additional files should be created. In pySWAP, this file is represented by the main class <code>Model</code>. Upon calling <code>Model.run('./')</code> method on a model object, a .swp file is created in a temporary directory along with all other input files. So you do not even see the file anymore.</p> SWAP.template <pre><code>**********************************************************************************\n* Filename: swap.swp\n* Contents: SWAP 4 - Main input data\n**********************************************************************************\n* Comment area:\n* Testbank of SWAP: build with template of swp-file\n*\n**********************************************************************************\n\n*   The main input file .swp contains the following sections:\n*           - General section\n*           - Meteorology section\n*           - Crop section\n*           - Soil water section\n*           - Lateral drainage section\n*           - Bottom boundary section\n*           - Heat flow section\n*           - Solute transport section\n\n**********************************************************************************\n\n*** GENERAL SECTION ***\n\n**********************************************************************************\n* Part 1: Environment\n\n  PROJECT   = {{PROJECT}}    ! Project description [A80]\n  PATHWORK  = '.\\'           ! Path to work folder [A80]\n  PATHATM   = {{PATHATM}}    ! Path to folder with weather files [A80]\n  PATHCROP  = {{PATHCROP}}   ! Path to folder with crop files [A80]\n  PATHDRAIN = '.\\'           ! Path to folder with drainage files [A80]\n\n* Switch, display progression of simulation run to screen:  \n  SWSCRE    = 0              ! 0 = no display to screen\n                             ! 1 = display water balance components\n                             ! 2 = display daynumber\n\n* Switch for printing errors to screen:\n  SWERROR   = 0              ! 0 = no display to screen\n                             ! 1 = display error to screen\n\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 2: Simulation period\n\n  TSTART  = {{TSTART}}       ! Start date of simulation run, give day-month-year [date]\n  TEND    = {{TEND}}         ! End date of simulation run, give day-month-year [date]\n\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 3: Output dates \n\n* Number of output times during a day\n  NPRINTDAY = {{NPRINTDAY}}  ! Number of output times during a day [1..1440, I]\n\n* Specify dates for output of state variables and fluxes\n  SWMONTH = {{SWMONTH}}      ! Switch, output each month [Y=1, N=0]\n\n{{#SWITCH_SWMONTH_OPTION_0}}\n* If SWMONTH = 0, choose output interval and/or specific dates\n  PERIOD = {{PERIOD}}        ! Fixed output interval, ignore = 0 [0..366, I]\n  SWRES  = {{SWRES}}         ! Switch, reset output interval counter each year [Y=1, N=0]\n  SWODAT = {{SWODAT}}        ! Switch, extra output dates are given in table below [Y=1, N=0]\n\n{{#SWITCH_SWODAT_OPTION_1}}\n* If SWODAT = 1, list specific dates [date], maximum MAOUT dates:\n  OUTDATINT =\n  2002-01-31\n  2004-12-31\n* End of table\n\n{{/SWITCH_SWODAT_OPTION_1}}\n{{/SWITCH_SWMONTH_OPTION_0}}\n* Output times for overall water and solute balances in *.BAL and *.BLC file: choose output\n* at a fixed date each year or at different dates:\n  SWYRVAR = {{SWYRVAR}}      ! 0 = each year output at the same date\n                             ! 1 = output at different dates\n\n{{#SWITCH_SWYRVAR_OPTION_0}}\n* If SWYRVAR = 0 specify fixed date:\n  DATEFIX = 31 12            ! Specify day and month for output of yearly balances [dd mm]\n\n{{/SWITCH_SWYRVAR_OPTION_0}}\n{{#SWITCH_SWYRVAR_OPTION_1}}  \n* If SWYRVAR = 1 specify all output dates [date], maximum MAOUT dates:\n  OUTDAT =\n  2003-12-31\n  2004-12-31\n* End of table\n\n{{/SWITCH_SWYRVAR_OPTION_1}}\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 4: Output files\n\n* General information\n  OUTFIL   = {{OUTFIL}}      ! Generic file name of output files, [A16]\n  SWHEADER = 0               ! Print header at the start of each balance period [Y=1, N=0]\n\n* Optional files\n  SWWBA  = 0                 ! Switch, output daily water balance [Y=1, N=0]\n  SWEND  = 0                 ! Switch, output end-conditions [Y=1, N=0]\n  SWVAP  = 0                 ! Switch, output soil profiles of moisture, solute and temperature [Y=1, N=0]\n  SWBAL  = 0                 ! Switch, output file with yearly water balance [Y=1, N=0]\n  SWBLC  = 0                 ! Switch, output file with detailed yearly water balance [Y=1, N=0]\n  SWSBA  = 0                 ! Switch, output file of daily solute balance [Y=1, N=0]\n  SWATE  = 0                 ! Switch, output file with soil temperature profiles [Y=1, N=0]\n  SWBMA  = 0                 ! Switch, output file with water fluxes, only for macropore flow [Y=1, N=0]\n  SWDRF  = 0                 ! Switch, output of drainage fluxes, only for extended drainage [Y=1, N=0]\n  SWSWB  = 0                 ! Switch, output surface water reservoir, only for extended drainage [Y=1, N=0]\n  SWINI  = 0                 ! Switch, output of initial SoilPhysParam and HeatParam [Y=1, N=0]  \n  SWINC  = 0                 ! Switch, output of water balance increments [Y=1, N=0]\n  SWCRP  = 0                 ! Switch, output of simple or detailed crop growth model [Y=1, N=0]\n  SWSTR  = 0                 ! Switch, output of stress values for wetness, drought, salinity and frost [Y=1, N=0]\n  SWIRG  = 0                 ! Switch, output of irrigation gifts [Y=1, N=0]\n\n* Specific CSV output file? (default: no)\n  SWCSV  = {{SWCSV}}         ! Switch, output of variables to be specified [Y=1, N=0]\n\n{{#SWITCH_SWCSV_OPTION_1}}  \n  INLIST_CSV = {{INLIST_CSV}}\n\n{{/SWITCH_SWCSV_OPTION_1}}  \n* Specific CSV output file? (default: no)\n  SWCSV_TZ  = {{SWCSV_TZ}}   ! Switch, output of variables to be specified [Y=1, N=0]\n\n{{#SWITCH_SWCSV_TZ_OPTION_1}}  \n  INLIST_CSV_TZ = {{INLIST_CSV_TZ}}\n\n{{/SWITCH_SWCSV_TZ_OPTION_1}}\n* Optional output files for water quality models or other specific use\n\n* Switch, output file with formatted hydrological data:\n  SWAFO  = {{SWAFO}}         ! 0 = no output\n                             ! 1 = output to a file named *.AFO\n                             ! 2 = output to a file named *.BFO\n\n* Switch, output file with unformatted hydrological data:\n  SWAUN  = {{SWAUN}}         ! 0 = no output\n                             ! 1 = output to a file named *.AUN\n                             ! 2 = output to a file named *.BUN\n\n{{#SWITCH_SWAFO_OPTION_1}}\n* if SWAFO = 1 or 2 or if SWAUN = 1 or 2 then specify CRITDEVMASBAL and SWDISCRVERT\n* Maximum deviation in water balance; in case of larger deviation, an error file is created (*.DWB.CSV)\n  CRITDEVMASBAL = {{CRITDEVMASBAL}} ! Critical Deviation in water balance during PERIOD [0.0..1.0 cm, R]\n\n* Switch to convert vertical discretization\n  SWDISCRVERT = {{SWDISCRVERT}} ! 0: no conversion\n                             ! 1: convert vertical discretization\n\n{{#SWITCH_SWDISCRVERT_OPTION_1}}\n* Only If SWDISCRVERT = 1 then NUMNODNEW and DZNEW are required\n  NUMNODNEW = 22             ! New number of nodes [1...macp,I,-]\n*                            ! (boundaries of soil layers may not change, which implies   \n*                            !  that the sum of thicknesses within a soil layer must be \n*                            !  equal to the thickness of the soil layer.\n*                            !  See also: SoilWaterSection, Part4: Vertical discretization of soil profile)\n\n* Thickness of compartments [1.0d-6...5.0d2, cm, R] \n DZNEW = \n   5.0   5.0   5.0   5.0   5.0   5.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0  20.0  20.0  20.0  20.0  20.0  20.0  40.0  40.0  40.0\n\n{{/SWITCH_SWDISCRVERT_OPTION_1}}\n{{/SWITCH_SWAFO_OPTION_1}}\n{{#SWITCH_SWAFO_OPTION_2}}\n* if SWAFO = 1 or 2 or if SWAUN = 1 or 2 then specify CRITDEVMASBAL and SWDISCRVERT\n* Maximum deviation in water balance; in case of larger deviation, an error file is created (*.DWB.CSV)\n  CRITDEVMASBAL = {{CRITDEVMASBAL}} ! Critical Deviation in water balance during PERIOD [0.0..1.0 cm, R]\n\n* Switch to convert vertical discretization\n  SWDISCRVERT = {{SWDISCRVERT}} ! 0: no conversion\n                             ! 1: convert vertical discretization\n\n{{#SWITCH_SWDISCRVERT_OPTION_1}}\n* Only If SWDISCRVERT = 1 then NUMNODNEW and DZNEW are required\n  NUMNODNEW = 22             ! New number of nodes [1...macp,I,-]\n*                            ! (boundaries of soil layers may not change, which implies   \n*                            !  that the sum of thicknesses within a soil layer must be \n*                            !  equal to the thickness of the soil layer.\n*                            !  See also: SoilWaterSection, Part4: Vertical discretization of soil profile)\n\n* Thickness of compartments [1.0d-6...5.0d2, cm, R] \n DZNEW = \n   5.0   5.0   5.0   5.0   5.0   5.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0  20.0  20.0  20.0  20.0  20.0  20.0  40.0  40.0  40.0\n\n{{/SWITCH_SWDISCRVERT_OPTION_1}}\n{{/SWITCH_SWAFO_OPTION_2}}\n{{#SWITCH_SWAUN_OPTION_1}}\n* if SWAFO = 1 or 2 or if SWAUN = 1 or 2 then specify CRITDEVMASBAL and SWDISCRVERT\n* Maximum deviation in water balance; in case of larger deviation, an error file is created (*.DWB.CSV)\n  CRITDEVMASBAL = {{CRITDEVMASBAL}} ! Critical Deviation in water balance during PERIOD [0.0..1.0 cm, R]\n\n* Switch to convert vertical discretization\n  SWDISCRVERT = {{SWDISCRVERT}} ! 0: no conversion\n                             ! 1: convert vertical discretization\n\n{{#SWITCH_SWDISCRVERT_OPTION_1}}\n* Only If SWDISCRVERT = 1 then NUMNODNEW and DZNEW are required\n  NUMNODNEW = 22             ! New number of nodes [1...macp,I,-]\n*                            ! (boundaries of soil layers may not change, which implies   \n*                            !  that the sum of thicknesses within a soil layer must be \n*                            !  equal to the thickness of the soil layer.\n*                            !  See also: SoilWaterSection, Part4: Vertical discretization of soil profile)\n\n* Thickness of compartments [1.0d-6...5.0d2, cm, R] \n DZNEW = \n   5.0   5.0   5.0   5.0   5.0   5.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0  20.0  20.0  20.0  20.0  20.0  20.0  40.0  40.0  40.0\n\n{{/SWITCH_SWDISCRVERT_OPTION_1}}\n{{/SWITCH_SWAUN_OPTION_1}}\n{{#SWITCH_SWAUN_OPTION_2}}\n* if SWAFO = 1 or 2 or if SWAUN = 1 or 2 then specify CRITDEVMASBAL and SWDISCRVERT\n* Maximum deviation in water balance; in case of larger deviation, an error file is created (*.DWB.CSV)\n  CRITDEVMASBAL = {{CRITDEVMASBAL}} ! Critical Deviation in water balance during PERIOD [0.0..1.0 cm, R]\n\n* Switch to convert vertical discretization\n  SWDISCRVERT = {{SWDISCRVERT}} ! 0: no conversion\n                             ! 1: convert vertical discretization\n\n{{#SWITCH_SWDISCRVERT_OPTION_1}}\n* Only If SWDISCRVERT = 1 then NUMNODNEW and DZNEW are required\n  NUMNODNEW = 22             ! New number of nodes [1...macp,I,-]\n*                            ! (boundaries of soil layers may not change, which implies   \n*                            !  that the sum of thicknesses within a soil layer must be \n*                            !  equal to the thickness of the soil layer.\n*                            !  See also: SoilWaterSection, Part4: Vertical discretization of soil profile)\n\n* Thickness of compartments [1.0d-6...5.0d2, cm, R] \n DZNEW = \n   5.0   5.0   5.0   5.0   5.0   5.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0  20.0  20.0  20.0  20.0  20.0  20.0  40.0  40.0  40.0\n\n{{/SWITCH_SWDISCRVERT_OPTION_1}}\n{{/SWITCH_SWAUN_OPTION_2}}\n**********************************************************************************\n\n\n**********************************************************************************\n\n*** METEOROLOGY SECTION ***\n\n**********************************************************************************\n* General data\n\n* File name\n  METFIL = {{METFIL}}        ! File name of meteorological data without extension .YYY, [A200]\n                             ! Extension is equal to last 3 digits of year, e.g. 003 denotes year 2003\n\n* Details of meteo station:\n  LAT = {{LAT}}              ! Latitude of meteo station [-90..90 degrees, R, North = +]\n\n* Type of weather data for potential evapotranspiration\n  SWETR = {{SWETR}}          ! 0 = Use basic weather data and apply Penman-Monteith equation\n                             ! 1 = Use reference evapotranspiration data in combination with crop factors\n\n{{#SWITCH_SWETR_OPTION_0}}\n* In case of Penman-Monteith (SWETR = 0), specify:\n  ALT       = {{ALT}}        ! Altitude of meteo station [-400..3000 m, R]\n  ALTW      = {{ALTW}}       ! Height of wind speed measurement above soil surface (10 m is default) [0..99 m, R]\n  ANGSTROMA = {{ANGSTROMA}}  ! Fraction of extraterrestrial radiation reaching the earth on overcast days [0..1 -, R]\n  ANGSTROMB = {{ANGSTROMB}}  ! Additional fraction of extraterrestrial radiation reaching the earth on clear days [0..1 -, R]\n\n* Switch for distribution of E and T:\n  SWDIVIDE  = {{SWDIVIDE}}   ! 0 = Based on crop and soil factors\n                             ! 1 = Based on direct application of Penman-Monteith\n\n* In case of SWETR = 0, specify time interval of evapotranspiration and rainfall weather data\n  SWMETDETAIL = {{SWMETDETAIL}} ! 0 = time interval is equal to one day\n                             ! 1 = time interval is less than one day\n\n{{#SWITCH_SWMETDETAIL_OPTION_0}}\n* In case of daily meteorological weather records (SWMETDETAIL = 0):\n  SWETSINE = {{SWETSINE}}    ! Switch, distribute daily Tp and Ep according to sinus wave [Y=1, N=0]\n\n* Switch for use of actual rainfall intensity (only if SWMETDETAIL = 0):\n  SWRAIN = {{SWRAIN}}        ! 0 = Use daily rainfall amounts\n                             ! 1 = Use daily rainfall amounts + mean intensity\n                             ! 2 = Use daily rainfall amounts + duration\n                             ! 3 = Use detailed rainfall records (dt &lt; 1 day), as supplied in separate file\n\n{{#SWITCH_SWRAIN_OPTION_1}}\n* If SWRAIN = 1, then specify mean rainfall intensity RAINFLUX [0.d0..1000.d0 mm/d, R]\n* as function of time TIME [0..366 d, R], maximum 30 records\n\n{{#TABLE_RAINFLUXTB}}\n  {{TIME}} {{RAINFLUX}}\n{{/TABLE_RAINFLUXTB}}\n* End of table\n{{/SWITCH_SWRAIN_OPTION_1}}\n{{#SWITCH_SWRAIN_OPTION_3}}\n* If SWRAIN = 3, then specify file name of file with detailed rainfall data\n  RAINFIL = {{RAINFIL}}      ! File name of detailed rainfall data without extension .YYY, [A200]\n                             ! Extension is equal to last 3 digits of year, e.g. 003 denotes year 2003\n{{/SWITCH_SWRAIN_OPTION_3}}\n{{/SWITCH_SWMETDETAIL_OPTION_0}}                                \n{{#SWITCH_SWMETDETAIL_OPTION_1}}\n* In case of detailed meteorological weather records (SWMETDETAIL = 1), specify:\n  NMETDETAIL = 24            ! Number of weather data records each day [1..96 -, I]\n{{/SWITCH_SWMETDETAIL_OPTION_1}}\n{{/SWITCH_SWETR_OPTION_0}}\n{{#SWITCH_SWETR_OPTION_1}}\n* In case of daily meteorological weather records (only if SWETR = 1):\n  SWETSINE = {{SWETSINE}}    ! Switch, distribute daily Tp and Ep according to sinus wave [Y=1, N=0]\n\n* Switch for use of actual rainfall intensity (only if SWETR = 1):\n  SWRAIN = {{SWRAIN}}        ! 0 = Use daily rainfall amounts\n                             ! 1 = Use daily rainfall amounts + mean intensity\n                             ! 2 = Use daily rainfall amounts + duration\n                             ! 3 = Use detailed rainfall records (dt &lt; 1 day), as supplied in separate file\n\n{{#SWITCH_SWRAIN_OPTION_1}}\n* If SWRAIN = 1, then specify mean rainfall intensity RAINFLUX [0.d0..1000.d0 mm/d, R]\n* as function of time TIME [0..366 d, R], maximum 30 records\n\n{{#TABLE_RAINFLUXTB}}\n  {{TIME}} {{RAINFLUX}}\n{{/TABLE_RAINFLUXTB}}\n* End of table\n{{/SWITCH_SWRAIN_OPTION_1}}\n{{#SWITCH_SWRAIN_OPTION_3}}\n* If SWRAIN = 3, then specify file name of file with detailed rainfall data\n  RAINFIL = {{RAINFIL}}      ! File name of detailed rainfall data without extension .YYY, [A200]\n                             ! Extension is equal to last 3 digits of year, e.g. 003 denotes year 2003\n{{/SWITCH_SWRAIN_OPTION_3}}\n{{/SWITCH_SWETR_OPTION_1}}\n\n**********************************************************************************\n\n\n**********************************************************************************\n\n*** CROP SECTION ***\n\n**********************************************************************************\n* Part 1: Crop rotation scheme\n\n* Switch for bare soil or cultivated soil:  \n  SWCROP = {{SWCROP}}        ! 0 = Bare soil\n                             ! 1 = Cultivated soil\n\n{{#SWITCH_SWCROP_OPTION_1}}\n* Specify for each crop (maximum MACROP):\n* CROPSTART  = date of crop emergence [date]\n* CROPEND    = date of crop harvest [date]\n* CROPFIL    = name of file with crop input parameters without extension .CRP, [A40]\n* CROPTYPE   = growth module: 1 = simple; 2 = detailed, WOFOST general; 3 = detailed, WOFOST grass\n\n{{#TABLE_CROPROTATION}}\n  {{CROPSTART}} {{CROPEND}} {{CROPFIL}} {{CROPTYPE}}\n{{/TABLE_CROPROTATION}}\n* End of table\n\n  RDS  = {{RDS}}             ! Maximum rooting depth allowed by the soil profile, [1..5000 cm, R]\n\n{{/SWITCH_SWCROP_OPTION_1}}\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 2: Fixed irrigation applications\n\n* Switch for fixed irrigation applications\n  SWIRFIX = {{SWIRFIX}}      ! 0 = no irrigation applications are prescribed\n                             ! 1 = irrigation applications are prescribed\n\n{{#SWITCH_SWIRFIX_OPTION_1}}\n* If SWIRFIX = 1, specify:\n* Switch for separate file with fixed irrigation applications\n  SWIRGFIL  = {{SWIRGFIL}}   ! 0 = data are specified in the .swp file\n                             ! 1 = data are specified in a separate file\n\n{{#SWITCH_SWIRGFIL_OPTION_0}}\n* If SWIRGFIL  = 0 specify information for each fixed irrigation event (max. MAIRG):\n* IRDATE   = date of irrigation [date]\n* IRDEPTH  = amount of water [0..1000 mm, R]\n{{#SWITCH_SWSOLU_OPTION_1}}\n* IRCONC   = concentration of irrigation water [0..1000 mg/cm3, R]\n{{/SWITCH_SWSOLU_OPTION_1}}\n* IRTYPE   = type of irrigation: sprinkling = 0, surface = 1\n\n{{#SWITCH_SWSOLU_OPTION_0}}\n{{#TABLE_IRRIGATIONFIXED}}\n  {{IRDATE}} {{IRDEPTH}} {{IRTYPE}}\n{{/TABLE_IRRIGATIONFIXED}}\n{{/SWITCH_SWSOLU_OPTION_0}}\n{{#SWITCH_SWSOLU_OPTION_1}}\n{{#TABLE_IRRIGATIONFIXED}}\n  {{IRDATE}} {{IRDEPTH}} {{IRCONC}} {{IRTYPE}}\n{{/TABLE_IRRIGATIONFIXED}}\n{{/SWITCH_SWSOLU_OPTION_1}}\n* End of table\n{{/SWITCH_SWIRGFIL_OPTION_0}}\n{{#SWITCH_SWIRGFIL_OPTION_1}}\n* If SWIRGFIL  = 1, specify name of file with irrigation data:\n  IRGFIL = {{IRGFIL}}        ! File name with irrigation input data without extension .IRG [A32]\n{{/SWITCH_SWIRGFIL_OPTION_1}}\n{{/SWITCH_SWIRFIX_OPTION_1}}\n\n**********************************************************************************\n\n\n**********************************************************************************\n\n*** SOIL WATER SECTION ***\n\n**********************************************************************************\n* Part 1: Initial soil moisture condition\n\n* Switch, type of initial soil moisture condition:\n  SWINCO = {{SWINCO}}        ! 1 = pressure head as function of soil depth\n                             ! 2 = pressure head of each compartment is in hydrostatic equilibrium with initial groundwater level\n                             ! 3 = read final pressure heads from output file of previous Swap simulation\n\n{{#SWITCH_SWINCO_OPTION_1}}\n* If SWINCO = 1, specify soil depth ZI [-1.d5..0 cm, R] and initial\n* soil water pressure head H [-1.d10..1.d4 cm, R] (maximum MACP):\n\n{{#TABLE_INIPRESSUREHEAD}}\n  {{ZI}} {{H}}\n{{/TABLE_INIPRESSUREHEAD}}\n* End of table\n{{/SWITCH_SWINCO_OPTION_1}}\n{{#SWITCH_SWINCO_OPTION_2}}\n* If SWINCO = 2, specify initial groundwater level:\n  GWLI   = {{GWLI}}          ! Initial groundwater level, [-10000..100 cm, R]\n{{/SWITCH_SWINCO_OPTION_2}}\n{{#SWITCH_SWINCO_OPTION_3}}\n* If SWINCO = 3, specify output file with initial values for current run:\n  INIFIL = {{INIFIL}}        ! name of output file *.END which contains initial values [A200]\n{{/SWITCH_SWINCO_OPTION_3}}\n\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 2: Ponding, runoff and runon\n\n* Ponding\n* Switch for variation ponding threshold for runoff\n  SWPONDMX = {{SWPONDMX}}    ! 0 = Ponding threshold for runoff is constant\n                             ! 1 = Ponding threshold for runoff varies in time\n\n{{#SWITCH_SWPONDMX_OPTION_0}}\n* If SWPONDMX = 0, specify\n  PONDMX  = {{PONDMX}}       ! In case of ponding, minimum thickness for runoff [0..1000 cm, R]\n{{/SWITCH_SWPONDMX_OPTION_0}}\n{{#SWITCH_SWPONDMX_OPTION_1}}\n* If SWPONDMX = 1, specify minimum thickness for runoff PONDMXTB [0..1000 cm, R] as function of time\n\n{{#TABLE_MXPONDTB}}\n  {{DATEPMX}} {{PONDMXTB}}\n{{/TABLE_MXPONDTB}}\n* End of table\n{{/SWITCH_SWPONDMX_OPTION_1}}\n\n* Runoff\n  RSRO    = {{RSRO}}         ! Drainage resistance for surface runoff [0.001..1.0 d, R]\n  RSROEXP = {{RSROEXP}}      ! Exponent in drainage equation of surface runoff [0.01..10.0 -, R]\n\n* Runon\n  SWRUNON = {{SWRUNON}}      ! Switch, use of runon data [Y=1, N=0]\n\n{{#SWITCH_SWRUNON_OPTION_1}}\n* If SWRUNON = 1, specify name of file with runon input data\n* This file may be an output file *.inc (with only 1 header line) of a previous Swap-simulation\n  RUFIL = 'swap.inc'         ! File name with extension [A80]\n\n{{/SWITCH_SWRUNON_OPTION_1}}\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 3: Soil evaporation\n\n  CFEVAPPOND = 1.25          ! When ETref is used, evaporation coefficient in case of ponding  [0..3 -, R]\n\n* Switch for use of soil factor CFBS to calculate Epot from ETref:\n  SWCFBS = {{SWCFBS}}        ! 0 = soil factor is not used\n                             ! 1 = soil factor is used\n\n{{#SWITCH_SWCFBS_OPTION_1}}\n* If SWCFBS = 1, specify coefficient CFBS:\n  CFBS = {{CFBS}}            ! Coefficient for potential soil evaporation, [0.5..1.5 -, R]\n\n{{/SWITCH_SWCFBS_OPTION_1}}\n{{#SWITCH_SWETR_OPTION_0}}\n{{#SWITCH_SWDIVIDE_OPTION_1}}\n* If SWDIVIDE = 1 (partitoning according to PMdirect) specify minimum soil resistance\n  RSOIL  =  {{RSOIL}}        ! Soil resistance of wet soil [0..1000.0 s/m, R]\n\n{{/SWITCH_SWDIVIDE_OPTION_1}}\n{{/SWITCH_SWETR_OPTION_0}}\n* Switch, method for reduction of potential soil evaporation:\n  SWREDU = {{SWREDU}}        ! 0 = reduction to maximum Darcy flux\n                             ! 1 = reduction to maximum Darcy flux and to maximum Black (1969)\n                             ! 2 = reduction to maximum Darcy flux and to maximum Boesten/Stroosnijder (1986)\n\n{{#SWITCH_SWREDU_OPTION_1}}\n* If SWREDU = 1, specify:\n COFREDBL = {{COFREDBL}}     ! Soil evaporation coefficient of Black [0..1 cm/d1/2, R]\n RSIGNI = {{RSIGNI}}         ! Minimum rainfall to reset method of Black [0..1 cm/d, R]\n\n{{/SWITCH_SWREDU_OPTION_1}}\n{{#SWITCH_SWREDU_OPTION_2}}\n* If SWREDU = 2, specify:\n COFREDBO = {{COFREDBO}}     ! Soil evaporation coefficient of Boesten/Stroosnijder [0..1 cm1/2, R]\n\n{{/SWITCH_SWREDU_OPTION_2}}\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 4: Vertical discretization of soil profile\n\n* Specify the following data (maximum MACP lines):\n* ISUBLAY  = number of sub layer, start with 1 at soil surface [1..MACP, I]\n* ISOILLAY = number of soil physical layer, start with 1 at soil surface [1..MAHO, I]\n* HSUBLAY  = height of sub layer [0..1.d4 cm, R]\n* HCOMP    = height of compartments in the sub layer [0.0..1000.0 cm, R]\n* NCOMP    = number of compartments in the sub layer (Mind NCOMP = HSUBLAY/HCOMP) [1..MACP, I]\n\n{{#TABLE_SOILPROFILE}}\n  {{ISUBLAY}} {{ISOILLAY}} {{HSUBLAY}} {{HCOMP}} {{NCOMP}}\n{{/TABLE_SOILPROFILE}}\n* End of table\n\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 5: Soil hydraulic functions\n\n* Switch for analytical functions or tabular input:\n  SWSOPHY = {{SWSOPHY}}      ! 0 = Analytical functions with input of Mualem - van Genuchten parameters\n                             ! 1 = Soil physical tables\n\n{{#SWITCH_SWSOPHY_OPTION_0}}\n* If SWSOPHY = 0, specify MvG parameters for each soil physical layer (maximum MAHO):\n* ORES    = Residual water content [0..1 cm3/cm3, R]\n* OSAT    = Saturated water content [0..1 cm3/cm3, R]\n* ALFA    = Parameter alfa of main drying curve [0.0001..100 /cm, R]\n* NPAR    = Parameter n [1.001..9 -, R]\n* KSATFIT = Fitting parameter Ksat of hydraulic conductivity function [1.d-5..1d5 cm/d, R]\n* LEXP    = Exponent in hydraulic conductivity function [-25..25 -, R]\n{{#SWITCH_SWHYST_OPTION_1}}\n* ALFAW   = Alfa parameter of main wetting curve in case of hysteresis [0.0001..100 /cm, R]\n{{/SWITCH_SWHYST_OPTION_1}}\n{{#SWITCH_SWHYST_OPTION_2}}\n* ALFAW   = Alfa parameter of main wetting curve in case of hysteresis [0.0001..100 /cm, R]\n{{/SWITCH_SWHYST_OPTION_2}}\n* H_ENPR  = Air entry pressure head [-40.0..0.0 cm, R]\n* KSATEXM = Measured hydraulic conductivity at saturated conditions [1.d-5..1d5 cm/d, R]\n* BDENS   = Dry soil bulk density [100..1d4 mg/cm3, R]\n\n{{#SWITCH_SWHYST_OPTION_0}}\n{{#TABLE_SOILHYDRFUNC}}\n  {{ORES}} {{OSAT}} {{ALFA}} {{NPAR}} {{KSATFIT}} {{LEXP}} {{H_ENPR}} {{KSATEXM}} {{BDENS}}\n{{/TABLE_SOILHYDRFUNC}}\n{{/SWITCH_SWHYST_OPTION_0}}\n{{#SWITCH_SWHYST_OPTION_1}}\n{{#TABLE_SOILHYDRFUNC}}\n  {{ORES}} {{OSAT}} {{ALFA}} {{NPAR}} {{KSATFIT}} {{LEXP}} {{ALFAW}} {{H_ENPR}} {{KSATEXM}} {{BDENS}}\n{{/TABLE_SOILHYDRFUNC}}\n{{/SWITCH_SWHYST_OPTION_1}}\n{{#SWITCH_SWHYST_OPTION_2}}\n{{#TABLE_SOILHYDRFUNC}}\n  {{ORES}} {{OSAT}} {{ALFA}} {{NPAR}} {{KSATFIT}} {{LEXP}} {{ALFAW}} {{H_ENPR}} {{KSATEXM}} {{BDENS}}\n{{/TABLE_SOILHYDRFUNC}}\n{{/SWITCH_SWHYST_OPTION_2}}\n* End of table\n{{/SWITCH_SWSOPHY_OPTION_0}}\n{{#SWITCH_SWSOPHY_OPTION_1}}\n* If SWSOPHY = 1, specify names of input files [A80] with soil hydraulic tables for each soil layer:\n  FILENAMESOPHY = {{FILENAMESOPHY}}\n{{/SWITCH_SWSOPHY_OPTION_1}}\n\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 6: Hysteresis of soil water retention function\n\n* Switch for hysteresis:\n  SWHYST = {{SWHYST}}        ! 0 = no hysteresis\n                             ! 1 = hysteresis, initial condition wetting\n                             ! 2 = hysteresis, initial condition drying\n\n{{#SWITCH_SWHYST_OPTION_1}}\n* If SWHYST = 1 or 2, specify:                                      \n  TAU = {{TAU}}              ! Minimum pressure head difference to change wetting-drying, [0..1 cm, R]\n\n{{/SWITCH_SWHYST_OPTION_1}}\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 7: Preferential flow due to macropores\n\n* Switch for macropore flow [0..2, I]:\n  SWMACRO = 0                ! 0 = no macropore flow\n                             ! 1 = macropore flow\n\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 8: Snow and frost\n\n* Switch, calculate snow accumulation and melt:\n  SWSNOW = {{SWSNOW}}        ! 0 = no simulation of snow\n                             ! 1 = simulation of snow accumulation and melt\n\n{{#SWITCH_SWSNOW_OPTION_1}}\n* If SWSNOW = 1, specify:\n  SNOWINCO = {{SNOWINCO}}    ! Initial snow water equivalent [0..1000 cm, R] \n  TEPRRAIN = {{TEPRRAIN}}    ! Temperature above which all precipitation is rain[ 0..10 oC, R]\n  TEPRSNOW = {{TEPRSNOW}}    ! Temperature below which all precipitation is snow[-10..0 oC, R]\n  SNOWCOEF = {{SNOWCOEF}}    ! Snowmelt calibration factor [0...10 -, R]\n\n{{/SWITCH_SWSNOW_OPTION_1}}\n* Switch, in case of frost reduce soil water flow:\n  SWFROST = {{SWFROST}}      ! 0 = no simulation of frost\n                             ! 1 = simulation of frost reduce soil water flow\n\n{{#SWITCH_SWFROST_OPTION_1}}\n* If SWFROST = 1, then specify soil temperature to start end end flux-reduction\n  TFROSTSTA = {{TFROSTSTA}}  ! Soil temperature (oC) where reduction of water fluxes starts [-10.0,5.0, oC, R]\n  TFROSTEND = {{TFROSTEND}}  ! Soil temperature (oC) where reduction of water fluxes ends [-10.0,5.0, oC, R]\n\n{{/SWITCH_SWFROST_OPTION_1}}\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 9: Numerical solution of Richards' equation for soil water flow\n\n  DTMIN         = {{DTMIN}}  ! Minimum timestep [1.d-7..0.1 d, R]\n  DTMAX         = {{DTMAX}}  ! Maximum timestep [dtmin..1 d, R]\n  GWLCONV       = {{GWLCONV}} ! Maximum difference of groundwater level between time steps [1.d-5..1000 cm, R]\n  CRITDEVH1CP   = {{CRITDEVH1CP}} ! Maximum relative difference in pressure heads per compartment [1.0d-10..1.d3 -, R]\n  CRITDEVH2CP   = {{CRITDEVH2CP}} ! Maximum absolute difference in pressure heads per compartment [1.0d-10..1.d3 cm, R]\n  CRITDEVPONDDT = {{CRITDEVPONDDT}} ! Maximum water balance error of ponding layer [1.0d-6..0.1 cm, R]\n  MAXIT         = {{MAXIT}}  ! Maximum number of iteration cycles [5..100 -, I]\n  MAXBACKTR     = {{MAXBACKTR}} ! Maximum number of back track cycles within an iteration cycle [1..10 -,I]\n\n* Switch for averaging method of hydraulic conductivity [1..4 -, I]:\n  SWKMEAN = {{SWKMEAN}}      ! 1 = unweighted arithmic mean\n                             ! 2 = weighted arithmic mean\n                             ! 3 = unweighted geometric mean\n                             ! 4 = weighted geometric mean\n                             ! 5 = unweighted harmonic mean\n                             ! 6 = weighted harmonic mean\n\n* Switch for updating hydraulic conductivity during iteration [0..1 -, I]:\n  SWKIMPL = {{SWKIMPL}}      ! 0 = no update\n                             ! 1 = update\n\n**********************************************************************************\n\n\n**********************************************************************************\n\n*** LATERAL DRAINAGE SECTION ***\n\n**********************************************************************************\n* Specify whether lateral drainage to surface water should be included\n\n* Switch, simulation of lateral drainage:\n  SWDRA = {{SWDRA}}          ! 0 = no simulation of drainage\n                             ! 1 = simulation with basic drainage routine\n                             ! 2 = simulation of drainage with surface water management\n\n{{#SWITCH_SWDRA_OPTION_1}}\n* If SWDRA = 1 specify name of file with drainage input data:\n  DRFIL = {{DRFIL}}          ! File name with drainage input data without extension .DRA [A16]\n{{/SWITCH_SWDRA_OPTION_1}}\n{{#SWITCH_SWDRA_OPTION_2}}\n* If SWDRA = 2 specify name of file with drainage input data:\n  DRFIL = {{DRFIL}}          ! File name with drainage input data without extension .DRA [A16]\n{{/SWITCH_SWDRA_OPTION_2}}\n\n**********************************************************************************\n\n\n**********************************************************************************\n\n*** BOTTOM BOUNDARY SECTION ***\n\n**********************************************************************************\n* Bottom boundary condition\n\n* Switch for file with bottom boundary data:\n  SWBBCFILE  = {{SWBBCFILE}} ! 0 = data are specified in current file\n                             ! 1 = data are specified in a separate file\n\n{{#SWITCH_SWBBCFILE_OPTION_0}}\n* Select one of the following options:\n  SWBOTB = {{SWBOTB}}        ! 1  Prescribe groundwater level\n                             ! 2  Prescribe bottom flux\n                             ! 3  Calculate bottom flux from hydraulic head of deep aquifer\n                             ! 4  Calculate bottom flux as function of groundwater level\n                             ! 5  Prescribe soil water pressure head of bottom compartment\n                             ! 6  Bottom flux equals zero\n                             ! 7  Free drainage of soil profile\n                             ! 8  Free outflow at soil-air interface\n\n* Options 1-5 require additional bottom boundary data below\n\n**********************************************************************************\n\n\n**********************************************************************************\n{{#SWITCH_SWBOTB_OPTION_1}}\n* In case of SWBOTB = 1, prescribe groundwater level\n\n* specify DATE1 [date] and GWLEVEL [cm, -10000..1000, R]:\n{{#TABLE_SWBOTBTB1}}\n  {{DATE1}} {{GWLEVEL}}\n{{/TABLE_SWBOTBTB1}}\n* End of table\n\n{{/SWITCH_SWBOTB_OPTION_1}}\n{{#SWITCH_SWBOTB_OPTION_2}}\n* In case of SWBOTB = 2, prescribe bottom flux\n\n* Specify whether a sinus function or a table are used for the bottom flux:\n  SW2    = {{SW2}}           ! 1 = sinus function\n                             ! 2 = table\n\n{{#SWITCH_SW2_OPTION_1}}\n* In case of sinus function (SW2 = 1), specify:\n  SINAVE = {{SINAVE}}        ! Average value of bottom flux [-10..10 cm/d, R, + = upwards]\n  SINAMP = {{SINAMP}}        ! Amplitude of bottom flux sine function [-10..10 cm/d, R]\n  SINMAX = {{SINMAX}}        ! Time of the year with maximum bottom flux [0..366 d, R]  \n{{/SWITCH_SW2_OPTION_1}}\n{{#SWITCH_SW2_OPTION_2}}\n* In case of table (SW2 = 2), specify date DATE2 [date] and bottom flux QBOT2 [-100..100 cm/d, R, positive = upwards]:\n\n{{#TABLE_SWBOTBTB2}}\n  {{DATE2}} {{QBOT2}}\n{{/TABLE_SWBOTBTB2}}\n* End of table\n{{/SWITCH_SW2_OPTION_2}}\n\n{{/SWITCH_SWBOTB_OPTION_2}}\n{{#SWITCH_SWBOTB_OPTION_3}}\n* In case of SWBOTB = 3, calculate bottom flux from hydraulic head in deep aquifer\n\n* Switch for vertical hydraulic resistance between bottom boundary and groundwater level\n  SWBOTB3RESVERT = {{SWBOTB3RESVERT}} ! 0 = Include vertical hydraulic resistance\n                             ! 1 = Suppress vertical hydraulic resistance\n\n* Switch for numerical solution of bottom flux: 0 = explicit, 1 = implicit\n  SWBOTB3IMPL = {{SWBOTB3IMPL}} ! 0 = explicit solution (choose always when SHAPE &lt; 1.0)\n                             ! 1 = implicit solution\n\n* Specify:\n  SHAPE  = {{SHAPE}}         ! Shape factor to derive average groundwater level [0..1 -, R]\n  HDRAIN = {{HDRAIN}}        ! Mean drain base to correct for average groundwater level [-10000..0 cm, R]\n  RIMLAY = {{RIMLAY}}        ! Vertical resistance of aquitard [0..100000 d, R]\n\n* Specify whether a sinus function or a table are used for the hydraulic head in the deep aquifer:\n  SW3    = {{SW3}}           ! 1 = sinus function  \n                             ! 2 = table \n\n{{#SWITCH_SW3_OPTION_1}}\n* In case of sinus function (SW3  = 1), specify:\n  AQAVE  = {{AQAVE}}         ! Average hydraulic head in underlaying aquifer [-10000..1000 cm, R] \n  AQAMP  = {{AQAMP}}         ! Amplitude hydraulic head sinus wave [0..1000 cm, R]\n  AQTMAX = {{AQTMAX}}        ! First time of the year with maximum hydraulic head [0..366 d, R]\n  AQPER  = {{AQPER}}         ! Period hydraulic head sinus wave [0..366 d, I]\n{{/SWITCH_SW3_OPTION_1}}\n{{#SWITCH_SW3_OPTION_2}}\n* In case of table (SW3  = 2), specify date DATE3 [date] and average pressure head in underlaying aquifer HAQUIF [-10000..1000 cm, R]:\n\n{{#TABLE_SWBOTBTB3A}}\n  {{DATE3}} {{HAQUIF}}\n{{/TABLE_SWBOTBTB3A}}\n* End of table\n{{/SWITCH_SW3_OPTION_2}}\n\n* An extra groundwater flux can be specified which is added to above specified flux\n  SW4   = {{SW4}}            ! 0 = no extra flux \n                             ! 1 = include extra flux\n\n{{#SWITCH_SW4_OPTION_1}}\n* If SW4 = 1, specify date DATE4 [date] and bottom flux QBOT4 [-100..100 cm/d, R]\n* QTAB is positive when flux is upward:\n\n{{#TABLE_SWBOTBTB3B}}\n  {{DATE4}} {{QBOT4}}\n{{/TABLE_SWBOTBTB3B}}\n* End of table\n\n{{/SWITCH_SW4_OPTION_1}}\n\n{{/SWITCH_SWBOTB_OPTION_3}}\n{{#SWITCH_SWBOTB_OPTION_4}}\n* In case of SWBOTB = 4, calculate bottom flux as function of groundwater level\n\n* Specify whether an exponential relation or a table is used [1..2 -,I]:\n  SWQHBOT = {{SWQHBOT}}      ! 1 = bottom flux is calculated with an exponential relation\n                             ! 2 = bottom flux is derived from a table\n\n{{#SWITCH_SWQHBOT_OPTION_1}}\n* In case of an exponential relation (SWQHBOT = 1),\n* specify coefficients of relation qbot = A exp (B*abs(groundwater level))\n  COFQHA = {{COFQHA}}        ! Coefficient A, [-100..100 cm/d, R]\n  COFQHB = {{COFQHB}}        ! Coefficient B  [-1..1 /cm, R]\n\n* If SWQHBOT = 1, an extra flux can be added to the exponential relation\n  COFQHC = {{COFQHC}}        ! Water flux (positive upward) in addition to flux from exponential relation [-10..10 cm/d, R]\n{{/SWITCH_SWQHBOT_OPTION_1}}\n{{#SWITCH_SWQHBOT_OPTION_2}}\n* In case of a table (SWQHBOT  = 2),\n* specify groundwaterlevel HTAB [-10000..1000, cm, R] and bottom flux QTAB [-100..100 cm/d, R]\n* HTAB is negative below the soil surface, QTAB is positive when flux is upward:\n\n{{#TABLE_SWBOTBTB4}}\n  {{HTAB}} {{QTAB}}\n{{/TABLE_SWBOTBTB4}}\n* End of table\n{{/SWITCH_SWQHBOT_OPTION_2}}\n\n{{/SWITCH_SWBOTB_OPTION_4}}\n{{#SWITCH_SWBOTB_OPTION_5}}\n* In case of SWBOTB = 5, prescribe soil water pressure head of bottom compartment\n\n* Specify date DATE5 [date] and bottom compartment pressure head HBOT5 [-1.d10..1000 cm, R]:\n\n{{#TABLE_SWBOTBTB5}}\n  {{DATE5}} {{HBOT5}}\n{{/TABLE_SWBOTBTB5}}\n* End of table\n\n{{/SWITCH_SWBOTB_OPTION_5}}\n{{/SWITCH_SWBBCFILE_OPTION_0}}\n{{#SWITCH_SWBBCFILE_OPTION_1}}\n* If SWBBCFILE = 1 specify name of file with bottom boundary data:\n  BBCFIL = {{BBCFIL}}        ! File name without extension .BBC [A32]\n\n{{/SWITCH_SWBBCFILE_OPTION_1}}\n**********************************************************************************\n\n\n**********************************************************************************\n\n*** HEAT FLOW SECTION ***\n\n**********************************************************************************\n* Switch for simulation of heat transport:\n  SWHEA  = {{SWHEA}}         ! 0 = no simulation of heat transport\n                             ! 1 = simulation of heat transport\n\n{{#SWITCH_SWHEA_OPTION_1}}\n* Switch for calculation method:\n  SWCALT = {{SWCALT}}        ! 1 = analytical method\n                             ! 2 = numerical method\n\n{{#SWITCH_SWCALT_OPTION_1}}\n* In case of the Analytical method (SWCALT = 1) specify:\n* If SWCALT = 1 specify the following heat parameters:\n  TAMPLI = {{TAMPLI}}        ! Amplitude of annual temperature wave at soil surface [0..50 oC, R]\n  TMEAN  = {{TMEAN}}         ! Mean annual temperature at soil surface [-10..30 oC, R]\n  TIMREF = {{TIMREF}}        ! Time at which the sinus temperature wave reaches it's top [0..366.0 d, R]\n  DDAMP  = {{DDAMP}}         ! Damping depth of soil temperature wave [1..500 cm, R]\n\n{{/SWITCH_SWCALT_OPTION_1}}\n{{#SWITCH_SWCALT_OPTION_2}}\n* In case of the numerical method (SWCALT = 2) specify:\n* Specify for each physical soil layer the soil texture (g/g mineral parts) and the organic matter content (g/g dry soil):\n\n{{#TABLE_SOILTEXTURES}}\n  {{PSAND}} {{PSILT}} {{PCLAY}} {{ORGMAT}}\n{{/TABLE_SOILTEXTURES}}\n* End of table\n\n{{#SWITCH_SWINCO_OPTION_1}}\n* If SWINCO = 1 or 2, list initial temperature TSOIL [-50..50 oC, R] as function of soil depth ZH [-100000..0 cm, R]:\n\n{{#TABLE_INITSOIL}}\n  {{ZH}} {{TSOIL}}\n{{/TABLE_INITSOIL}}\n* End of table\n{{/SWITCH_SWINCO_OPTION_1}}\n{{#SWITCH_SWINCO_OPTION_2}}\n* If SWINCO = 1 or 2, list initial temperature TSOIL [-50..50 oC, R] as function of soil depth ZH [-100000..0 cm, R]:\n\n{{#TABLE_INITSOIL}}\n  {{ZH}} {{TSOIL}}\n{{/TABLE_INITSOIL}}\n* End of table\n{{/SWITCH_SWINCO_OPTION_2}}\n\n* Define top boundary condition: \n  SWTOPBHEA = {{SWTOPBHEA}}  ! 1 = use air temperature of meteo input file as top boundary\n                             ! 2 = use measured top soil temperature as top boundary\n\n{{#SWITCH_SWTOPBHEA_OPTION_2}}\n* If SWTOPBHEA = 2, specify name of input file with soil surface temperatures\n  TSOILFILE = 'swap'         ! File name without extension .TSS [A16]\n\n{{/SWITCH_SWTOPBHEA_OPTION_2}}\n* Define bottom boundary condition:\n  SWBOTBHEA = {{SWBOTBHEA}}  ! 1 = no heat flux\n                             ! 2 = prescribe bottom temperature\n\n{{#SWITCH_SWBOTBHEA_OPTION_2}}\n* If SWBOTBHEA = 2, specify bottom boundary temperature TBOT [-50..50 oC, R] as function of date DATET [date]:\n\n{{#TABLE_BBCTSOIL}}\n  {{DATET}} {{TBOT}}\n{{/TABLE_BBCTSOIL}}\n* End of table\n\n{{/SWITCH_SWBOTBHEA_OPTION_2}}\n{{/SWITCH_SWCALT_OPTION_2}}\n{{/SWITCH_SWHEA_OPTION_1}}\n\n**********************************************************************************\n\n\n**********************************************************************************\n\n*** SOLUTE SECTION ***\n\n**********************************************************************************\n* Part 0: Specify whether simulation includes solute transport\n\n* Switch for simulation of solute transport\n  SWSOLU = {{SWSOLU}}        ! 0 = no simulation of solute transport\n                             ! 1 = simulation of solute transport\n\n{{#SWITCH_SWSOLU_OPTION_1}}\n**********************************************************************************\n* Part 1: Boundary and initial conditions\n\n  CPRE = {{CPRE}}            ! Solute concentration in precipitation, [0..100 mg/cm3 R]\n  CDRAIN = {{CDRAIN}}        ! Solute concentration in surface water [0..100 mg/cm3 R]\n\n* Switch for groundwater concentration in case of upward flow (seepage):\n  SWBOTBC = {{SWBOTBC}}      ! 0 = Equal to surface water concentration CDRAIN\n                             ! 1 = Constant concentration CSEEP\n                             ! 2 = Concentration as function of time\n\n{{#SWITCH_SWBOTBC_OPTION_1}}\n* In case of constant concentration (SWBOTBC = 1), specify:\n  CSEEP = {{CSEEP}}          ! Solute concentration in surface water [0..100 mg/cm3, R]\n\n{{/SWITCH_SWBOTBC_OPTION_1}}\n{{#SWITCH_SWBOTBC_OPTION_2}}\n* In case of SWBOTBC = 2, specify groundwater conc. CSEEPARR [0..100 mg/cm3, R] as function of date DATEC [date]:\n\n{{#TABLE_CSEEPARRTB}}\n  {{DATEC}} {{CSEEPARR}}\n{{/TABLE_CSEEPARRTB}}\n* End of table\n\n{{/SWITCH_SWBOTBC_OPTION_2}}\n\n{{#SWITCH_SWINCO_OPTION_1}}\n* If SWINCO = 1, list initial solute concentration CML [0..1000 mg/cm3, R] as function of soil depth ZC [-100000..0 cm, R]:\n\n{{#TABLE_INISSOIL}}\n  {{ZC}} {{CML}}\n{{/TABLE_INISSOIL}}\n* End of table\n\n{{/SWITCH_SWINCO_OPTION_1}}\n{{#SWITCH_SWINCO_OPTION_2}}\n* If SWINCO = 2, list initial solute concentration CML [0..1000 mg/cm3, R] as function of soil depth ZC [-100000..0 cm, R]:\n\n{{#TABLE_INISSOIL}}\n  {{ZC}} {{CML}}\n{{/TABLE_INISSOIL}}\n* End of table\n\n{{/SWITCH_SWINCO_OPTION_2}}\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 2: Miscellaneous parameters as function of soil depth\n\n* Specify for each soil layer:\n* LDIS   = Dispersion length [0..100 cm, R]\n{{#SWITCH_SWSP_OPTION_1}}\n* KF     = Freundlich adsorption coefficient [0..1d4 cm3/mg, R]\n{{/SWITCH_SWSP_OPTION_1}}\n{{#SWITCH_SWDC_OPTION_1}}\n* DECPOT = Potential decomposition rate [0..10 /d, R]\n* FDEPTH = Reduction factor for decomposition [0..1 -, R]\n{{/SWITCH_SWDC_OPTION_1}}\n\n{{#SWITCH_SWSP_OPTION_0}}\n{{#SWITCH_SWDC_OPTION_0}}\n{{#TABLE_MISCELLANEOUS}}\n  {{LDIS}}\n{{/TABLE_MISCELLANEOUS}}\n* End of Table\n{{/SWITCH_SWDC_OPTION_0}}\n{{#SWITCH_SWDC_OPTION_1}}\n{{#TABLE_MISCELLANEOUS}}\n  {{LDIS}} {{DECPOT}} {{FDEPTH}}\n{{/TABLE_MISCELLANEOUS}}\n* End of Table\n{{/SWITCH_SWDC_OPTION_1}}\n{{/SWITCH_SWSP_OPTION_0}}\n\n{{#SWITCH_SWSP_OPTION_1}}\n{{#SWITCH_SWDC_OPTION_0}}\n{{#TABLE_MISCELLANEOUS}}\n  {{LDIS}} {{KF}}\n{{/TABLE_MISCELLANEOUS}}\n* End of Table\n{{/SWITCH_SWDC_OPTION_0}}\n{{#SWITCH_SWDC_OPTION_1}}\n{{#TABLE_MISCELLANEOUS}}\n  {{LDIS}} {{KF}} {{DECPOT}} {{FDEPTH}}\n{{/TABLE_MISCELLANEOUS}}\n* End of Table\n{{/SWITCH_SWDC_OPTION_1}}\n{{/SWITCH_SWSP_OPTION_1}}\n\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 3: Diffusion constant and solute uptake by roots\n\n  DDIF = {{DDIF}}            ! Molecular diffusion coefficient [0..10 cm2/d, R]\n  TSCF = {{TSCF}}            ! Relative uptake of solutes by roots [0..10 -, R]\n\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 4: Adsorption \n\n* Switch, consider solute adsorption\n  SWSP = {{SWSP}}            ! 0 = no solute adsorption\n                             ! 1 = simulation of solute adsorption\n\n{{#SWITCH_SWSP_OPTION_1}}\n* In case of adsorption (SWSP = 1), specify:\n  FREXP = {{FREXP}}          ! Freundlich exponent [0..10 -, R]\n  CREF  = {{CREF}}           ! Reference solute concentration for adsorption [0..1000 mg/cm3, R]\n\n{{/SWITCH_SWSP_OPTION_1}}\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 5: Decomposition\n\n* Switch, consider solute decomposition\n  SWDC = {{SWDC}}            ! 0 = no solute decomposition\n                             ! 1 = simulation of solute decomposition\n\n{{#SWITCH_SWDC_OPTION_1}}\n* In case of solute decomposition (SWDC = 1), specify:\n  GAMPAR = {{GAMPAR}}        ! Factor reduction decomposition due to temperature [0..0.5 /C, R]\n  RTHETA = {{RTHETA}}        ! Minimum water content for potential decomposition [0..0.4 cm3/cm3, R]\n  BEXP   = {{BEXP}}          ! Exponent in reduction decomposition due to dryness [0..2 -, R]\n\n{{/SWITCH_SWDC_OPTION_1}}\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 6: Solute residence time in the saturated zone\n\n  SWBR = {{SWBR}}            ! Switch, consider mixed reservoir of saturated zone [Y=1, N=0]\n\n{{#SWITCH_SWBR_OPTION_1}}\n* In case of mixed reservoir (SWBR = 1), specify:\n  DAQUIF  = {{DAQUIF}}       ! Thickness saturated part of aquifer [0..10000 cm, R]\n  POROS   = {{POROS}}        ! Porosity of aquifer [0..0.6 -, R]\n  KFSAT   = {{KFSAT}}        ! Linear adsorption coefficient in aquifer [0..100 cm3/mg, R]\n  DECSAT  = {{DECSAT}}       ! Decomposition rate in aquifer [0..10 /d, R]\n  CDRAINI = {{CDRAINI}}      ! Initial solute concentration in groundwater [0..100 mg/cm3, R]\n\n{{/SWITCH_SWBR_OPTION_1}}\n{{/SWITCH_SWSOLU_OPTION_1}}\n**********************************************************************************\n\n* End of the main input file .SWP!\n</code></pre>","boost":0.5},{"location":"wiki/input-files/3-met-file/","title":".MET","text":"<p>Originally, the meteorological data was passed to SWAP in files that had extensions equal to the last three digits of the year. However, the option to use one file (csv-like) with .met extension seems to be the best choice for simplicity. Therefore, for now, pySWAP only allows to use the .met file.</p> <p>Depending on the selected option, the .met file will have a different set of headers.</p>","boost":0.5},{"location":"wiki/input-files/4-crp-file/","title":".CRP","text":"<p>In swap there are three implementation of a crop module: simple (fixed) crop, WOFOST implementation and a dynamic grass growth. Each requires slightly different set of variables. Below are the templates of the .crp files.</p>","boost":0.5},{"location":"wiki/input-files/4-crp-file/#simple_fixed_crop","title":"Simple (fixed) crop","text":"CROPFIL_FIXED.template <pre><code>**********************************************************************************\n* Contents: SWAP 4 - Crop data (fixed crop)\n**********************************************************************************\n* Comment area:\n* Testbank of SWAP: build with template of crp-file\n*\n**********************************************************************************\n\n*** PLANT GROWTH SECTION ***\n\n**********************************************************************************\n* Part 0 : Preparation, Sowing, Germination and Harvest\n\n* Part 0a: Preparation before crop growth\n\n* Switch for preparation:\n  SWPREP = {{SWPREP}}        ! 0 = No preparation\n                             ! 1 = Preparation before start of crop growth\n\n{{#SWITCH_SWPREP_OPTION_1}}\n* If SWPREP = 1, specify:\n  ZPREP = {{ZPREP}}          ! Z-level for monitoring work-ability for the crop [-100..0 cm, R]\n  HPREP = {{HPREP}}          ! Maximum pressure head during preparation [-200..0 cm, R]\n  MAXPREPDELAY = {{MAXPREPDELAY}} ! Maximum delay of preparation from start of growing season [1..366 d, I]\n\n{{/SWITCH_SWPREP_OPTION_1}}\n* Part 0b: Sowing\n* Switch for sowing:\n  SWSOW = {{SWSOW}}          ! 0 = No sowing\n                             ! 1 = Sowing before start of crop growth\n\n{{#SWITCH_SWSOW_OPTION_1}}\n* If SWSOW = 1, specify:\n  ZSOW = {{ZSOW}}            ! Z-level for monitoring work-ability for the crop [-100..0 cm, R]\n  HSOW = {{HSOW}}            ! Maximum pressure head during sowing [-200..0 cm, R]\n  ZTEMPSOW = {{ZTEMPSOW}}    ! Z-level for monitoring temperature for sowing [-100..0 cm, R]\n  TEMPSOW = {{TEMPSOW}}      ! Soil temperature needed for sowing [0..30 oC, R]\n  MAXSOWDELAY = {{MAXSOWDELAY}} ! Maximum delay of sowing from start of growing season [1..366 d, I]\n\n{{/SWITCH_SWSOW_OPTION_1}}\n* Part 0c: Germination\n\n* Switch for germination:\n  SWGERM = {{SWGERM}}        ! 0 = No germination\n                             ! 1 = Simulate germination depending on temperature\n                             ! 2 = Simulate germination depending on temperature and hydrological conditions\n\n{{#SWITCH_SWGERM_OPTION_1}}\n* If SWGERM = 1, specify:\n  TSUMEMEOPT = {{TSUMEMEOPT}} ! Temperature sum needed for crop emergence [0..1000 oC, R]\n  TBASEM = {{TBASEM}}        ! Minimum temperature, used for germination trajectory [0..40 oC, R]  \n  TEFFMX = {{TEFFMX}}        ! Maximum temperature, used for germination trajectory [0..40 oC, R]  \n\n{{/SWITCH_SWGERM_OPTION_1}}\n{{#SWITCH_SWGERM_OPTION_2}}\n* If SWGERM = 1, specify:\n  TSUMEMEOPT = {{TSUMEMEOPT}} ! Temperature sum needed for crop emergence [0..1000 oC, R]\n  TBASEM = {{TBASEM}}        ! Minimum temperature, used for germination trajectory [0..40 oC, R]  \n  TEFFMX = {{TEFFMX}}        ! Maximum temperature, used for germination trajectory [0..40 oC, R]  \n  HDRYGERM = {{HDRYGERM}}    ! Pressure head rootzone for dry germination trajectory [-1000..-0.01 cm, R]\n  HWETGERM = {{HWETGERM}}    ! Pressure head rootzone for wet germination trajectory [-100..-0.01 cm, R]\n  ZGERM = {{ZGERM}}          ! Z-level for monitoring average pressure head [-100..0 cm, R]\n  AGERM = {{AGERM}}          ! A-coefficient Eq. 24/25 Feddes &amp; Van Wijk [1..1000, R]\n\n{{/SWITCH_SWGERM_OPTION_2}}\n\n* Part 0d: Harvest\n\n  DVSEND = {{DVSEND}}        ! Development stage at harvest [0..3 -, R]\n\n* Switch to check work-ability during harvest:\n  SWHARV = {{SWHARV}}        ! 0 = Timing of harvest depends on end of growing period (CROPEND)\n                             ! 1 = Timing of harvest depends on development stage (DVSEND)\n\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 1: Crop development\n\n* Duration of crop growing period:\n  IDEV = {{IDEV}}            ! 1 = Duration is fixed\n                             ! 2 = Duration is variable\n\n{{#SWITCH_IDEV_OPTION_1}}\n* If duration is fixed (IDEV = 1), specify:                                                \n  LCC = {{LCC}}              ! Duration of the crop growing period [1..366 days, I]\n{{/SWITCH_IDEV_OPTION_1}}\n{{#SWITCH_IDEV_OPTION_2}}\n* If duration is variable (IDEV = 2), specify:                                                \n  TSUMEA = {{TSUMEA}}        ! Temperature sum from emergence to anthesis [0..1d4 oC, R]\n  TSUMAM = {{TSUMAM}}        ! Temperature sum from anthesis to maturity  [0..1d4 oC, R]\n  TBASE = {{TBASE}}          ! Start value of temperature sum [-10..30 0C, R]\n{{/SWITCH_IDEV_OPTION_2}}\n\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 2: Light extinction\n\n  KDIF = {{KDIF}}            ! Extinction coefficient for diffuse visible light [0..2 -, R]\n  KDIR = {{KDIR}}            ! Extinction coefficient for direct visible light  [0..2 -, R]\n\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 3: Leaf area index or soil cover fraction\n\n* Choose between LAI or SCF:\n  SWGC = {{SWGC}}            ! 1 = Leaf Area Index\n                             ! 2 = Soil Cover Fraction\n\n{{#SWITCH_SWGC_OPTION_1}}\n* If SWGC = 1, list Leaf Area Index [0..12 (m2 leaf)/(m2 soil), R], as function of dev. stage [0..2 -, R]:\n\n* DVS   LAI\n  GCTB =                \n{{#TABLE_GCTB}}\n  {{DVS}} {{LAI}}\n{{/TABLE_GCTB}}\n{{/SWITCH_SWGC_OPTION_1}}\n{{#SWITCH_SWGC_OPTION_2}}\n* If SWGC = 2, list Soil Cover Fraction [0..1 (m2 cover)/(m2 soil), R], as function of dev. stage [0..2 -, R]:\n\n* DVS   SCF\n  GCTB =                \n{{#TABLE_GCTB}}\n  {{DVS}} {{SCF}}\n{{/TABLE_GCTB}}\n{{/SWITCH_SWGC_OPTION_2}}\n* End of table\n\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 4: crop factor or crop height\n\n* Choose between crop factor and crop height\n* Choose crop factor if ETref is used, either from meteo input file (SWETR = 1) or with Penman-Monteith\n* Choose crop height if Penman-Monteith should be used with actual crop height, albedo and canopy resistance\n  SWCF = {{SWCF}}            ! 1 = Crop factor \n                             ! 2 = Crop height\n\n{{#SWITCH_SWCF_OPTION_1}}\n* If SWCF = 1, list Crop Factor [0..2 -, R],   as function of dev. stage [0..2 -, R]:\n\n{{#TABLE_CFTB}}\n  {{DVS}} {{CF}}\n{{/TABLE_CFTB}}\n{{/SWITCH_SWCF_OPTION_1}}\n{{#SWITCH_SWCF_OPTION_2}}\n* If SWCF = 2, list Crop Height [0..1.d4 cm, R], as function of dev. stage [0..2 -, R]:\n\n{{#TABLE_CFTB}}\n  {{DVS}} {{CH}}\n{{/TABLE_CFTB}}\n* End of table\n\n* If SWCF = 2, in addition to crop height list crop specific values for:\n  ALBEDO = {{ALBEDO}}        ! Crop reflection coefficient [0..1.0 -, R]                    \n  RSC = {{RSC}}              ! Minimum canopy resistance [0..1d6 s/m, R]\n  RSW = {{RSW}}              ! Canopy resistance of intercepted water [0..1d6 s/m, R]\n{{/SWITCH_SWCF_OPTION_2}}\n\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 10: Root growth and root density profile\n\n* Switch development of root growth\n  SWRD = {{SWRD}}            ! 1 = Root growth depends on development stage\n                             ! 2 = Root growth depends on maximum daily increase\n                             ! 3 = Root growth depends on available root biomass\n\n{{#SWITCH_SWRD_OPTION_1}}\n* If case of dependency development stage (SWRD=1), specify:\n* List Rooting Depth [0..1000 cm, R], as a function of development stage [0..2 -, R]:\n\n*  DVS   RD\n  RDTB =\n{{#TABLE_RDTB}}\n  {{DVS}} {{RD}}\n{{/TABLE_RDTB}}\n* End of table\n{{/SWITCH_SWRD_OPTION_1}}\n{{#SWITCH_SWRD_OPTION_2}}\n* If case of dependency maximum daily increase (SWRD=2), specify:\n  RDI = {{RDI}}              ! Initial rooting depth [0..1000 cm, R]\n  RRI = {{RRI}}              ! Maximum daily increase in rooting depth [0..100 cm/d, R]\n  RDC = {{RDC}}              ! Maximum rooting depth of particular crop [0..1000 cm, R]\n\n* Switch for calculation rooting depth:\n  SWDMI2RD = {{SWDMI2RD}}    ! 0 = Rooting depth increase is related to availability assimilates for roots\n                             ! 1 = Rooting depth increase is related to relative dry matter increase\n\n{{/SWITCH_SWRD_OPTION_2}}\n{{#SWITCH_SWRD_OPTION_3}}\n* In case of dependency available root biomass (SWRD=3), specify:\n* List rooting depth [0..5000 cm, R] as function of root weight [0..5000 kg DM/ha, R]:\n*   RW     RD\n  RLWTB =\n{{#TABLE_RLWTB}}\n  {{RW}} {{RD}}\n{{/TABLE_RLWTB}}\n* End of table\n\n  WRTMAX = {{WRTMAX}}        ! Maximum root weight [0..1d5 kg DM/ha, R]                \n{{/SWITCH_SWRD_OPTION_3}}\n\n* Always specify:\n* Switch for calculation of relative root density (default SWRDC = 1):\n  SWRDC = {{SWRDC}}          ! 0 = Root density is not modified\n                             ! 1 = Root density is modified based on root water extraction\n\n* List root density [0..100 cm/cm3, R] as function of relative rooting depth [0..1 -, R]:\n* In case of drought stress according to Feddes et al. (1978) (SWDROUGHT = 1), relative root density (-) is sufficient\n\n*   RRD    RDENS\n  RDCTB =\n{{#TABLE_RDCTB}}\n  {{RRD}} {{RDENS}}\n{{/TABLE_RDCTB}}\n* End of table\n\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 11: Oxygen stress\n\n* Switch for oxygen stress:\n  SWOXYGEN = {{SWOXYGEN}}    ! 0 = No oxygen stress\n                             ! 1 = Oxygen stress according to Feddes et al. (1978)\n                             ! 2 = Oxygen stress according to Bartholomeus et al. (2008)\n\n* Switch for checking aerobic conditions in root zone to stop root(zone) development\n  SWWRTNONOX = {{SWWRTNONOX}} ! 0 = Do not check for aerobic conditions\n                             ! 1 = Check for aerobic conditions\n\n{{#SWITCH_SWWRTNONOX_OPTION_1}}\n  AERATECRIT = {{AERATECRIT}} ! Threshold to stop root extension in case of oxygenstress; 0.0 maximum oxygen stress [0.0001..1.0 -, R]\n\n{{/SWITCH_SWWRTNONOX_OPTION_1}}\n{{#SWITCH_SWOXYGEN_OPTION_1}}\n* If SWOXYGEN=1, specify:\n  HLIM1 = {{HLIM1}}          ! No water extraction at higher pressure heads [-100..100 cm, R]\n  HLIM2U = {{HLIM2U}}        ! H below which optimum water extr. starts for top layer [-1000..100 cm, R]\n  HLIM2L = {{HLIM2L}}        ! H below which optimum water extr. starts for sub layer [-1000..100 cm, R]\n{{/SWITCH_SWOXYGEN_OPTION_1}}\n{{#SWITCH_SWOXYGEN_OPTION_2}}\n* If SWOXYGEN=2, specify:\n  Q10_MICROBIAL = {{Q10_MICROBIAL}} ! Relative increase in microbial respiration at temperature increase of 10 C [1.0..4.0 -, R]\n  SPECIFIC_RESP_HUMUS = {{SPECIFIC_RESP_HUMUS}} ! Respiration rate of humus at 25 C [0.0..1.0 kg O2/kg C/d, R] \n  SRL = {{SRL}}              ! Specific root length [0.0..1.d10 m root/kg root, R]      \n\n* Switch for calculation of root radius:  \n  SWROOTRADIUS = {{SWROOTRADIUS}} ! 1 = Calculate root radius\n                             ! 2 = Root radius is given in input file\n\n{{#SWITCH_SWROOTRADIUS_OPTION_1}}\n* If SWROOTRADIUS=1, specify:\n  DRY_MAT_CONT_ROOTS = {{DRY_MAT_CONT_ROOTS}} ! Dry matter content of roots [0.0..1.0 -, R]\n  AIR_FILLED_ROOT_POR = {{AIR_FILLED_ROOT_POR}} ! Air filled root porosity [0.0..1.0 -, R]\n  SPEC_WEIGHT_ROOT_TISSUE = {{SPEC_WEIGHT_ROOT_TISSUE}} ! Specific weight of non-airfilled root tissue [0.0..1.d5 kg root/m3 root, R]\n  VAR_A = {{VAR_A}}          ! Variance of root radius [0.0..1.0 -, R]\n{{/SWITCH_SWROOTRADIUS_OPTION_1}}\n{{#SWITCH_SWROOTRADIUS_OPTION_2}}\n* If SWROOTRADIUS=2, specify:\n  ROOT_RADIUSO2 = {{ROOT_RADIUSO2}} ! Root radius for oxygen stress module [1d-6..0.1 m, R]\n{{/SWITCH_SWROOTRADIUS_OPTION_2}}\n* If CROPTYPE=1 and SWOXYGEN=2 growth, specify: \n  Q10_ROOT = {{Q10_ROOT}}    ! Relative increase in root respiration at temperature increase of 10 oC [1.0..4.0 -, R]\n  F_SENES  = {{F_SENES}}     ! Reduction factor for senescence, used for maintenance respiration [0..1.0 -, R]\n  C_MROOT  = {{C_MROOT}}     ! Maintenance coefficient of root [0.0..1.0 kg O2/kg/d, R]\n\n* Ratio root total respiration / maintenance respiration [1..5.0 -, R]\n*  DVS   MAX_RESP_FACTOR\n  MRFTB =\n{{#TABLE_MRFTB}}\n  {{DVS}} {{MAX_RESP_FACTOR}}\n{{/TABLE_MRFTB}}\n* End of table\n\n* List dry weight of roots at soil surface [0..10 kg/m3, R], as a function of development stage [0..2 -,R]:\n*  DVS   W_ROOT_SS\n  WRTB =\n{{#TABLE_WRTB}}\n  {{DVS}} {{W_ROOT_SS}}\n{{/TABLE_WRTB}}\n* End of table\n{{/SWITCH_SWOXYGEN_OPTION_2}}\n\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 12: Drought stress\n\n* Switch for drought stress:\n  SWDROUGHT = {{SWDROUGHT}}  ! 1 = Drought stress according to Feddes et al. (1978)\n                             ! 2 = Drought stress according to De Jong van Lier et al. (2008)\n\n{{#SWITCH_SWDROUGHT_OPTION_1}}\n* If SWDROUGHT=1, or in case of irrigation scheduling (SCHEDULE = 1), specify:\n  HLIM3H = {{HLIM3H}}        ! Pressure head below which water uptake reduction starts at high Tpot [-1d4..100 cm, R]\n  HLIM3L = {{HLIM3L}}        ! Pressure head below which water uptake reduction starts at low Tpot  [-1d4..100 cm, R]\n  HLIM4 = {{HLIM4}}          ! No water extraction at lower soil water pressure heads [-1.6d4..100 cm, R]\n  ADCRH = {{ADCRH}}          ! Level of high atmospheric demand, corresponding to HLIM3H [0..5 cm/d, R]     \n  ADCRL = {{ADCRL}}          ! Level of low atmospheric demand, corresponding to HLIM3L [0..5 cm/d, R]     \n{{/SWITCH_SWDROUGHT_OPTION_1}}\n{{#SWITCH_SWDROUGHT_OPTION_2}}\n* If SWDROUGHT=2, specify:\n  WILTPOINT  = {{WILTPOINT}} ! Minimum pressure head in leaves [-1d8..-1d2 cm, R]\n  KSTEM = {{KSTEM}}          ! Hydraulic conductance between leaf and root xylem [1d-10..10 /d, R]\n  RXYLEM = {{RXYLEM}}        ! Xylem radius [1d-4..1 cm, R]\n  ROOTRADIUS = {{ROOTRADIUS}} ! Root radius [1d-4..1 cm, R]\n  KROOT = {{KROOT}}          ! Radial hydraulic conductivity of root tissue [1d-10..1d10 cm/d, R] \n  ROOTCOEFA  = {{ROOTCOEFA}} ! Defines relative distance between roots at which mean soil water content occurs [0..1 -, R]\n  SWHYDRLIFT = {{SWHYDRLIFT}} ! Switch for possibility hydraulic lift in root system [N=0, Y=1]\n  ROOTEFF = {{ROOTEFF}}      ! Root system efficiency factor [0..1 -, R]\n  STEPHR = {{STEPHR}}        ! Step between values of hroot and hxylem in iteration cycle [0..10 cm, R]\n  CRITERHR = {{CRITERHR}}    ! Maximum difference of Hroot between iterations; convergence criterium [0..10 cm, R]\n  TACCUR = {{TACCUR}}        ! Maximum absolute difference between simulated and calculated potential transpiration rate (1d-5..1d-2 cm/d, R)\n{{/SWITCH_SWDROUGHT_OPTION_2}}\n\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 13: salt stress\n\n* Switch salinity stress\n  SWSALINITY = {{SWSALINITY}} ! 0 = No salinity stress\n                             ! 1 = Maas and Hoffman reduction function\n                             ! 2 = Use osmotic head\n\n{{#SWITCH_SWSALINITY_OPTION_1}}\n* If SWSALINITY = 1, specify threshold and slope of Maas and Hoffman\n  SALTMAX = {{SALTMAX}}      ! Threshold salt concentration in soil water  [0..100 mg/cm3, R] \n  SALTSLOPE = {{SALTSLOPE}}  ! Decline of root water uptake above threshold [0..1.0 cm3/mg, R] \n{{/SWITCH_SWSALINITY_OPTION_1}}\n{{#SWITCH_SWSALINITY_OPTION_2}}\n* If SWSALINITY = 2, specify:\n  SALTHEAD = {{SALTHEAD}}    ! Conversion factor salt concentration (mg/cm3) into osmotic head (cm) [0..1000 cm/(mg/cm3), R]\n{{/SWITCH_SWSALINITY_OPTION_2}}\n\n**********************************************************************************\n\n\n**********************************************************************************\n* Part xx: compensation of root water uptake stress\n\n* Switch for compensation root water uptake stress\n  SWCOMPENSATE = {{SWCOMPENSATE}} ! 0 = No compensation\n                             ! 1 = Compensation according to Jarvis (1989)\n                             ! 2 = Compensation according to Walsum (2019)\n\n{{#SWITCH_SWCOMPENSATE_OPTION_1}}\n* Switch for selection of stressors to compensate\n  SWSTRESSOR = {{SWSTRESSOR}} ! 1 = Compensation of all stressors\n                             ! 2 = Compensation of drought stress\n                             ! 3 = Compensation of oxygen stress\n                             ! 4 = Compensation of salinity stress\n                             ! 5 = Compensation of frost stress\n\n* If SWCOMPENSATE = 1, specify:\n  ALPHACRIT = {{ALPHACRIT}}  ! Critical stress index for compensation of root water uptake [0.2..1 -, R]\n\n{{/SWITCH_SWCOMPENSATE_OPTION_1}}\n{{#SWITCH_SWCOMPENSATE_OPTION_2}}\n* Switch for selection of stressors to compensate\n  SWSTRESSOR = {{SWSTRESSOR}} ! 1 = Compensation of all stressors\n                             ! 2 = Compensation of drought stress\n                             ! 3 = Compensation of oxygen stress\n                             ! 4 = Compensation of salinity stress\n                             ! 5 = Compensation of frost stress\n\n* If SWCOMPENSATE = 2, specify:\n  DCRITRTZ = {{DCRITRTZ}}    ! Threshold of rootzone thickness after which compensation occurs [0.02..100 cm, R]\n\n{{/SWITCH_SWCOMPENSATE_OPTION_2}}\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 14: interception                                            \n\n* For agricultural crops apply interception concept of Von Hoyningen-Hune and Braden\n* Switch for rainfall interception method:\n  SWINTER = {{SWINTER}}      ! 0 = No interception calculated\n                             ! 1 = Agricultural crops (Von Hoyningen-Hune and Braden)\n                             ! 2 = Trees and forests (Gash)\n\n{{#SWITCH_SWINTER_OPTION_1}}\n* In case of agricultural crops (SWINTER=1) specify:\n  COFAB = {{COFAB}}          ! Interception coefficient, corresponding to maximum interception amount [0..1 cm, R]\n{{/SWITCH_SWINTER_OPTION_1}}\n{{#SWITCH_SWINTER_OPTION_2}}\n* In case of closed forest canopies (SWINTER=2), specify as function of time T [0..366 d, R]:\n* PFREE = Free throughfall coefficient [0..1 -, R]\n* PSTEM = Stem flow coefficient [0..1 -, R]\n* SCANOPY = Storage capacity of canopy [0..10 cm, R]\n* AVPREC = Average rainfall intensity [0..100 cm/d, R]\n* AVEVAP = Average evaporation intensity during rainfall from a wet canopy [0..10 cm/d, R]\n\n{{#TABLE_INTERTB}}\n  {{T}} {{PFREE}} {{PSTEM}} {{SCANOPY}} {{AVPREC}} {{AVEVAP}}\n{{/TABLE_INTERTB}}\n* End of table\n{{/SWITCH_SWINTER_OPTION_2}}\n\n**********************************************************************************\n\n\n**********************************************************************************\n\n*** IRRIGATION SCHEDULING SECTION ***\n\n**********************************************************************************\n* Part 1: General\n\n  SCHEDULE = {{SCHEDULE}}    ! Switch for application irrigation scheduling [Y=1, N=0] \n\n{{#SWITCH_SCHEDULE_OPTION_1}}\n* If SCHEDULE = 1, specify:\n  STARTIRR = {{STARTIRR}}    ! Specify day and month at which irrigation scheduling starts [dd mm]\n  ENDIRR = {{ENDIRR}}        ! Specify day and month at which irrigation scheduling stops [dd mm]\n  CIRRS = {{CIRRS}}          ! Solute concentration of irrigation water [0..100 mg/cm3, R]\n\n* Switch for type of irrigation method: \n  ISUAS = {{ISUAS}}          ! 0 = Sprinkling irrigation\n                             ! 1 = Surface irrigation\n\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 2: Irrigation time criteria\n\n* Choose one of the following timing criteria options [1..6 -, I]:\n  TCS = {{TCS}}              ! 1 = Ratio actual/potential transpiration\n                             ! 2 = Depletion of Readily Available Water\n                             ! 3 = Depletion of Totally Available Water\n                             ! 4 = Depletion of absolute Water Amount\n                             ! 6 = Fixed weekly irrigation\n                             ! 7 = Pressure head\n                             ! 8 = Moisture content\n\n{{#SWITCH_TCS_OPTION_1}}\n* Ratio actual/potential transpiration (TCS = 1)\n* Specify mimimum of ratio actual/potential transpiration TREL [0..1 -, R] as function of crop development stage\n{{#TABLE_TC1TB}}\n  {{DVS_TC1}} {{TREL}}\n{{/TABLE_TC1TB}}\n* End of table\n{{/SWITCH_TCS_OPTION_1}}\n{{#SWITCH_TCS_OPTION_2}}\n* Depletion of Readily Available Water (TCS = 2) \n* Specify minimum fraction of readily available water RAW [0..1 -, R] as function of crop development stage\n{{#TABLE_TC2TB}}\n  {{DVS_TC2}} {{RAW}}\n{{/TABLE_TC2TB}}\n* End of table\n\n  PHFIELDCAPACITY = {{PHFIELDCAPACITY}} ! Soil water pressure head at field capacity [-1000..0 cm, R]\n{{/SWITCH_TCS_OPTION_2}}\n{{#SWITCH_TCS_OPTION_3}}\n* Depletion of Totally Available Water (TCS = 3)\n* Specify minimal fraction of totally available water TAW [0..1 -, R] as function of crop development stage\n{{#TABLE_TC3TB}}\n  {{DVS_TC3}} {{TAW}}\n{{/TABLE_TC3TB}}\n* End of table\n\n  PHFIELDCAPACITY = {{PHFIELDCAPACITY}} ! Soil water pressure head at field capacity [-1000..0 cm, R]\n{{/SWITCH_TCS_OPTION_3}}\n{{#SWITCH_TCS_OPTION_4}}\n* Depletion of absolute Water Amount (TCS = 4)\n* Specify maximum amount of water depleted below field capacity DWA [0..500 mm, R] as function of crop development stage\n{{#TABLE_TC4TB}}\n  {{DVS_TC4}} {{DWA}}\n{{/TABLE_TC4TB}}\n* End of table\n\n  PHFIELDCAPACITY = {{PHFIELDCAPACITY}} ! Soil water pressure head at field capacity [-1000..0 cm, R]\n{{/SWITCH_TCS_OPTION_4}}\n{{#SWITCH_TCS_OPTION_6}}\n* Fixed weekly irrigation (TCS = 6)\n* Only irrigate when soil water deficit in root zone is larger than threshold\n  IRGTHRESHOLD = {{IRGTHRESHOLD}} ! Threshold value for weekly irrigation  [0..20 mm, R]\n{{/SWITCH_TCS_OPTION_6}}\n{{#SWITCH_TCS_OPTION_7}}\n* Pressure head (TCS = 7)\n* Specify critical pressure head [-1d6..-100 cm, R] as function of crop development stage:\n{{#TABLE_TC7TB}}\n  {{DVS_TC7}} {{HCRI}}\n{{/TABLE_TC7TB}}\n* End of table\n\n  DCRIT =  {{DCRIT}}         ! Depth of the sensor [-100..0 cm, R]\n\n* In case TCS = 7, over-irrigation can be applied if the salinity concentration exceeds a threshold salinity\n* Switch for over-irrigation:\n  SWCIRRTHRES = {{SWCIRRTHRES}} ! 0 = No over-irrigation\n                             ! 1 = Apply over-irrigation\n\n{{#SWITCH_SWCIRRTHRES_OPTION_1}}\n* If SWCIRRTHRES = 1, specify:\n  CIRRTHRES = {{CIRRTHRES}}  ! Threshold salinity concentration above which over-irrigation occurs [0..100 mg/cm3, R]\n  PERIRRSURP = {{PERIRRSURP}} ! Over-irrigation of the usually scheduled irrigation depth [0..100 %, R]\n{{/SWITCH_SWCIRRTHRES_OPTION_1}}\n{{/SWITCH_TCS_OPTION_7}}\n{{#SWITCH_TCS_OPTION_8}}\n* Moisture content (TCS = 8)\n* Specify critical moisture content [0..1 cm3/cm3, R] as function of crop development stage\n{{#TABLE_TC8TB}}\n  {{DVS_TC8}} {{TCRI}}\n{{/TABLE_TC8TB}}\n* End of table\n\n  DCRIT =  {{DCRIT}}         ! Depth of the sensor [-100..0 cm, R]\n\n* In case TCS = 8, over-irrigation can be applied if the salinity concentration exceeds a threshold salinity\n* Switch for over-irrigation:\n  SWCIRRTHRES = {{SWCIRRTHRES}} ! 0 = No over-irrigation\n                             ! 1 = Apply over-irrigation\n\n{{#SWITCH_SWCIRRTHRES_OPTION_1}}\n* If SWCIRRTHRES = 1, specify:\n  CIRRTHRES = {{CIRRTHRES}}  ! Threshold salinity concentration above which over-irrigation occurs [0..100 mg/cm3, R]\n  PERIRRSURP = {{PERIRRSURP}} ! Over-irrigation of the usually scheduled irrigation depth [0..100 %, R]\n{{/SWITCH_SWCIRRTHRES_OPTION_1}}\n{{/SWITCH_TCS_OPTION_8}}\n\n* Switch for minimum time interval between irrigation applications\n  TCSFIX = {{TCSFIX}}        ! 0 = No minimum time interval\n                             ! 1 = Define minimum time interval\n{{#SWITCH_TCSFIX_OPTION_1}}\n\n* If TCSFIX = 1, specify:\n  IRGDAYFIX = {{IRGDAYFIX}}  ! Minimum number of days between irrigation applications [1..366 d, I]\n{{/SWITCH_TCSFIX_OPTION_1}}\n\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 3: Irrigation depth criteria\n\n* Choose one of the following two options for irrigation depth:\n  DCS = {{DCS}}              ! 1 = Back to field capacity\n                             ! 2 = Fixed Irrigation Depth\n\n{{#SWITCH_DCS_OPTION_1}}\n{{#SWITCH_TCS_OPTION_1}}\n* Specify pressure head at field capacity\n  PHFIELDCAPACITY = {{PHFIELDCAPACITY}} ! Soil water pressure head at field capacity [-1000..0 cm, R] \n\n{{/SWITCH_TCS_OPTION_1}}\n{{#SWITCH_TCS_OPTION_6}}\n* Specify pressure head at field capacity\n  PHFIELDCAPACITY = {{PHFIELDCAPACITY}} ! Soil water pressure head at field capacity [-1000..0 cm, R] \n\n{{/SWITCH_TCS_OPTION_6}}\n{{#SWITCH_TCS_OPTION_7}}\n* Specify pressure head at field capacity\n  PHFIELDCAPACITY = {{PHFIELDCAPACITY}} ! Soil water pressure head at field capacity [-1000..0 cm, R] \n\n{{/SWITCH_TCS_OPTION_7}}\n{{#SWITCH_TCS_OPTION_8}}\n* Specify pressure head at field capacity\n  PHFIELDCAPACITY = {{PHFIELDCAPACITY}} ! Soil water pressure head at field capacity [-1000..0 cm, R] \n\n{{/SWITCH_TCS_OPTION_8}}\n* Specify amount of under (-) or over (+) irrigation DI [-100..100 mm, R] as function of crop development stage [0..2, R]:\n{{#TABLE_DC1TB}}\n  {{DVS_DC1}} {{DI}}\n{{/TABLE_DC1TB}}\n* End of table\n\n  RAITHRESHOLD = {{RAITHRESHOLD}} ! When rainfall exceeds RAITHRESHOLD, DI is added to back to field capacity [0..1000 cm, R]\n  {{/SWITCH_DCS_OPTION_1}}\n{{#SWITCH_DCS_OPTION_2}}\n* Specify fixed irrigation depth FID [0..400 mm, R] as function of crop development stage [0..2, R]:\n{{#TABLE_DC2TB}}\n  {{DVS_DC2}} {{FID}}\n{{/TABLE_DC2TB}}\n* End of table\n{{/SWITCH_DCS_OPTION_2}}\n\n* Select minimum and maximum of irrigation depths:\n  DCSLIM = {{DCSLIM}}        ! Switch, limit range irrigation depth  [Y=1, N=0]\n\n{{#SWITCH_DCSLIM_OPTION_1}}\n* If DCSLIM = 1, specify:\n  IRGDEPMIN = {{IRGDEPMIN}}  ! Minimum irrigation depth [0..100 mm, I]\n  IRGDEPMAX = {{IRGDEPMAX}}  ! Maximum irrigation depth [IRGDEPMIN..1d7 mm, I]\n\n{{/SWITCH_DCSLIM_OPTION_1}}\n{{/SWITCH_SCHEDULE_OPTION_1}}\n**********************************************************************************\n\n* End of .crp file !\n</code></pre>","boost":0.5},{"location":"wiki/input-files/4-crp-file/#wofost_crop","title":"WOFOST crop","text":"CROPFIL_WOFOST.template <pre><code>**********************************************************************************\n* Contents: SWAP 4 - Crop data (WOFOST)\n**********************************************************************************\n* Comment area:\n* Testbank of SWAP: build with template of crp-file\n*\n**********************************************************************************\n\n*** PLANT GROWTH SECTION ***\n\n**********************************************************************************\n* Part 0 : Preparation, Sowing, Germination and Harvest\n\n* Part 0a: Preparation before crop growth\n\n* Switch for preparation:\n  SWPREP = {{SWPREP}}         ! 0 = No preparation\n                              ! 1 = Preparation before start of crop growth\n\n{{#SWITCH_SWPREP_OPTION_1}}\n* If SWPREP = 1, specify:\n  ZPREP = {{ZPREP}}           ! Z-level for monitoring work-ability for the crop [-100..0 cm, R]\n  HPREP = {{HPREP}}           ! Maximum pressure head during preparation [-200..0 cm, R]\n  MAXPREPDELAY = {{MAXPREPDELAY}} ! Maximum delay of preparation from start of growing season [1..366 d, I]\n\n{{/SWITCH_SWPREP_OPTION_1}}\n* Part 0b: Sowing\n* Switch for sowing:\n  SWSOW = {{SWSOW}}           ! 0 = No sowing\n                              ! 1 = Sowing before start of crop growth\n\n{{#SWITCH_SWSOW_OPTION_1}}\n* If SWSOW = 1, specify:\n  ZSOW = {{ZSOW}}             ! Z-level for monitoring work-ability for the crop [-100..0 cm, R]\n  HSOW = {{HSOW}}             ! Maximum pressure head during sowing [-200..0 cm, R]\n  ZTEMPSOW = {{ZTEMPSOW}}     ! Z-level for monitoring temperature for sowing [-100..0 cm, R]\n  TEMPSOW = {{TEMPSOW}}       ! Soil temperature needed for sowing [0..30 oC, R]\n  MAXSOWDELAY = {{MAXSOWDELAY}} ! Maximum delay of sowing from start of growing season [1..366 d, I]\n\n{{/SWITCH_SWSOW_OPTION_1}}\n* Part 0c: Germination\n\n* Switch for germination:\n  SWGERM = {{SWGERM}}         ! 0 = No germination\n                              ! 1 = Simulate germination depending on temperature\n                              ! 2 = Simulate germination depending on temperature and hydrological conditions\n\n{{#SWITCH_SWGERM_OPTION_1}}\n* If SWGERM = 1, specify:\n  TSUMEMEOPT = {{TSUMEMEOPT}} ! Temperature sum needed for crop emergence [0..1000 oC, R]\n  TBASEM = {{TBASEM}}         ! Minimum temperature, used for germination trajectory [0..40 oC, R]  \n  TEFFMX = {{TEFFMX}}         ! Maximum temperature, used for germination trajectory [0..40 oC, R]  \n\n{{/SWITCH_SWGERM_OPTION_1}}\n{{#SWITCH_SWGERM_OPTION_2}}\n* If SWGERM = 2, specify:\n  TSUMEMEOPT = {{TSUMEMEOPT}} ! Temperature sum needed for crop emergence [0..1000 oC, R]\n  TBASEM = {{TBASEM}}         ! Minimum temperature, used for germination trajectory [0..40 oC, R]  \n  TEFFMX = {{TEFFMX}}         ! Maximum temperature, used for germination trajectory [0..40 oC, R]  \n  HDRYGERM = {{HDRYGERM}}     ! Pressure head rootzone for dry germination trajectory [-1000..-0.01 cm, R]\n  HWETGERM = {{HWETGERM}}     ! Pressure head rootzone for wet germination trajectory [-100..-0.01 cm, R]\n  ZGERM = {{ZGERM}}           ! Z-level for monitoring average pressure head [-100..0 cm, R]\n  AGERM = {{AGERM}}           ! A-coefficient Eq. 24/25 Feddes &amp; Van Wijk [1..1000, R]\n\n{{/SWITCH_SWGERM_OPTION_2}}\n\n* Part 0d: Harvest\n\n  DVSEND = {{DVSEND}}         ! Development stage at harvest [0..3 -, R]\n\n* Switch to check work-ability during harvest:\n  SWHARV = {{SWHARV}}         ! 0 = Timing of harvest depends on end of growing period (CROPEND)\n                              ! 1 = Timing of harvest depends on development stage (DVSEND)\n\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 1: crop factor or crop height\n\n* Choose between crop factor and crop height\n* Choose crop factor if ETref is used, either from meteo input file (SWETR = 1) or with Penman-Monteith\n* Choose crop height if Penman-Monteith should be used with actual crop height, albedo and canopy resistance\n  SWCF = {{SWCF}}             ! 1 = Crop factor \n                              ! 2 = Crop height\n\n{{#SWITCH_SWCF_OPTION_1}}\n* If SWCF = 1, list Crop Factor [0..2 -, R],   as function of dev. stage [0..2 -, R]:\n\n{{#TABLE_CFTB}}\n  {{DVS}} {{CF}}\n{{/TABLE_CFTB}}\n{{/SWITCH_SWCF_OPTION_1}}\n{{#SWITCH_SWCF_OPTION_2}}\n* If SWCF = 2, list Crop Height [0..1.d4 cm, R], as function of dev. stage [0..2 -, R]:\n\n{{#TABLE_CFTB}}\n  {{DVS}} {{CH}}\n{{/TABLE_CFTB}}\n* End of table\n\n* If SWCF = 2, in addition to crop height list crop specific values for:\n  ALBEDO = {{ALBEDO}}       ! Crop reflection coefficient [0..1.0 -, R]                    \n  RSC = {{RSC}}             ! Minimum canopy resistance [0..1d6 s/m, R]\n  RSW = {{RSW}}             ! Canopy resistance of intercepted water [0..1d6 s/m, R]\n{{/SWITCH_SWCF_OPTION_2}}\n\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 2 : Crop development\n\n* Switch for crop development:\n  IDSL = {{IDSL}}         ! 0 = Crop development before anthesis depends on temperature\n                          ! 1 = Crop development before anthesis depends on temparature and daylength\n                          ! 2 = Crop development before anthesis depends on temperature, daylength and vernalisation factor\n\n* Specify temperature dependency:\n  TSUMEA = {{TSUMEA}}     ! Temperature sum from emergence to anthesis [0..10000 oC, R]\n  TSUMAM = {{TSUMAM}}     ! Temperature sum from anthesis to maturity  [0..10000 oC, R]\n\n* List increase in temperature sum [0..60 oC, R] as function of daily average temperature [0..100 oC, R]\n*   TAV  DTSM    (maximum 15 records)\n  DTSMTB =\n{{#TABLE_DTSMTB}}\n  {{TAV}} {{DTSM}}\n{{/TABLE_DTSMTB}}\n* End of table\n\n{{#SWITCH_IDSL_OPTION_1}}\n* Specify daylength dependency:\n  DLO = {{DLO}}           ! Optimum day length for crop development [0..24 h, R]\n  DLC = {{DLC}}           ! Minimum day length [0..24 h, R]\n{{/SWITCH_IDSL_OPTION_1}}\n{{#SWITCH_IDSL_OPTION_2}}\n* Specify daylength dependency:\n  DLO = {{DLO}}           ! Optimum day length for crop development [0..24 h, R]\n  DLC = {{DLC}}           ! Minimum day length [0..24 h, R]\n\n* Specify vernalisation factor\n  VERNSAT = {{VERNSAT}}   ! saturated vernalisation requirement [0.0,100.0 d, R]\n  VERNBASE = {{VERNBASE}} ! base vernalisation requirement [0.0,100.0 d, R]\n  VERNDVS = {{VERNDVS}}   ! critical development stage after which the effect of vernalisation is halted [0.0,0.3 -, R]\n\n*  table with rate of vernalisation as function of average air temperature [d/oC]\n  VERNTB =\n{{#TABLE_VERNTB}}\n  {{TAV}} {{VERNRATE}}\n{{/TABLE_VERNTB}}\n* End of table\n{{/SWITCH_IDSL_OPTION_2}}\n\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 3: Initial values\n\n  TDWI = {{TDWI}}     ! Initial total crop dry weight [0..10000 kg/ha, R]\n  LAIEM = {{LAIEM}}   ! Leaf area index at emergence [0..10 m2/m2, R]\n  RGRLAI = {{RGRLAI}} ! Maximum relative increase in LAI [0..1 m2/m2/d, R]\n\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 4: Green surface area\n\n  SPA = {{SPA}}     ! Specific pod area  [0..1 ha/kg, R]\n  SSA = {{SSA}}     ! Specific stem area [0..1 ha/kg, R]\n  SPAN = {{SPAN}}   ! Life span under leaves under optimum conditions  [0..366 d, R]\n  TBASE = {{TBASE}} ! Lower threshold temperature for ageing of leaves [-10..30 oC, R]\n\n* List specific leaf area [0..1 ha/kg, R] as function of crop development stage [0..2 -, R]\n*   DVS     SLA    (maximum 15 records)\n  SLATB =\n{{#TABLE_SLATB}}\n  {{DVS}} {{SLA}}\n{{/TABLE_SLATB}}\n* End of table \n\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 5: Assimilation\n\n  KDIF = {{KDIF}} ! Extinction coefficient for diffuse visible light [0..2 -, R]\n  KDIR = {{KDIR}} ! Extinction coefficient for direct visible light  [0..2 -, R]\n  EFF = {{EFF}}   ! Light use efficiency for real leaf [0..10 kg/ha/hr/(Jm2s), R]\n\n* List maximum CO2 assimilation rate [0..100 kg/ha/hr, R] as function of development stage [0..2 -, R]\n*   DVS    AMAX   (maximum 15 records)\n  AMAXTB =\n{{#TABLE_AMAXTB}}\n  {{DVS}} {{AMAX}}\n{{/TABLE_AMAXTB}}\n* End of table \n\n* List reduction factor of AMAX [-, R] as function of average day temperature [-10..50 oC, R]\n*   TAVD   TMPF  (maximum 15 records)\n  TMPFTB =\n{{#TABLE_TMPFTB}}\n  {{TAVD}} {{TMPF}}\n{{/TABLE_TMPFTB}}\n* End of table \n\n* List reduction factor of AMAX [-, R] as function of minimum day temperature [-10..50 oC, R]\n*   TMNR    TMNF  (maximum 15 records)\n  TMNFTB =\n{{#TABLE_TMNFTB}}\n  {{TMNR}} {{TMNF}}\n{{/TABLE_TMNFTB}}\n* End of table \n\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 6: Conversion of assimilates into biomass\n\n  CVL = {{CVL}} ! Efficiency of conversion into leaves [0..1 kg/kg, R]\n  CVO = {{CVO}} ! Efficiency of conversion into storage organs [0..1 kg/kg, R]\n  CVR = {{CVR}} ! Efficiency of conversion into roots [0..1 kg/kg, R]\n  CVS = {{CVS}} ! Efficiency of conversion into stems [0..1 kg/kg, R]\n\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 7: Maintenance respiration\n\n  Q10 = {{Q10}} ! Increase in respiration rate with temperature  [0..5 /10 oC, R]\n  RML = {{RML}} ! Maintenance respiration rate of leaves [0..1 kgCH2O/kg/d, R]\n  RMO = {{RMO}} ! Maintenance respiration rate of storage organs [0..1 kgCH2O/kg/d, R]\n  RMR = {{RMR}} ! Maintenance respiration rate of roots [0..1 kgCH2O/kg/d, R]\n  RMS = {{RMS}} ! Maintenance respiration rate of stems [0..1 kgCH2O/kg/d, R]\n\n* List reduction factor of senescence [-, R] as function of development stage [0..2 -, R]\n*   DVS    RFSE  (maximum 15 records)\n  RFSETB = \n{{#TABLE_RFSETB}}\n  {{DVS}} {{RFSE}}\n{{/TABLE_RFSETB}}\n* End of table \n\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 8: Partitioning\n\n* List fraction of total dry matter increase partitioned to the roots [kg/kg, R]\n* as function of development stage [0..2 -, R]\n*   DVS     FR    (maximum 15 records)\n  FRTB = \n{{#TABLE_FRTB}}\n  {{DVS}} {{FR}}\n{{/TABLE_FRTB}}\n* End of table \n\n* List fraction of total above ground dry matter increase partitioned to the leaves [kg/kg, R]\n* as function of development stage [0..2 -, R]\n*   DVS     FL   (maximum 15 records)\n  FLTB = \n{{#TABLE_FLTB}}\n  {{DVS}} {{FL}}\n{{/TABLE_FLTB}}\n* End of table \n\n* List fraction of total above ground dry matter increase partitioned to the stems [kg/kg, R]\n* as function of development stage [0..2 -, R]\n*   DVS    FS   (maximum 15 records)\n  FSTB = \n{{#TABLE_FSTB}}\n  {{DVS}} {{FS}}\n{{/TABLE_FSTB}}\n* End of table \n\n* List fraction of total above ground dry matter increase partitioned to the storage organs [kg/kg, R]\n* as function of development stage [0..2 -, R]\n*   DVS    FO    (maximum 15 records)\n  FOTB = \n{{#TABLE_FOTB}}\n  {{DVS}} {{FO}}\n{{/TABLE_FOTB}}\n* End of table\n\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 9: Death rates\n\n  PERDL = {{PERDL}}          ! Maximum relative death rate of leaves due to water stress [0..3 /d, R]\n\n* List relative death rates of roots [kg/kg/d] as function of development stage [0..2 -, R]\n*   DVS    RDRR    (maximum 15 records)\n  RDRRTB = \n{{#TABLE_RDRRTB}}\n  {{DVS}} {{RDRR}}\n{{/TABLE_RDRRTB}}\n* End of table\n\n* List relative death rates of stems [kg/kg/d] as function of development stage [0..2 -, R]\n*   DVS     RDRS    (maximum 15 records)\n  RDRSTB = \n{{#TABLE_RDRSTB}}\n  {{DVS}} {{RDRS}}\n{{/TABLE_RDRSTB}}\n* End of table\n\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 10: Root growth and root density profile\n\n* Switch development of root growth\n  SWRD = {{SWRD}}            ! 1 = Root growth depends on development stage\n                             ! 2 = Root growth depends on maximum daily increase\n                             ! 3 = Root growth depends on available root biomass\n\n{{#SWITCH_SWRD_OPTION_1}}\n* If case of dependency development stage (SWRD=1), specify:\n* List Rooting Depth [0..1000 cm, R], as a function of development stage [0..2 -, R]:\n\n*  DVS   RD\n  RDTB =\n{{#TABLE_RDTB}}\n  {{DVS}} {{RD}}\n{{/TABLE_RDTB}}\n* End of table\n{{/SWITCH_SWRD_OPTION_1}}\n{{#SWITCH_SWRD_OPTION_2}}\n* If case of dependency maximum daily increase (SWRD=2), specify:\n  RDI = {{RDI}}              ! Initial rooting depth [0..1000 cm, R]\n  RRI = {{RRI}}              ! Maximum daily increase in rooting depth [0..100 cm/d, R]\n  RDC = {{RDC}}              ! Maximum rooting depth of particular crop [0..1000 cm, R]\n\n* Switch for calculation rooting depth:\n  SWDMI2RD = {{SWDMI2RD}}    ! 0 = Rooting depth increase is related to availability assimilates for roots\n                             ! 1 = Rooting depth increase is related to relative dry matter increase\n\n{{/SWITCH_SWRD_OPTION_2}}\n{{#SWITCH_SWRD_OPTION_3}}\n* In case of dependency available root biomass (SWRD=3), specify:\n* List rooting depth [0..5000 cm, R] as function of root weight [0..5000 kg DM/ha, R]:\n*   RW     RD\n  RLWTB =\n{{#TABLE_RLWTB}}\n  {{RW}} {{RD}}\n{{/TABLE_RLWTB}}\n* End of table\n\n  WRTMAX = {{WRTMAX}}        ! Maximum root weight [0..1d5 kg DM/ha, R]                \n{{/SWITCH_SWRD_OPTION_3}}\n\n* Always specify:\n* Switch for calculation of relative root density (default SWRDC = 1):\n  SWRDC = {{SWRDC}}          ! 0 = Root density is not modified\n                             ! 1 = Root density is modified based on root water extraction\n\n* List root density [0..100 cm/cm3, R] as function of relative rooting depth [0..1 -, R]:\n* In case of drought stress according to Feddes et al. (1978) (SWDROUGHT = 1), relative root density (-) is sufficient\n\n*   RRD    RDENS\n  RDCTB =\n{{#TABLE_RDCTB}}\n  {{RRD}} {{RDENS}}\n{{/TABLE_RDCTB}}\n* End of table\n\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 11: Oxygen stress\n\n* Switch for oxygen stress:\n  SWOXYGEN = {{SWOXYGEN}}    ! 0 = No oxygen stress\n                             ! 1 = Oxygen stress according to Feddes et al. (1978)\n                             ! 2 = Oxygen stress according to Bartholomeus et al. (2008)\n\n* Switch for checking aerobic conditions in root zone to stop root(zone) development\n  SWWRTNONOX = {{SWWRTNONOX}} ! 0 = Do not check for aerobic conditions\n                             ! 1 = Check for aerobic conditions\n\n{{#SWITCH_SWWRTNONOX_OPTION_1}}\n  AERATECRIT = {{AERATECRIT}} ! Threshold to stop root extension in case of oxygenstress; 0.0 maximum oxygen stress [0.0001..1.0 -, R]\n\n{{/SWITCH_SWWRTNONOX_OPTION_1}}\n{{#SWITCH_SWOXYGEN_OPTION_1}}\n* If SWOXYGEN=1, specify:\n  HLIM1 = {{HLIM1}}          ! No water extraction at higher pressure heads [-100..100 cm, R]\n  HLIM2U = {{HLIM2U}}        ! H below which optimum water extr. starts for top layer [-1000..100 cm, R]\n  HLIM2L = {{HLIM2L}}        ! H below which optimum water extr. starts for sub layer [-1000..100 cm, R]\n{{/SWITCH_SWOXYGEN_OPTION_1}}\n{{#SWITCH_SWOXYGEN_OPTION_2}}\n* If SWOXYGEN=2, specify:\n  Q10_MICROBIAL = {{Q10_MICROBIAL}} ! Relative increase in microbial respiration at temperature increase of 10 C [1.0..4.0 -, R]\n  SPECIFIC_RESP_HUMUS = {{SPECIFIC_RESP_HUMUS}} ! Respiration rate of humus at 25 C [0.0..1.0 kg O2/kg C/d, R] \n  SRL = {{SRL}}              ! Specific root length [0.0..1.d10 m root/kg root, R]      \n\n* Switch for calculation of root radius:  \n  SWROOTRADIUS = {{SWROOTRADIUS}} ! 1 = Calculate root radius\n                             ! 2 = Root radius is given in input file\n\n{{#SWITCH_SWROOTRADIUS_OPTION_1}}\n* If SWROOTRADIUS=1, specify:\n  DRY_MAT_CONT_ROOTS = {{DRY_MAT_CONT_ROOTS}} ! Dry matter content of roots [0.0..1.0 -, R]\n  AIR_FILLED_ROOT_POR = {{AIR_FILLED_ROOT_POR}} ! Air filled root porosity [0.0..1.0 -, R]\n  SPEC_WEIGHT_ROOT_TISSUE = {{SPEC_WEIGHT_ROOT_TISSUE}} ! Specific weight of non-airfilled root tissue [0.0..1.d5 kg root/m3 root, R]\n  VAR_A = {{VAR_A}}          ! Variance of root radius [0.0..1.0 -, R]\n{{/SWITCH_SWROOTRADIUS_OPTION_1}}\n{{#SWITCH_SWROOTRADIUS_OPTION_2}}\n* If SWROOTRADIUS=2, specify:\n  ROOT_RADIUSO2 = {{ROOT_RADIUSO2}} ! Root radius for oxygen stress module [1d-6..0.1 m, R]\n{{/SWITCH_SWROOTRADIUS_OPTION_2}}\n{{/SWITCH_SWOXYGEN_OPTION_2}}\n\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 12: Drought stress\n\n* Switch for drought stress:\n  SWDROUGHT = {{SWDROUGHT}}  ! 1 = Drought stress according to Feddes et al. (1978)\n                             ! 2 = Drought stress according to De Jong van Lier et al. (2008)\n\n{{#SWITCH_SWDROUGHT_OPTION_1}}\n* If SWDROUGHT=1, or in case of irrigation scheduling (SCHEDULE = 1), specify:\n  HLIM3H = {{HLIM3H}}        ! Pressure head below which water uptake reduction starts at high Tpot [-1d4..100 cm, R]\n  HLIM3L = {{HLIM3L}}        ! Pressure head below which water uptake reduction starts at low Tpot  [-1d4..100 cm, R]\n  HLIM4 = {{HLIM4}}          ! No water extraction at lower soil water pressure heads [-1.6d4..100 cm, R]\n  ADCRH = {{ADCRH}}          ! Level of high atmospheric demand, corresponding to HLIM3H [0..5 cm/d, R]     \n  ADCRL = {{ADCRL}}          ! Level of low atmospheric demand, corresponding to HLIM3L [0..5 cm/d, R]     \n{{/SWITCH_SWDROUGHT_OPTION_1}}\n{{#SWITCH_SWDROUGHT_OPTION_2}}\n* If SWDROUGHT=2, specify:\n  WILTPOINT  = {{WILTPOINT}} ! Minimum pressure head in leaves [-1d8..-1d2 cm, R]\n  KSTEM = {{KSTEM}}          ! Hydraulic conductance between leaf and root xylem [1d-10..10 /d, R]\n  RXYLEM = {{RXYLEM}}        ! Xylem radius [1d-4..1 cm, R]\n  ROOTRADIUS = {{ROOTRADIUS}} ! Root radius [1d-4..1 cm, R]\n  KROOT = {{KROOT}}          ! Radial hydraulic conductivity of root tissue [1d-10..1d10 cm/d, R] \n  ROOTCOEFA  = {{ROOTCOEFA}} ! Defines relative distance between roots at which mean soil water content occurs [0..1 -, R]\n  SWHYDRLIFT = {{SWHYDRLIFT}} ! Switch for possibility hydraulic lift in root system [N=0, Y=1]\n  ROOTEFF = {{ROOTEFF}}      ! Root system efficiency factor [0..1 -, R]\n  STEPHR = {{STEPHR}}        ! Step between values of hroot and hxylem in iteration cycle [0..10 cm, R]\n  CRITERHR = {{CRITERHR}}    ! Maximum difference of Hroot between iterations; convergence criterium [0..10 cm, R]\n  TACCUR = {{TACCUR}}        ! Maximum absolute difference between simulated and calculated potential transpiration rate (1d-5..1d-2 cm/d, R)\n{{/SWITCH_SWDROUGHT_OPTION_2}}\n\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 13: salt stress\n\n* Switch salinity stress\n  SWSALINITY = {{SWSALINITY}} ! 0 = No salinity stress\n                             ! 1 = Maas and Hoffman reduction function\n                             ! 2 = Use osmotic head\n\n{{#SWITCH_SWSALINITY_OPTION_1}}\n* If SWSALINITY = 1, specify threshold and slope of Maas and Hoffman\n  SALTMAX = {{SALTMAX}}      ! Threshold salt concentration in soil water  [0..100 mg/cm3, R] \n  SALTSLOPE = {{SALTSLOPE}}  ! Decline of root water uptake above threshold [0..1.0 cm3/mg, R] \n{{/SWITCH_SWSALINITY_OPTION_1}}\n{{#SWITCH_SWSALINITY_OPTION_2}}\n* If SWSALINITY = 2, specify:\n  SALTHEAD = {{SALTHEAD}}    ! Conversion factor salt concentration (mg/cm3) into osmotic head (cm) [0..1000 cm/(mg/cm3), R]\n{{/SWITCH_SWSALINITY_OPTION_2}}\n\n**********************************************************************************\n\n**********************************************************************************\n* Part xx: compensation of root water uptake stress\n\n* Switch for compensation root water uptake stress\n  SWCOMPENSATE = {{SWCOMPENSATE}} ! 0 = No compensation\n                             ! 1 = Compensation according to Jarvis (1989)\n                             ! 2 = Compensation according to Walsum (2019)\n\n{{#SWITCH_SWCOMPENSATE_OPTION_1}}\n* Switch for selection of stressors to compensate\n  SWSTRESSOR = {{SWSTRESSOR}} ! 1 = Compensation of all stressors\n                             ! 2 = Compensation of drought stress\n                             ! 3 = Compensation of oxygen stress\n                             ! 4 = Compensation of salinity stress\n                             ! 5 = Compensation of frost stress\n\n* If SWCOMPENSATE = 1, specify:\n  ALPHACRIT = {{ALPHACRIT}}  ! Critical stress index for compensation of root water uptake [0.2..1 -, R]\n\n{{/SWITCH_SWCOMPENSATE_OPTION_1}}\n{{#SWITCH_SWCOMPENSATE_OPTION_2}}\n* Switch for selection of stressors to compensate\n  SWSTRESSOR = {{SWSTRESSOR}} ! 1 = Compensation of all stressors\n                             ! 2 = Compensation of drought stress\n                             ! 3 = Compensation of oxygen stress\n                             ! 4 = Compensation of salinity stress\n                             ! 5 = Compensation of frost stress\n\n* If SWCOMPENSATE = 2, specify:\n  DCRITRTZ = {{DCRITRTZ}}    ! Threshold of rootzone thickness after which compensation occurs [0.02..100 cm, R]\n\n{{/SWITCH_SWCOMPENSATE_OPTION_2}}\n**********************************************************************************\n\n**********************************************************************************\n* Part 14: interception                                            \n\n* For agricultural crops apply interception concept of Von Hoyningen-Hune and Braden\n* Switch for rainfall interception method:\n  SWINTER = {{SWINTER}}      ! 0 = No interception calculated\n                             ! 1 = Agricultural crops (Von Hoyningen-Hune and Braden)\n                             ! 2 = Trees and forests (Gash)\n\n{{#SWITCH_SWINTER_OPTION_1}}\n* In case of agricultural crops (SWINTER=1) specify:\n  COFAB = {{COFAB}}          ! Interception coefficient, corresponding to maximum interception amount [0..1 cm, R]\n{{/SWITCH_SWINTER_OPTION_1}}\n{{#SWITCH_SWINTER_OPTION_2}}\n* In case of closed forest canopies (SWINTER=2), specify as function of time T [0..366 d, R]:\n* PFREE = Free throughfall coefficient [0..1 -, R]\n* PSTEM = Stem flow coefficient [0..1 -, R]\n* SCANOPY = Storage capacity of canopy [0..10 cm, R]\n* AVPREC = Average rainfall intensity [0..100 cm/d, R]\n* AVEVAP = Average evaporation intensity during rainfall from a wet canopy [0..10 cm/d, R]\n\n{{#TABLE_INTERTB}}\n  {{T}} {{PFREE}} {{PSTEM}} {{SCANOPY}} {{AVPREC}} {{AVEVAP}}\n{{/TABLE_INTERTB}}\n* End of table\n{{/SWITCH_SWINTER_OPTION_2}}\n\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 15: CO2-impact\n*\n* CO2-impact:\n*    correction of photosynthesis as a function of atmospheric CO2 concentration (-)\n*    correction of radiation use efficiency as a function of atmospheric CO2 concentration (-)\n*    correction of transpiration as a function of atmospheric CO2 concentration (-)\n*    values for C3 crops (potatoes, grassland, soybean)\n*    actual CO2 concentration in atmosphere [ppm] in separate file atmospheric.co2\n**********************************************************************************\n\n* Switch for assimilation correction due to CO2 impact\n  SWCO2 = {{SWCO2}}          ! 0 = No CO2 assimilation correction\n                             ! 1 = CO2 assimilation correction\n\n{{#SWITCH_SWCO2_OPTION_1}}\n* if SWCO2=1, specify:\n  ATMOFIL = {{ATMOFIL}}      ! alternative filename for atmosphere.co2\n\n* Correction of photosynthesis as a function of atmospheric CO2 concentration\n  CO2AMAXTB =\n{{#TABLE_CO2AMAXTB}}\n  {{CO2}} {{AMAX}}\n{{/TABLE_CO2AMAXTB}}\n* End of table\n\n* Correction of radiation use efficiency as a function of atmospheric CO2 concentration:\n  CO2EFFTB =\n{{#TABLE_CO2EFFTB}}\n  {{CO2}} {{EFF}}\n{{/TABLE_CO2EFFTB}}\n* End of table\n\n* Correction of transpiration as a function of atmospheric CO2 concentration:\n  CO2TRATB =  \n{{#TABLE_CO2TRATB}}\n  {{CO2}} {{TRA}}\n{{/TABLE_CO2TRATB}}\n* End of table\n\n{{/SWITCH_SWCO2_OPTION_1}}\n**********************************************************************************\n\n*** MANAGEMENT SECTION ***\n\n**********************************************************************************\n* Part 1: Nitrogen use\n\n* Data from: Linutl4,  http://models.pps.wur.nl/models\n*                      param values from MAG202.DATo\n*      reference:    Wolf, J. (2012). Users guide for LINTUL4 and LINTUL4V: \n*                    Simple generic model for simulation of crop growth under \n*                    potential, water limited and nitrogen limited conditions. \n*                    WUR-PPS report (Vol. 4).\n RDRNS = {{RDRNS}}   ! Maximum relative death rate of leaves due to N stress [0.0..1.0 /d, R]\n DVSNLT = {{DVSNLT}} ! Development stage above which no crop nitrogen uptake does occur [0.0..2.0 -, R]\n DVSNT = {{DVSNT}}   ! Development stage above which nitrogen translocation to storage organs does occur [0.0..2.0 -, R]\n FNTRT = {{FNTRT}}   ! Nitrogen translocation from roots as a fraction of total N amount translocated from leaves and stems [0.0..1.0 -, R]\n FRNX = {{FRNX}}     ! Optimal N concentration as fraction of maximum N concentration [0.0..1.0 -, R]\n LRNR = {{LRNR}}     ! Maximum N concentration in roots as fraction of maximum N concentration in leaves [0.0..1.0 -, R]\n LSNR = {{LSNR}}     ! Maximum N concentration in stems as fraction of maximum N concentration in leaves [0.0..1.0 -, R]\n NLAI = {{NLAI}}     ! Coefficient for the reduction due to N stress of the LAI increase (during juvenile phase) [0.0..2.0 -, R]\n NLUE = {{NLUE}}     ! Coefficient for the reduction of RUE due to Nitrogen stress [0.0..2.0 -, R]\n NMAXSO = {{NMAXSO}} ! Maximum N concentration in storage organs [0.0..1.0 kg kg-1, R]\n NPART = {{NPART}}   ! Coefficient for the effect of N stress on leaf biomass reduction [0.0..2.0 -, R]\n NSLA = {{NSLA}}     ! Coefficient for the effect of N stress on SLA reduction [0.0..2.0 -, R]\n RNFLV = {{RNFLV}}   ! Residual N fraction in leaves [0.0..1.0 kg kg-1, R]\n RNFST = {{RNFST}}   ! Residual N fraction in stems [0.0..1.0 kg kg-1, R]\n RNFRT = {{RNFRT}}   ! Residual N fraction in roots [0.0..1.0 kg kg-1, R]\n TCNT = {{TCNT}}     ! Time coefficient for N translocation to storage organs [0.0..100.0 d, R]\n NFIXF = {{NFIXF}}   ! Fraction of crop nitrogen uptake by biological fixation [0.0..1.0 -, R]\n\n* Maximum N concentration in leaves as function of development stage [0.0..1.0 kg kg-1, R]\n  NMXLV =\n{{#TABLE_NMXLV}}\n  {{DVS}} {{NMXLV}}\n{{/TABLE_NMXLV}}\nEnd of table\n\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 2: Losses of organic matter\n\n* Harvest losses of organic matter \n  FRAHARLOSORM_LV = {{FRAHARLOSORM_LV}} ! Fraction harvest losses of organic matter from leaves [0.0..1.0 kg kg-1, R]\n  FRAHARLOSORM_ST = {{FRAHARLOSORM_ST}} ! Fraction harvest losses of organic matter from stems [0.0..1.0 kg kg-1, R]\n  FRAHARLOSORM_SO = {{FRAHARLOSORM_SO}} ! Fraction harvest losses of organic matter from storage organs [0.0..1.0 kg kg-1, R]\n\n* Losses of organic matter \n  FRADECEASEDLVTOSOIL = {{FRADECEASEDLVTOSOIL}} ! Fraction of deceased leaves incorporated in soil  [0..1.0 kg kg-1, R]\n\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 3: Management, other than irrigation, for instance pests,diseases or nutrients\n\n* Switch for calculation of potential yield\n  SWPOTRELMF = {{SWPOTRELMF}} ! 1 = Theoretical potential yield\n                             ! 2 = Attainable yield\n\n* In case of pest, diseases or nutrients, specify:\n  RELMF = {{RELMF}}          ! Relative management factor to reduce theoretical potential yield to attainable yield [0..1 -, R]\n\n**********************************************************************************\n\n*** IRRIGATION SCHEDULING SECTION ***\n\n**********************************************************************************\n* Part 1: General\n\n  SCHEDULE = {{SCHEDULE}}    ! Switch for application irrigation scheduling [Y=1, N=0] \n\n{{#SWITCH_SCHEDULE_OPTION_1}}\n* If SCHEDULE = 1, specify:\n  STARTIRR = {{STARTIRR}}    ! Specify day and month at which irrigation scheduling starts [dd mm]\n  ENDIRR = {{ENDIRR}}        ! Specify day and month at which irrigation scheduling stops [dd mm]\n  CIRRS = {{CIRRS}}          ! Solute concentration of irrigation water [0..100 mg/cm3, R]\n\n* Switch for type of irrigation method: \n  ISUAS = {{ISUAS}}          ! 0 = Sprinkling irrigation\n                             ! 1 = Surface irrigation\n\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 2: Irrigation time criteria\n\n* Choose one of the following timing criteria options [1..6 -, I]:\n  TCS = {{TCS}}              ! 1 = Ratio actual/potential transpiration\n                             ! 2 = Depletion of Readily Available Water\n                             ! 3 = Depletion of Totally Available Water\n                             ! 4 = Depletion of absolute Water Amount\n                             ! 6 = Fixed weekly irrigation\n                             ! 7 = Pressure head\n                             ! 8 = Moisture content\n\n{{#SWITCH_TCS_OPTION_1}}\n* Ratio actual/potential transpiration (TCS = 1)\n* Specify mimimum of ratio actual/potential transpiration TREL [0..1 -, R] as function of crop development stage\n{{#TABLE_TC1TB}}\n  {{DVS_TC1}} {{TREL}}\n{{/TABLE_TC1TB}}\n* End of table\n{{/SWITCH_TCS_OPTION_1}}\n{{#SWITCH_TCS_OPTION_2}}\n* Depletion of Readily Available Water (TCS = 2) \n* Specify minimum fraction of readily available water RAW [0..1 -, R] as function of crop development stage\n{{#TABLE_TC2TB}}\n  {{DVS_TC2}} {{RAW}}\n{{/TABLE_TC2TB}}\n* End of table\n\n  PHFIELDCAPACITY = {{PHFIELDCAPACITY}} ! Soil water pressure head at field capacity [-1000..0 cm, R]\n{{/SWITCH_TCS_OPTION_2}}\n{{#SWITCH_TCS_OPTION_3}}\n* Depletion of Totally Available Water (TCS = 3)\n* Specify minimal fraction of totally available water TAW [0..1 -, R] as function of crop development stage\n{{#TABLE_TC3TB}}\n  {{DVS_TC3}} {{TAW}}\n{{/TABLE_TC3TB}}\n* End of table\n\n  PHFIELDCAPACITY = {{PHFIELDCAPACITY}} ! Soil water pressure head at field capacity [-1000..0 cm, R]\n{{/SWITCH_TCS_OPTION_3}}\n{{#SWITCH_TCS_OPTION_4}}\n* Depletion of absolute Water Amount (TCS = 4)\n* Specify maximum amount of water depleted below field capacity DWA [0..500 mm, R] as function of crop development stage\n{{#TABLE_TC4TB}}\n  {{DVS_TC4}} {{DWA}}\n{{/TABLE_TC4TB}}\n* End of table\n\n  PHFIELDCAPACITY = {{PHFIELDCAPACITY}} ! Soil water pressure head at field capacity [-1000..0 cm, R]\n{{/SWITCH_TCS_OPTION_4}}\n{{#SWITCH_TCS_OPTION_6}}\n* Fixed weekly irrigation (TCS = 6)\n* Only irrigate when soil water deficit in root zone is larger than threshold\n  IRGTHRESHOLD = {{IRGTHRESHOLD}} ! Threshold value for weekly irrigation  [0..20 mm, R]\n{{/SWITCH_TCS_OPTION_6}}\n{{#SWITCH_TCS_OPTION_7}}\n* Pressure head (TCS = 7)\n* Specify critical pressure head [-1d6..-100 cm, R] as function of crop development stage:\n{{#TABLE_TC7TB}}\n  {{DVS_TC7}} {{HCRI}}\n{{/TABLE_TC7TB}}\n* End of table\n\n  DCRIT =  {{DCRIT}}         ! Depth of the sensor [-100..0 cm, R]\n\n* In case TCS = 7, over-irrigation can be applied if the salinity concentration exceeds a threshold salinity\n* Switch for over-irrigation:\n  SWCIRRTHRES = {{SWCIRRTHRES}} ! 0 = No over-irrigation\n                             ! 1 = Apply over-irrigation\n\n{{#SWITCH_SWCIRRTHRES_OPTION_1}}\n* If SWCIRRTHRES = 1, specify:\n  CIRRTHRES = {{CIRRTHRES}}  ! Threshold salinity concentration above which over-irrigation occurs [0..100 mg/cm3, R]\n  PERIRRSURP = {{PERIRRSURP}} ! Over-irrigation of the usually scheduled irrigation depth [0..100 %, R]\n{{/SWITCH_SWCIRRTHRES_OPTION_1}}\n{{/SWITCH_TCS_OPTION_7}}\n{{#SWITCH_TCS_OPTION_8}}\n* Moisture content (TCS = 8)\n* Specify critical moisture content [0..1 cm3/cm3, R] as function of crop development stage\n{{#TABLE_TC8TB}}\n  {{DVS_TC8}} {{TCRI}}\n{{/TABLE_TC8TB}}\n* End of table\n\n  DCRIT =  {{DCRIT}}         ! Depth of the sensor [-100..0 cm, R]\n\n* In case TCS = 8, over-irrigation can be applied if the salinity concentration exceeds a threshold salinity\n* Switch for over-irrigation:\n  SWCIRRTHRES = {{SWCIRRTHRES}} ! 0 = No over-irrigation\n                                  ! 1 = Apply over-irrigation\n\n{{#SWITCH_SWCIRRTHRES_OPTION_1}}\n* If SWCIRRTHRES = 1, specify:\n  CIRRTHRES = {{CIRRTHRES}}  ! Threshold salinity concentration above which over-irrigation occurs [0..100 mg/cm3, R]\n  PERIRRSURP = {{PERIRRSURP}} ! Over-irrigation of the usually scheduled irrigation depth [0..100 %, R]\n{{/SWITCH_SWCIRRTHRES_OPTION_1}}\n{{/SWITCH_TCS_OPTION_8}}\n\n* Switch for minimum time interval between irrigation applications\n  TCSFIX = {{TCSFIX}}        ! 0 = No minimum time interval\n                             ! 1 = Define minimum time interval\n{{#SWITCH_TCSFIX_OPTION_1}}\n\n* If TCSFIX = 1, specify:\n  IRGDAYFIX = {{IRGDAYFIX}}  ! Minimum number of days between irrigation applications [1..366 d, I]\n{{/SWITCH_TCSFIX_OPTION_1}}\n\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 3: Irrigation depth criteria\n\n* Choose one of the following two options for irrigation depth:\n  DCS = {{DCS}}              ! 1 = Back to field capacity\n                             ! 2 = Fixed Irrigation Depth\n\n{{#SWITCH_DCS_OPTION_1}}\n{{#SWITCH_TCS_OPTION_1}}\n* Specify pressure head at field capacity\n  PHFIELDCAPACITY = {{PHFIELDCAPACITY}} ! Soil water pressure head at field capacity [-1000..0 cm, R] \n\n{{/SWITCH_TCS_OPTION_1}}\n{{#SWITCH_TCS_OPTION_6}}\n* Specify pressure head at field capacity\n  PHFIELDCAPACITY = {{PHFIELDCAPACITY}} ! Soil water pressure head at field capacity [-1000..0 cm, R] \n\n{{/SWITCH_TCS_OPTION_6}}\n{{#SWITCH_TCS_OPTION_7}}\n* Specify pressure head at field capacity\n  PHFIELDCAPACITY = {{PHFIELDCAPACITY}} ! Soil water pressure head at field capacity [-1000..0 cm, R] \n\n{{/SWITCH_TCS_OPTION_7}}\n{{#SWITCH_TCS_OPTION_8}}\n* Specify pressure head at field capacity\n  PHFIELDCAPACITY = {{PHFIELDCAPACITY}} ! Soil water pressure head at field capacity [-1000..0 cm, R] \n\n{{/SWITCH_TCS_OPTION_8}}\n* Specify amount of under (-) or over (+) irrigation DI [-100..100 mm, R] as function of crop development stage [0..2, R]:\n{{#TABLE_DC1TB}}\n  {{DVS_DC1}} {{DI}}\n{{/TABLE_DC1TB}}\n* End of table\n\n  RAITHRESHOLD = {{RAITHRESHOLD}} ! When rainfall exceeds RAITHRESHOLD, DI is added to back to field capacity [0..1000 cm, R]\n  {{/SWITCH_DCS_OPTION_1}}\n{{#SWITCH_DCS_OPTION_2}}\n* Specify fixed irrigation depth FID [0..400 mm, R] as function of crop development stage [0..2, R]:\n{{#TABLE_DC2TB}}\n  {{DVS_DC2}} {{FID}}\n{{/TABLE_DC2TB}}\n* End of table\n{{/SWITCH_DCS_OPTION_2}}\n\n* Select minimum and maximum of irrigation depths:\n  DCSLIM = {{DCSLIM}}        ! Switch, limit range irrigation depth  [Y=1, N=0]\n\n{{#SWITCH_DCSLIM_OPTION_1}}\n* If DCSLIM = 1, specify:\n  IRGDEPMIN = {{IRGDEPMIN}}  ! Minimum irrigation depth [0..100 mm, I]\n  IRGDEPMAX = {{IRGDEPMAX}}  ! Maximum irrigation depth [IRGDEPMIN..1d7 mm, I]\n\n{{/SWITCH_DCSLIM_OPTION_1}}\n{{/SWITCH_SCHEDULE_OPTION_1}}\n**********************************************************************************\n\n* End of .crp file !\n</code></pre>","boost":0.5},{"location":"wiki/input-files/5-dra-file/","title":".DRA","text":"<p>There are two types of drainage files: simple and extended. The templates can be found below.</p>","boost":0.5},{"location":"wiki/input-files/5-dra-file/#simple_drainage","title":"Simple drainage","text":"DRFIL_BASIC.template <pre><code>**********************************************************************************\n* Filename: swap.dra                  \n* Contents: SWAP 4 - Input data for basic and extended drainage\n**********************************************************************************\n* Comment area:\n* Testbank of SWAP: build with template of dra-file\n*\n**********************************************************************************\n\n*** BASIC DRAINAGE SECTION ***\n\n**********************************************************************************\n* Part 0: General\n\n* Switch, method of lateral drainage calculation:\n  DRAMET = {{DRAMET}}        ! 1 = Use table of drainage flux - groundwater level relation\n                             ! 2 = Use drainage formula of Hooghoudt or Ernst\n                             ! 3 = Use drainage/infiltration resistance, multi-level if needed\n\n  SWDIVD = {{SWDIVD}}        ! Calculate vertical distribution of drainage flux in groundwater [Y=1, N=0]\n\n{{#SWITCH_SWDIVD_OPTION_1}}\n* If SWDIVD = 1, specify anisotropy factor COFANI (horizontal/vertical saturated hydraulic\n* conductivity) for each soil layer (maximum MAHO), [0.0001..1000 -, R]:\n  COFANI = {{COFANI}}\n{{/SWITCH_SWDIVD_OPTION_1}}\n\n* Switch to adjust upper boundary of model discharge layer\n  SWDISLAY = 0               ! switch to adjust discharge layer  [0,1,2, -, I]\n\n**********************************************************************************\n\n\n{{#SWITCH_DRAMET_OPTION_1}}\n**********************************************************************************\n* Part 1: Table of drainage flux - groundwater level relation (DRAMET = 1)\n\n{{#SWITCH_SWDIVD_OPTION_1}}\n* If SWDIVD = 1, specify the drain spacing:\n  LM1 = {{LM1}}              ! Drain spacing, [1..1000 m, R]\n\n{{/SWITCH_SWDIVD_OPTION_1}}\n* Specify drainage flux QDRAIN [-100..1000 cm/d, R] as function of groundwater level GWL [-1000.0..10.0 cm, R]\n* negative GWL is below soil surface; start with highest groundwater level; maximum of 25 records:\n\n{{#TABLE_QDRNTB}}\n  {{QDRAIN}} {{GWL}}\n{{/TABLE_QDRNTB}}\n* End of table                                             \n{{/SWITCH_DRAMET_OPTION_1}}\n{{#SWITCH_DRAMET_OPTION_2}}\n**********************************************************************************\n* Part 2: Drainage formula of Hooghoudt or Ernst (DRAMET = 2)\n*\n* Drain characteristics:\n  LM2    = {{LM2}}           ! Drain spacing, [1..1000 m, R]\n  SHAPE  = {{SHAPE_DRA}}     ! Shape factor to account for actual location between drain and water divide [0.0..1.0 -, R]\n  WETPER = {{WETPER}}        ! Wet perimeter of the drain, [0..1000 cm, R]\n  ZBOTDR = {{ZBOTDR}}        ! Level of drain bottom, [-1000..0 cm, R, neg. below soil surface]\n  ENTRES = {{ENTRES}}        ! Drain entry resistance, [0..1000 d, R]\n\n* Soil profile characteristics:\n\n* Position of drain:  \n  IPOS   = {{IPOS}}          ! 1 = On top of an impervious layer in a homogeneous profile          \n                             ! 2 = Above an impervious layer in a homogeneous profile              \n                             ! 3 = At the interface of a fine upper and a coarse lower soil layer\n                             ! 4 = In the lower, more coarse soil layer\n                             ! 5 = In the upper, more fine soil layer                                             \n\n* For all positions specify:\n  BASEGW = {{BASEGW}}        ! Level of impervious layer, [-1d4..0 cm, R]\n  KHTOP  = {{KHTOP}}         ! Horizontal hydraulic conductivity top layer, [0..1000 cm/d, R]\n\n{{#SWITCH_IPOS_OPTION_3}}\n* In addition, in case IPOS = 3\n  KHBOT  = {{KHBOT}}         ! horizontal hydraulic conductivity bottom layer, [0..1000 cm/d, R]\n  ZINTF  = {{ZINTF}}         ! Level of interface of fine and coarse soil layer, [-1d4..0 cm, R]\n{{/SWITCH_IPOS_OPTION_3}}\n{{#SWITCH_IPOS_OPTION_4}}\n* In addition, in case IPOS = 4\n  KHBOT  = {{KHBOT}}         ! horizontal hydraulic conductivity bottom layer, [0..1000 cm/d, R]\n  ZINTF  = {{ZINTF}}         ! Level of interface of fine and coarse soil layer, [-1d4..0 cm, R]\n  KVTOP  = {{KVTOP}}         ! Vertical hydraulic conductivity top layer, [0..1000 cm/d, R]\n  KVBOT  = {{KVBOT}}         ! Vertical hydraulic conductivity bottom layer, [0..1000 cm/d, R]\n{{/SWITCH_IPOS_OPTION_4}}\n{{#SWITCH_IPOS_OPTION_5}}\n* In addition, in case IPOS = 5\n  KHBOT  = {{KHBOT}}         ! horizontal hydraulic conductivity bottom layer, [0..1000 cm/d, R]\n  ZINTF  = {{ZINTF}}         ! Level of interface of fine and coarse soil layer, [-1d4..0 cm, R]\n  KVTOP  = {{KVTOP}}         ! Vertical hydraulic conductivity top layer, [0..1000 cm/d, R]\n  KVBOT  = {{KVBOT}}         ! Vertical hydraulic conductivity bottom layer, [0..1000 cm/d, R]\n  GEOFAC = {{GEOFAC}}        ! Geometry factor of Ernst,  [0..100 -, R]\n{{/SWITCH_IPOS_OPTION_5}}\n{{/SWITCH_DRAMET_OPTION_2}}\n{{#SWITCH_DRAMET_OPTION_3}}\n**********************************************************************************\n* METHOD 3 - Part 3: Drainage and infiltration resistance (DRAMET = 3)\n\n  NRLEVS = {{NRLEVS}}        ! Number of drainage levels, [1..5, I]\n\n* Option for interflow in highest drainage level (shallow system with short residence time)\n  SWINTFL = {{SWINTFL}}      ! Switch for interflow [0,1, I]\n\n{{#SWITCH_SWINTFL_OPTION_1}}\n* If SWINTFL = 1, specify:\n  COFINTFLB = {{COFINTFLB}}  ! Coefficient for interflow relation  [0.01..10.0 d, R]\n  EXPINTFLB = {{EXPINTFLB}}  ! Exponent for interflow relation  [0.1..1.0 -, R]\n\n{{#SWITCH_SWDIVD_OPTION_1}}\n* Switch to adjust the bottom of the model discharge layer in case of lateral interflow (SWDIVD=1).\n* In case of SWTOPNRSRF=1) then the bottom of the highest order drainage system (ZBORDR(NUMDRAIN)) represents the max depth of the interflow.  \n SWTOPNRSRF = {{SWTOPNRSRF}} ! Switch to enable adjustment of model discharge layer [0,1, I] \n\n{{/SWITCH_SWDIVD_OPTION_1}}\n{{/SWITCH_SWINTFL_OPTION_1}}\n**********************************************************************************\n\n{{#SWITCH_NRLEVS_OPTION_1}}\n**********************************************************************************\n* Part 3a: Drainage to level 1\n\n  DRARES1 = {{DRARES1}}      ! Drainage resistance, [10..1d5 d, R]\n  INFRES1 = {{INFRES1}}      ! Infiltration resistance, [0..1d5 d, R]\n\n* Switch, for allowance drainage/infiltration:\n  SWALLO1 = {{SWALLO1}}      ! 1 = Drainage and infiltration are both allowed\n                             ! 2 = Drainage is not allowed\n                             ! 3 = Infiltration is not allowed                          \n\n{{#SWITCH_SWDIVD_OPTION_1}}\n* If SWDIVD = 1 (drainage flux vertically distributed), specify the drain spacing:\n  L1 = {{L1}}                ! Drain spacing, [1..100000 m, R]\n\n{{/SWITCH_SWDIVD_OPTION_1}}\n  ZBOTDR1 = {{ZBOTDR1}}      ! Level of drainage medium bottom, [-10000..0 cm, R]\n  SWDTYP1 = {{SWDTYP1}}      ! Type of drainage medium: 1 = drain tube, 2 = open channel\n\n* Specify date DATOWL1 [date] and channel water level LEVEL1 [-10000..200, cm, R]\n* LEVEL1 is negative if below soil surface; maximum MAOWL records:\n\n{{#TABLE_DATOWLTB1}}\n  {{DATOWL1}} {{LEVEL1}}\n{{/TABLE_DATOWLTB1}}\n* End of table\n{{/SWITCH_NRLEVS_OPTION_1}}\n{{#SWITCH_NRLEVS_OPTION_2}}\n**********************************************************************************\n* Part 3a: Drainage to level 1\n\n  DRARES1 = {{DRARES1}}      ! Drainage resistance, [10..1d5 d, R]\n  INFRES1 = {{INFRES1}}      ! Infiltration resistance, [0..1d5 d, R]\n\n* Switch, for allowance drainage/infiltration:\n  SWALLO1 = {{SWALLO1}}      ! 1 = Drainage and infiltration are both allowed\n                             ! 2 = Drainage is not allowed\n                             ! 3 = Infiltration is not allowed                          \n\n{{#SWITCH_SWDIVD_OPTION_1}}\n* If SWDIVD = 1 (drainage flux vertically distributed), specify the drain spacing:\n  L1 = {{L1}}                ! Drain spacing, [1..100000 m, R]\n\n{{/SWITCH_SWDIVD_OPTION_1}}\n  ZBOTDR1 = {{ZBOTDR1}}      ! Level of drainage medium bottom, [-10000..0 cm, R]\n  SWDTYP1 = {{SWDTYP1}}      ! Type of drainage medium: 1 = drain tube, 2 = open channel\n\n* Specify date DATOWL1 [date] and channel water level LEVEL1 [-10000..200, cm, R]\n* LEVEL1 is negative if below soil surface; maximum MAOWL records:\n\n{{#TABLE_DATOWLTB1}}\n  {{DATOWL1}} {{LEVEL1}}\n{{/TABLE_DATOWLTB1}}\n* End of table\n\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 3b: Drainage to level 2\n\n  DRARES2 = {{DRARES2}}      ! Drainage resistance, [10..1d5 d, R]\n  INFRES2 = {{INFRES2}}      ! Infiltration resistance, [0..1d5 d, R]\n\n* Switch, for allowance drainage/infiltration:\n  SWALLO2 = {{SWALLO2}}      ! 1 = Drainage and infiltration are both allowed\n                             ! 2 = Drainage is not allowed\n                             ! 3 = Infiltration is not allowed                          \n\n{{#SWITCH_SWDIVD_OPTION_1}}\n* If SWDIVD = 1 (drainage flux vertically distributed), specify the drain spacing:\n  L2 = {{L2}}                ! Drain spacing, [1..100000 m, R]\n\n{{/SWITCH_SWDIVD_OPTION_1}}\n  ZBOTDR2 = {{ZBOTDR2}}      ! Level of drainage medium bottom, [-10000..0 cm, R]\n  SWDTYP2 = {{SWDTYP2}}      ! Type of drainage medium: 1 = drain tube, 2 = open channel\n\n* Specify date DATOWL2 [date] and channel water level LEVEL2 [-10000..200, cm, R]\n* LEVEL2 is negative if below soil surface; maximum MAOWL records:\n\n{{#TABLE_DATOWLTB2}}\n  {{DATOWL2}} {{LEVEL2}}\n{{/TABLE_DATOWLTB2}}\n* End of table\n{{/SWITCH_NRLEVS_OPTION_2}}\n{{#SWITCH_NRLEVS_OPTION_3}}\n**********************************************************************************\n* Part 3a: Drainage to level 1\n\n  DRARES1 = {{DRARES1}}      ! Drainage resistance, [10..1d5 d, R]\n  INFRES1 = {{INFRES1}}      ! Infiltration resistance, [0..1d5 d, R]\n\n* Switch, for allowance drainage/infiltration:\n  SWALLO1 = {{SWALLO1}}      ! 1 = Drainage and infiltration are both allowed\n                             ! 2 = Drainage is not allowed\n                             ! 3 = Infiltration is not allowed                          \n\n{{#SWITCH_SWDIVD_OPTION_1}}\n* If SWDIVD = 1 (drainage flux vertically distributed), specify the drain spacing:\n  L1 = {{L1}}                ! Drain spacing, [1..100000 m, R]\n\n{{/SWITCH_SWDIVD_OPTION_1}}\n  ZBOTDR1 = {{ZBOTDR1}}      ! Level of drainage medium bottom, [-10000..0 cm, R]\n  SWDTYP1 = {{SWDTYP1}}      ! Type of drainage medium: 1 = drain tube, 2 = open channel\n\n* Specify date DATOWL1 [date] and channel water level LEVEL1 [-10000..200, cm, R]\n* LEVEL1 is negative if below soil surface; maximum MAOWL records:\n\n{{#TABLE_DATOWLTB1}}\n  {{DATOWL1}} {{LEVEL1}}\n{{/TABLE_DATOWLTB1}}\n* End of table\n\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 3b: Drainage to level 2\n\n  DRARES2 = {{DRARES2}}      ! Drainage resistance, [10..1d5 d, R]\n  INFRES2 = {{INFRES2}}      ! Infiltration resistance, [0..1d5 d, R]\n\n* Switch, for allowance drainage/infiltration:\n  SWALLO2 = {{SWALLO2}}      ! 1 = Drainage and infiltration are both allowed\n                             ! 2 = Drainage is not allowed\n                             ! 3 = Infiltration is not allowed                          \n\n{{#SWITCH_SWDIVD_OPTION_1}}\n* If SWDIVD = 1 (drainage flux vertically distributed), specify the drain spacing:\n  L2 = {{L2}}                ! Drain spacing, [1..100000 m, R]\n\n{{/SWITCH_SWDIVD_OPTION_1}}\n  ZBOTDR2 = {{ZBOTDR2}}      ! Level of drainage medium bottom, [-10000..0 cm, R]\n  SWDTYP2 = {{SWDTYP2}}      ! Type of drainage medium: 1 = drain tube, 2 = open channel\n\n* Specify date DATOWL2 [date] and channel water level LEVEL2 [-10000..200, cm, R]\n* LEVEL2 is negative if below soil surface; maximum MAOWL records:\n\n{{#TABLE_DATOWLTB2}}\n  {{DATOWL2}} {{LEVEL2}}\n{{/TABLE_DATOWLTB2}}\n* End of table\n\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 3c: Drainage to level 3\n\n  DRARES3 = {{DRARES3}}      ! Drainage resistance, [10..1d5 d, R]\n  INFRES3 = {{INFRES3}}      ! Infiltration resistance, [0..1d5 d, R]\n\n* Switch, for allowance drainage/infiltration:\n  SWALLO3 = {{SWALLO3}}      ! 1 = Drainage and infiltration are both allowed\n                             ! 2 = Drainage is not allowed\n                             ! 3 = Infiltration is not allowed                          \n\n{{#SWITCH_SWDIVD_OPTION_1}}\n* If SWDIVD = 1 (drainage flux vertically distributed), specify the drain spacing:\n  L3 = {{L3}}                ! Drain spacing, [1..100000 m, R]\n\n{{/SWITCH_SWDIVD_OPTION_1}}\n  ZBOTDR3 = {{ZBOTDR3}}      ! Level of drainage medium bottom, [-10000..0 cm, R]\n  SWDTYP3 = {{SWDTYP3}}      ! Type of drainage medium: 1 = drain tube, 2 = open channel\n\n* Specify date DATOWL3 [date] and channel water level LEVEL3 [-10000..200, cm, R]\n* LEVEL3 is negative if below soil surface; maximum MAOWL records:\n\n{{#TABLE_DATOWLTB3}}\n  {{DATOWL3}} {{LEVEL3}}\n{{/TABLE_DATOWLTB3}}\n* End of table\n{{/SWITCH_NRLEVS_OPTION_3}}\n{{#SWITCH_NRLEVS_OPTION_4}}\n**********************************************************************************\n* Part 3a: Drainage to level 1\n\n  DRARES1 = {{DRARES1}}      ! Drainage resistance, [10..1d5 d, R]\n  INFRES1 = {{INFRES1}}      ! Infiltration resistance, [0..1d5 d, R]\n\n* Switch, for allowance drainage/infiltration:\n  SWALLO1 = {{SWALLO1}}      ! 1 = Drainage and infiltration are both allowed\n                             ! 2 = Drainage is not allowed\n                             ! 3 = Infiltration is not allowed                          \n\n{{#SWITCH_SWDIVD_OPTION_1}}\n* If SWDIVD = 1 (drainage flux vertically distributed), specify the drain spacing:\n  L1 = {{L1}}                ! Drain spacing, [1..100000 m, R]\n\n{{/SWITCH_SWDIVD_OPTION_1}}\n  ZBOTDR1 = {{ZBOTDR1}}      ! Level of drainage medium bottom, [-10000..0 cm, R]\n  SWDTYP1 = {{SWDTYP1}}      ! Type of drainage medium: 1 = drain tube, 2 = open channel\n\n* Specify date DATOWL1 [date] and channel water level LEVEL1 [-10000..200, cm, R]\n* LEVEL1 is negative if below soil surface; maximum MAOWL records:\n\n{{#TABLE_DATOWLTB1}}\n  {{DATOWL1}} {{LEVEL1}}\n{{/TABLE_DATOWLTB1}}\n* End of table\n\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 3b: Drainage to level 2\n\n  DRARES2 = {{DRARES2}}      ! Drainage resistance, [10..1d5 d, R]\n  INFRES2 = {{INFRES2}}      ! Infiltration resistance, [0..1d5 d, R]\n\n* Switch, for allowance drainage/infiltration:\n  SWALLO2 = {{SWALLO2}}      ! 1 = Drainage and infiltration are both allowed\n                             ! 2 = Drainage is not allowed\n                             ! 3 = Infiltration is not allowed                          \n\n{{#SWITCH_SWDIVD_OPTION_1}}\n* If SWDIVD = 1 (drainage flux vertically distributed), specify the drain spacing:\n  L2 = {{L2}}                ! Drain spacing, [1..100000 m, R]\n\n{{/SWITCH_SWDIVD_OPTION_1}}\n  ZBOTDR2 = {{ZBOTDR2}}      ! Level of drainage medium bottom, [-10000..0 cm, R]\n  SWDTYP2 = {{SWDTYP2}}      ! Type of drainage medium: 1 = drain tube, 2 = open channel\n\n* Specify date DATOWL2 [date] and channel water level LEVEL2 [-10000..200, cm, R]\n* LEVEL2 is negative if below soil surface; maximum MAOWL records:\n\n{{#TABLE_DATOWLTB2}}\n  {{DATOWL2}} {{LEVEL2}}\n{{/TABLE_DATOWLTB2}}\n* End of table\n\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 3c: Drainage to level 3\n\n  DRARES3 = {{DRARES3}}      ! Drainage resistance, [10..1d5 d, R]\n  INFRES3 = {{INFRES3}}      ! Infiltration resistance, [0..1d5 d, R]\n\n* Switch, for allowance drainage/infiltration:\n  SWALLO3 = {{SWALLO3}}      ! 1 = Drainage and infiltration are both allowed\n                             ! 2 = Drainage is not allowed\n                             ! 3 = Infiltration is not allowed                          \n\n{{#SWITCH_SWDIVD_OPTION_1}}\n* If SWDIVD = 1 (drainage flux vertically distributed), specify the drain spacing:\n  L3 = {{L3}}                ! Drain spacing, [1..100000 m, R]\n\n{{/SWITCH_SWDIVD_OPTION_1}}\n  ZBOTDR3 = {{ZBOTDR3}}      ! Level of drainage medium bottom, [-10000..0 cm, R]\n  SWDTYP3 = {{SWDTYP3}}      ! Type of drainage medium: 1 = drain tube, 2 = open channel\n\n* Specify date DATOWL3 [date] and channel water level LEVEL3 [-10000..200, cm, R]\n* LEVEL3 is negative if below soil surface; maximum MAOWL records:\n\n{{#TABLE_DATOWLTB3}}\n  {{DATOWL3}} {{LEVEL3}}\n{{/TABLE_DATOWLTB3}}\n* End of table\n\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 3d: Drainage to level 4\n\n  DRARES4 = {{DRARES4}}      ! Drainage resistance, [10..1d5 d, R]\n  INFRES4 = {{INFRES4}}      ! Infiltration resistance, [0..1d5 d, R]\n\n* Switch, for allowance drainage/infiltration:\n  SWALLO4 = {{SWALLO4}}      ! 1 = Drainage and infiltration are both allowed\n                             ! 2 = Drainage is not allowed\n                             ! 3 = Infiltration is not allowed                          \n\n{{#SWITCH_SWDIVD_OPTION_1}}\n* If SWDIVD = 1 (drainage flux vertically distributed), specify the drain spacing:\n  L4 = {{L4}}                ! Drain spacing, [1..100000 m, R]\n\n{{/SWITCH_SWDIVD_OPTION_1}}\n  ZBOTDR4 = {{ZBOTDR4}}      ! Level of drainage medium bottom, [-10000..0 cm, R]\n  SWDTYP4 = {{SWDTYP4}}      ! Type of drainage medium: 1 = drain tube, 2 = open channel\n\n* Specify date DATOWL4 [date] and channel water level LEVEL4 [-10000..200, cm, R]\n* LEVEL4 is negative if below soil surface; maximum MAOWL records:\n\n{{#TABLE_DATOWLTB4}}\n  {{DATOWL4}} {{LEVEL4}}\n{{/TABLE_DATOWLTB4}}\n* End of table\n{{/SWITCH_NRLEVS_OPTION_4}}\n{{#SWITCH_NRLEVS_OPTION_5}}\n**********************************************************************************\n* Part 3a: Drainage to level 1\n\n  DRARES1 = {{DRARES1}}      ! Drainage resistance, [10..1d5 d, R]\n  INFRES1 = {{INFRES1}}      ! Infiltration resistance, [0..1d5 d, R]\n\n* Switch, for allowance drainage/infiltration:\n  SWALLO1 = {{SWALLO1}}      ! 1 = Drainage and infiltration are both allowed\n                             ! 2 = Drainage is not allowed\n                             ! 3 = Infiltration is not allowed                          \n\n{{#SWITCH_SWDIVD_OPTION_1}}\n* If SWDIVD = 1 (drainage flux vertically distributed), specify the drain spacing:\n  L1 = {{L1}}                ! Drain spacing, [1..100000 m, R]\n\n{{/SWITCH_SWDIVD_OPTION_1}}\n  ZBOTDR1 = {{ZBOTDR1}}      ! Level of drainage medium bottom, [-10000..0 cm, R]\n  SWDTYP1 = {{SWDTYP1}}      ! Type of drainage medium: 1 = drain tube, 2 = open channel\n\n* Specify date DATOWL1 [date] and channel water level LEVEL1 [-10000..200, cm, R]\n* LEVEL1 is negative if below soil surface; maximum MAOWL records:\n\n{{#TABLE_DATOWLTB1}}\n  {{DATOWL1}} {{LEVEL1}}\n{{/TABLE_DATOWLTB1}}\n* End of table\n\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 3b: Drainage to level 2\n\n  DRARES2 = {{DRARES2}}      ! Drainage resistance, [10..1d5 d, R]\n  INFRES2 = {{INFRES2}}      ! Infiltration resistance, [0..1d5 d, R]\n\n* Switch, for allowance drainage/infiltration:\n  SWALLO2 = {{SWALLO2}}      ! 1 = Drainage and infiltration are both allowed\n                             ! 2 = Drainage is not allowed\n                             ! 3 = Infiltration is not allowed                          \n\n{{#SWITCH_SWDIVD_OPTION_1}}\n* If SWDIVD = 1 (drainage flux vertically distributed), specify the drain spacing:\n  L2 = {{L2}}                ! Drain spacing, [1..100000 m, R]\n\n{{/SWITCH_SWDIVD_OPTION_1}}\n  ZBOTDR2 = {{ZBOTDR2}}      ! Level of drainage medium bottom, [-10000..0 cm, R]\n  SWDTYP2 = {{SWDTYP2}}      ! Type of drainage medium: 1 = drain tube, 2 = open channel\n\n* Specify date DATOWL2 [date] and channel water level LEVEL2 [-10000..200, cm, R]\n* LEVEL2 is negative if below soil surface; maximum MAOWL records:\n\n{{#TABLE_DATOWLTB2}}\n  {{DATOWL2}} {{LEVEL2}}\n{{/TABLE_DATOWLTB2}}\n* End of table\n\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 3c: Drainage to level 3\n\n  DRARES3 = {{DRARES3}}      ! Drainage resistance, [10..1d5 d, R]\n  INFRES3 = {{INFRES3}}      ! Infiltration resistance, [0..1d5 d, R]\n\n* Switch, for allowance drainage/infiltration:\n  SWALLO3 = {{SWALLO3}}      ! 1 = Drainage and infiltration are both allowed\n                             ! 2 = Drainage is not allowed\n                             ! 3 = Infiltration is not allowed                          \n\n{{#SWITCH_SWDIVD_OPTION_1}}\n* If SWDIVD = 1 (drainage flux vertically distributed), specify the drain spacing:\n  L3 = {{L3}}                ! Drain spacing, [1..100000 m, R]\n\n{{/SWITCH_SWDIVD_OPTION_1}}\n  ZBOTDR3 = {{ZBOTDR3}}      ! Level of drainage medium bottom, [-10000..0 cm, R]\n  SWDTYP3 = {{SWDTYP3}}      ! Type of drainage medium: 1 = drain tube, 2 = open channel\n\n* Specify date DATOWL3 [date] and channel water level LEVEL3 [-10000..200, cm, R]\n* LEVEL3 is negative if below soil surface; maximum MAOWL records:\n\n{{#TABLE_DATOWLTB3}}\n  {{DATOWL3}} {{LEVEL3}}\n{{/TABLE_DATOWLTB3}}\n* End of table\n\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 3d: Drainage to level 4\n\n  DRARES4 = {{DRARES4}}      ! Drainage resistance, [10..1d5 d, R]\n  INFRES4 = {{INFRES4}}      ! Infiltration resistance, [0..1d5 d, R]\n\n* Switch, for allowance drainage/infiltration:\n  SWALLO4 = {{SWALLO4}}      ! 1 = Drainage and infiltration are both allowed\n                             ! 2 = Drainage is not allowed\n                             ! 3 = Infiltration is not allowed                          \n\n{{#SWITCH_SWDIVD_OPTION_1}}\n* If SWDIVD = 1 (drainage flux vertically distributed), specify the drain spacing:\n  L4 = {{L4}}                ! Drain spacing, [1..100000 m, R]\n\n{{/SWITCH_SWDIVD_OPTION_1}}\n  ZBOTDR4 = {{ZBOTDR4}}      ! Level of drainage medium bottom, [-10000..0 cm, R]\n  SWDTYP4 = {{SWDTYP4}}      ! Type of drainage medium: 1 = drain tube, 2 = open channel\n\n* Specify date DATOWL4 [date] and channel water level LEVEL4 [-10000..200, cm, R]\n* LEVEL4 is negative if below soil surface; maximum MAOWL records:\n\n{{#TABLE_DATOWLTB4}}\n  {{DATOWL4}} {{LEVEL4}}\n{{/TABLE_DATOWLTB4}}\n* End of table\n\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 3e: Drainage to level 5\n\n  DRARES5 = {{DRARES5}}      ! Drainage resistance, [10..1d5 d, R]\n  INFRES5 = {{INFRES5}}      ! Infiltration resistance, [0..1d5 d, R]\n\n* Switch, for allowance drainage/infiltration:\n  SWALLO5 = {{SWALLO5}}      ! 1 = Drainage and infiltration are both allowed\n                             ! 2 = Drainage is not allowed\n                             ! 3 = Infiltration is not allowed                          \n\n{{#SWITCH_SWDIVD_OPTION_1}}\n* If SWDIVD = 1 (drainage flux vertically distributed), specify the drain spacing:\n  L5 = {{L5}}                ! Drain spacing, [1..100000 m, R]\n\n{{/SWITCH_SWDIVD_OPTION_1}}\n  ZBOTDR5 = {{ZBOTDR5}}      ! Level of drainage medium bottom, [-10000..0 cm, R]\n  SWDTYP5 = {{SWDTYP5}}      ! Type of drainage medium: 1 = drain tube, 2 = open channel\n\n* Specify date DATOWL5 [date] and channel water level LEVEL5 [-10000..200, cm, R]\n* LEVEL5 is negative if below soil surface; maximum MAOWL records:\n\n{{#TABLE_DATOWLTB5}}\n  {{DATOWL5}} {{LEVEL5}}\n{{/TABLE_DATOWLTB5}}\n* End of table\n{{/SWITCH_NRLEVS_OPTION_5}}\n{{/SWITCH_DRAMET_OPTION_3}}\n\n**********************************************************************************\n\n* End of .dra file!\n</code></pre>","boost":0.5},{"location":"wiki/input-files/5-dra-file/#extended_drainage","title":"Extended drainage","text":"DRFIL_EXTENDED.template <pre><code>**********************************************************************************\n* Filename: swap.dra                  \n* Contents: SWAP 4 - Input data for basic and extended drainage\n**********************************************************************************\n* Comment area:\n* Testbank of SWAP: build with template of dra-file\n*\n**********************************************************************************\n\n*** EXTENDED DRAINAGE SECTION ***\n\n**********************************************************************************\n* Part 0: General\n\n  SWDIVD = {{SWDIVD}}        ! Calculate vertical distribution of drainage flux in groundwater [Y=1, N=0]\n\n{{#SWITCH_SWDIVD_OPTION_1}}\n* If SWDIVD = 1, specify anisotropy factor COFANI (horizontal/vertical saturated hydraulic\n* conductivity) for each soil layer (maximum MAHO), [0.0001..1000 -, R]:\n  COFANI = {{COFANI}}\n{{/SWITCH_SWDIVD_OPTION_1}}\n\n* Switch to adjust upper boundary of model discharge layer\n  SWDISLAY = 0               ! switch to adjust discharge layer  [0,1,2, -, I]\n\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 0: Reference level\n\n  ALTCU = 0.0                ! Altitude of the control unit relative to reference level [-300000..300000 cm, R]\n\n**********************************************************************************\n* Part 1: drainage characteristics \n\n  NRSRF  = {{NRSRF}}         ! number of subsurface drainage levels [1..5, I]\n\n* Table with physical characteristics of each subsurface drainage level:\n* Variables RENTRY, REXIT, WIDTHR and TALUDR must have realistic values when the type of drainage medium is open\n* LEVEL   = Drainage level number [1..NRSRF, I]\n* SWDTYP  = Type of drainage medium [open=0, closed=1] \n* L       = Spacing between channels/drains [1..100000 m, R]\n* ZBOTDRE = Altitude of bottom of channel or drain [ALTCU-1000..ALTCU-0.01 cm,R]\n* GWLINF  = Groundwater level for maximum infiltration [-1000..0 cm rel. to soil surf., R]\n* RDRAIN  = Drainage resistance [1..100000 d, R]\n* RINFI   = Infiltration resistance  [1..100000 d, R]\n* RENTRY  = Entry resistance  [0..100 d, R]\n* REXIT   = Exit resistance   [0..100 d, R]\n* WIDTHR  = Bottom width of channel [0..10000 cm, R]\n* TALUDR  = Side-slope (dh/dw) of channel [0.01..5, R]\n\n{{#TABLE_DRNTB}}\n  {{LEV}} {{SWDTYP}} {{L}} {{ZBOTDRE}} {{GWLINF}} {{RDRAIN}} {{RINFI}} {{RENTRY}} {{REXIT}} {{WIDTHR}} {{TALUDR}}\n{{/TABLE_DRNTB}}\n* End of table\n\n* Switch to introduce rapid subsurface drainage [0..2, I]\n  SWNRSRF = {{SWNRSRF}}      ! 0 = No rapid drainage\n                             ! 1 = Rapid drainage in the highest drainage system (implies adjustment of RDRAIN of highest drainage system)\n                             ! 2 = Rapid drainage as interflow according to a power relation (implies adjustment of RDRAIN of highest drainage system)\n\n{{#SWITCH_SWNRSRF_OPTION_1}}\n* In case of SWRNSRF=1, specify rapid drainage\n  RSURFDEEP    = {{RSURFDEEP}} ! Maximum resistance of rapid subsurface drainage [0.001..1000.0 d, R]\n  RSURFSHALLOW = {{RSURFSHALLOW}} ! Minimum resistance of rapid subsurface drainage [0.001..1000.0 d, R]\n{{/SWITCH_SWNRSRF_OPTION_1}}\n{{#SWITCH_SWNRSRF_OPTION_2}}\n* In case of SWRNSRF=2, specify coefficients of power function\n COFINTFL = {{COFINTFL}}     ! Coefficient of interflow relation [0.01..10.0 d-1, R]\n EXPINTFL = {{EXPINTFL}}     ! Exponent of interflow relation [0.1...1.0 -, R]\n{{/SWITCH_SWNRSRF_OPTION_2}}\n\n* Switch to adjust the bottom of the model discharge layer in case of lateral (SWDIVD=1) interflow or rapid drainage (SWNRSRF=1 or SWNRSRF=2). \n* In case of SWTOPNRSRF=1) then the bottom of the highest order drainage system (ZBORDR(NUMDRAIN)) represents the max depth of the interflow.  \n SWTOPNRSRF = {{SWTOPNRSRF}} ! Switch to enable adjustment of model discharge layer [0,1, I] \n\n**********************************************************************************\n\n\n**********************************************************************************\n* Part 2: Specification and control of surface water system\n\n* Switch for interaction with surface water system [1..3, I] \n  SWSRF = {{SWSRF}}          ! 1 = No interaction with surface water system\n                             ! 2 = Surface water system is simulated with no separate primary system \n                             ! 3 = Surface water system is simulated with separate primary system\n\n{{#SWITCH_SWSRF_OPTION_2}}\n* If SWSRF=2, specify option for surface water level of secondary system [1..2, I]\n  SWSEC = {{SWSEC}}          ! 1 = Surface water level is input\n                             ! 2 = Surface water level is simulated\n\n\n{{#SWITCH_SWSEC_OPTION_1}}\n* Water level in secondary water course [ALTCU-1000..ALTCU-0.01 cm, R] as function of DATE2 [dd-mmm-yyyy] \n{{#TABLE_SECWATLVL}}\n  {{DATE2}} {{WLS}}\n{{/TABLE_SECWATLVL}}\n* End of table\n{{/SWITCH_SWSEC_OPTION_1}}\n{{#SWITCH_SWSEC_OPTION_2}}\n* Miscellaneous parameters\n  WLACT  = {{WLACT}}         ! Initial surface water level [ALTCU-1000..ALTCU cm,R]\n  OSSWLM = {{OSSWLM}}        ! Criterium for warning about oscillation [0..10 cm, R]\n\n* Management of surface water levels\n  NMPER  =  {{NMPER}}        ! Number of management periods [1..3660, I]\n\n* For each management period specify:\n* IMPER  = Index of management period [1..NMPER, I]\n* IMPEND = Date that period ends [dd-mm-yyyy]\n* SWMAN  = Type of water management 1 = fixed weir crest (see part 4c and 4d) 2 = automatic weir (see part 4e) [1..2, I]\n* WSCAP  = Surface water supply capacity [0..100 cm/d, R]\n* WLDIP  = Allowed dip of surface water level before starting supply [0..100 cm, R]\n* INTWL  = Length of water-level adjustment period (SWMAN=2 only) [1..31 d, I]\n\n{{#TABLE_MANSECWATLVL}}\n  {{IMPER_4B}} {{IMPEND}} {{SWMAN}} {{WSCAP}} {{WLDIP}} {{INTWL}}\n{{/TABLE_MANSECWATLVL}}\n* End of table\n\n* Switch for type of discharge relationship [1..2, I]\n  SWQHR = {{SWQHR}}          ! 1 = Exponential relationship\n                             ! 2 = Table\n\n{{#SWITCH_SWQHR_OPTION_1}}\n* If SWQHR=1, specify:\n  SOFCU = {{SOFCU}}          ! Size of the control unit [0.1..100000.0 ha, R]\n\n* If SWQHR=1, specify exponential discharge relation for all periods: \n* IMPER  = Index of management period [1..NMPER, I]\n* HBWEIR = Weir crest; levels above soil surface are allowed, but simulated surface water levels should remain below 100 cm above soil surface; \n*          the crest must be higher than the deepest channel bottom of the secondary system (ZBOTDR(1 or 2), [ALTCU-ZBOTDR..ALTCU+100 cm,R].\n*          If SWMAN=2, HBWEIR represents the lowest possible weir position.\n* ALPHAW = Alpha-coefficient of discharge formula [0.1..50.0, R]\n* BETAW  = Beta-coefficient of discharge formula [0.5..3.0, R]\n\n{{#TABLE_QWEIR}}\n  {{IMPER_4C}} {{HBWEIR}} {{ALPHAW}} {{BETAW}}\n{{/TABLE_QWEIR}}\n* End of table\n{{/SWITCH_SWQHR_OPTION_1}}\n{{#SWITCH_SWQHR_OPTION_2}}\n* If SWQHR=2, specify table discharge relation:\n* IMPER  = Index of management period [1..NMPER, I]\n* IMPTAB = Index per management period [1..10, I]\n* HTAB   = Surface water level [ALTCU-1000..ALTCU+100 cm, R] (first value for each period = ALTCU + 100 cm)\n* QTAB   = Discharge [0..500 cm/d, R] (should go down to a value of zero at a level that is higher than the deepest channel bottom of secondary surface water system)\n\n{{#TABLE_QWEIRTB}}\n  {{IMPER_4D}} {{IMPTAB}} {{HTAB}} {{QTAB}}\n{{/TABLE_QWEIRTB}}\n* End of table\n{{/SWITCH_SWQHR_OPTION_2}}\n{{/SWITCH_SWSEC_OPTION_2}}\n{{/SWITCH_SWSRF_OPTION_2}}\n{{#SWITCH_SWSRF_OPTION_3}}\n* If SWSRF=3, specify water levels in the primary system [max. = 52]\n* No levels above soil surface for primary system      \n\n* Water level in primary water course [ALTCU-1000..ALTCU-0.01 cm, R] as function of DATE1 [date]\n{{#TABLE_PRIWATLVL}}\n  {{DATE1}} {{WLP}}\n{{/TABLE_PRIWATLVL}}\n* End of table\n\n* If SWSRF=3, specify option for surface water level of secondary system [1..2, I]\n  SWSEC = {{SWSEC}}          ! 1 = Surface water level is input\n                             ! 2 = Surface water level is simulated\n\n{{#SWITCH_SWSEC_OPTION_1}}\n* Water level in secondary water course [ALTCU-1000..ALTCU-0.01 cm, R] as function of DATE2 [dd-mmm-yyyy] \n{{#TABLE_SECWATLVL}}\n  {{DATE2}} {{WLS}}\n{{/TABLE_SECWATLVL}}\n* End of table\n{{/SWITCH_SWSEC_OPTION_1}}\n{{#SWITCH_SWSEC_OPTION_2}}\n* Miscellaneous parameters\n  WLACT  = {{WLACT}}         ! Initial surface water level [ALTCU-1000..ALTCU cm,R]\n  OSSWLM = {{OSSWLM}}        ! Criterium for warning about oscillation [0..10 cm, R]\n\n* Management of surface water levels\n  NMPER  =  {{NMPER}}        ! Number of management periods [1..3660, I]\n\n* For each management period specify:\n* IMPER  = Index of management period [1..NMPER, I]\n* IMPEND = Date that period ends [dd-mm-yyyy]\n* SWMAN  = Type of water management 1 = fixed weir crest (see part 4c and 4d) 2 = automatic weir (see part 4e) [1..2, I]\n* WSCAP  = Surface water supply capacity [0..100 cm/d, R]\n* WLDIP  = Allowed dip of surface water level before starting supply [0..100 cm, R]\n* INTWL  = Length of water-level adjustment period (SWMAN=2 only) [1..31 d, I]\n\n{{#TABLE_MANSECWATLVL}}\n  {{IMPER_4B}} {{IMPEND}} {{SWMAN}} {{WSCAP}} {{WLDIP}} {{INTWL}}\n{{/TABLE_MANSECWATLVL}}\n* End of table\n\n* Switch for type of discharge relationship [1..2, I]\n  SWQHR = {{SWQHR}}          ! 1 = Exponential relationship\n                             ! 2 = Table\n\n{{#SWITCH_SWQHR_OPTION_1}}\n* If SWQHR=1, specify:\n  SOFCU = {{SOFCU}}          ! Size of the control unit [0.1..100000.0 ha, R]\n\n* If SWQHR=1, specify exponential discharge relation for all periods: \n* IMPER  = Index of management period [1..NMPER, I]\n* HBWEIR = Weir crest; levels above soil surface are allowed, but simulated surface water levels should remain below 100 cm above soil surface; \n*          the crest must be higher than the deepest channel bottom of the secondary system (ZBOTDR(1 or 2), [ALTCU-ZBOTDR..ALTCU+100 cm,R].\n*          If SWMAN=2, HBWEIR represents the lowest possible weir position.\n* ALPHAW = Alpha-coefficient of discharge formula [0.1..50.0, R]\n* BETAW  = Beta-coefficient of discharge formula [0.5..3.0, R]\n\n{{#TABLE_QWEIR}}\n  {{IMPER_4C}} {{HBWEIR}} {{ALPHAW}} {{BETAW}}\n{{/TABLE_QWEIR}}\n* End of table\n{{/SWITCH_SWQHR_OPTION_1}}\n{{#SWITCH_SWQHR_OPTION_2}}\n* If SWQHR=2, specify table discharge relation:\n* IMPER  = Index of management period [1..NMPER, I]\n* IMPTAB = Index per management period [1..10, I]\n* HTAB   = Surface water level [ALTCU-1000..ALTCU+100 cm, R] (first value for each period = ALTCU + 100 cm)\n* QTAB   = Discharge [0..500 cm/d, R] (should go down to a value of zero at a level that is higher than the deepest channel bottom of secondary surface water system)\n\n{{#TABLE_QWEIRTB}}\n  {{IMPER_4D}} {{IMPTAB}} {{HTAB}} {{QTAB}}\n{{/TABLE_QWEIRTB}}\n* End of table\n{{/SWITCH_SWQHR_OPTION_2}}\n{{/SWITCH_SWSEC_OPTION_2}}\n{{/SWITCH_SWSRF_OPTION_3}}\n{{/SWITCH_SWDRA_OPTION_2}}\n\n**********************************************************************************\n\n* End of .dra file!\n</code></pre>","boost":0.5},{"location":"wiki/input-files/6-bbc-file/","title":".BBC","text":"<p>The .bbc file contains settings of the bottom boundary conditions. Normally it is included within the .swp file, but can also be excluded to a separate file.</p> <p>Note</p> <p>For now, pySWAP does not include the option to create the .bbc file.</p> BBCFIL.template <pre><code>**********************************************************************************\n* Filename: swap.bbc\n* Contents: SWAP 4 - Main input data\n**********************************************************************************\n* Comment area:\n* Testbank of SWAP: build with template of bbc-file\n*\n**********************************************************************************\n\n*** BOTTOM BOUNDARY SECTION ***\n\n**********************************************************************************\n* Bottom boundary condition\n\n* Select one of the following options:\n  SWBOTB = {{SWBOTB}}        ! 1  Prescribe groundwater level\n                             ! 2  Prescribe bottom flux\n                             ! 3  Calculate bottom flux from hydraulic head of deep aquifer\n                             ! 4  Calculate bottom flux as function of groundwater level\n                             ! 5  Prescribe soil water pressure head of bottom compartment\n                             ! 6  Bottom flux equals zero\n                             ! 7  Free drainage of soil profile\n                             ! 8  Free outflow at soil-air interface\n\n* Options 1-5 require additional bottom boundary data below\n\n**********************************************************************************\n\n\n{{#SWITCH_SWBOTB_OPTION_1}}\n**********************************************************************************\n* In case of SWBOTB = 1, prescribe groundwater level\n\n* specify DATE1 [date] and GWLEVEL [cm, -10000..1000, R]:\n\n{{#TABLE_SWBOTBTB1}}\n  {{DATE1}} {{GWLEVEL}}\n{{/TABLE_SWBOTBTB1}}\n* End of table\n\n**********************************************************************************\n{{/SWITCH_SWBOTB_OPTION_1}}\n{{#SWITCH_SWBOTB_OPTION_2}}\n**********************************************************************************\n* In case of SWBOTB = 2, prescribe bottom flux\n\n* Specify whether a sinus function or a table are used for the bottom flux:\n  SW2    = {{SW2}}           ! 1 = sinus function\n                             ! 2 = table\n\n{{#SWITCH_SW2_OPTION_1}}\n* In case of sinus function (SW2 = 1), specify:\n  SINAVE = {{SINAVE}}        ! Average value of bottom flux [-10..10 cm/d, R, + = upwards]\n  SINAMP = {{SINAMP}}        ! Amplitude of bottom flux sine function [-10..10 cm/d, R]\n  SINMAX = {{SINMAX}}        ! Time of the year with maximum bottom flux [0..366 d, R]  \n{{/SWITCH_SW2_OPTION_1}}\n{{#SWITCH_SW2_OPTION_2}}\n* In case of table (SW2 = 2), specify date DATE2 [date] and bottom flux QBOT2 [-100..100 cm/d, R, positive = upwards]:\n\n{{#TABLE_SWBOTBTB2}}\n  {{DATE2}} {{QBOT2}}\n{{/TABLE_SWBOTBTB2}}\n* End of table\n{{/SWITCH_SW2_OPTION_2}}\n\n**********************************************************************************\n{{/SWITCH_SWBOTB_OPTION_2}}\n{{#SWITCH_SWBOTB_OPTION_3}}\n**********************************************************************************\n* In case of SWBOTB = 3, calculate bottom flux from hydraulic head in deep aquifer\n\n* Switch for vertical hydraulic resistance between bottom boundary and groundwater level\n  SWBOTB3RESVERT = {{SWBOTB3RESVERT}} ! 0 = Include vertical hydraulic resistance\n                             ! 1 = Suppress vertical hydraulic resistance\n\n* Switch for numerical solution of bottom flux: 0 = explicit, 1 = implicit\n  SWBOTB3IMPL = {{SWBOTB3IMPL}} ! 0 = explicit solution (choose always when SHAPE &lt; 1.0)\n                             ! 1 = implicit solution\n\n* Specify:\n  SHAPE  = {{SHAPE}}         ! Shape factor to derive average groundwater level [0..1 -, R]\n  HDRAIN = {{HDRAIN}}        ! Mean drain base to correct for average groundwater level [-10000..0 cm, R]\n  RIMLAY = {{RIMLAY}}        ! Vertical resistance of aquitard [0..100000 d, R]\n\n* Specify whether a sinus function or a table are used for the hydraulic head in the deep aquifer:\n  SW3    = {{SW3}}           ! 1 = sinus function  \n                             ! 2 = table \n\n{{#SWITCH_SW3_OPTION_1}}\n* In case of sinus function (SW3  = 1), specify:\n  AQAVE  = {{AQAVE}}         ! Average hydraulic head in underlaying aquifer [-10000..1000 cm, R] \n  AQAMP  = {{AQAMP}}         ! Amplitude hydraulic head sinus wave [0..1000 cm, R]\n  AQTMAX = {{AQTMAX}}        ! First time of the year with maximum hydraulic head [0..366 d, R]\n  AQPER  = {{AQPER}}         ! Period hydraulic head sinus wave [0..366 d, I]\n{{/SWITCH_SW3_OPTION_1}}\n{{#SWITCH_SW3_OPTION_2}}\n* In case of table (SW3  = 2), specify date DATE3 [date] and average pressure head in underlaying aquifer HAQUIF [-10000..1000 cm, R]:\n\n{{#TABLE_SWBOTBTB3A}}\n  {{DATE3}} {{HAQUIF}}\n{{/TABLE_SWBOTBTB3A}}\n* End of table\n{{/SWITCH_SW3_OPTION_2}}\n\n* An extra groundwater flux can be specified which is added to above specified flux\n  SW4   = {{SW4}}            ! 0 = no extra flux \n                             ! 1 = include extra flux\n\n{{#SWITCH_SW4_OPTION_1}}\n* If SW4 = 1, specify date DATE4 [date] and bottom flux QBOT4 [-100..100 cm/d, R]\n* QTAB is positive when flux is upward:\n\n{{#TABLE_SWBOTBTB3B}}\n  {{DATE4}} {{QBOT4}}\n{{/TABLE_SWBOTBTB3B}}\n* End of table\n\n{{/SWITCH_SW4_OPTION_1}}\n**********************************************************************************\n{{/SWITCH_SWBOTB_OPTION_3}}\n{{#SWITCH_SWBOTB_OPTION_4}}\n**********************************************************************************\n* In case of SWBOTB = 4, calculate bottom flux as function of groundwater level\n\n\n* Specify whether an exponential relation or a table is used [1..2 -,I]:\n  SWQHBOT = {{SWQHBOT}}      ! 1 = bottom flux is calculated with an exponential relation\n                             ! 2 = bottom flux is derived from a table\n\n{{#SWITCH_SWQHBOT_OPTION_1}}\n* In case of an exponential relation (SWQHBOT = 1),\n* specify coefficients of relation qbot = A exp (B*abs(groundwater level))\n  COFQHA = {{COFQHA}}        ! Coefficient A, [-100..100 cm/d, R]\n  COFQHB = {{COFQHB}}        ! Coefficient B  [-1..1 /cm, R]\n\n* If SWQHBOT = 1, an extra flux can be added to the exponential relation\n  COFQHC = {{COFQHC}}        ! Water flux (positive upward) in addition to flux from exponential relation [-10..10 cm/d, R]\n{{/SWITCH_SWQHBOT_OPTION_1}}\n{{#SWITCH_SWQHBOT_OPTION_2}}\n* In case of a table (SWQHBOT = 2),\n* specify groundwaterlevel HTAB [-10000..1000, cm, R]  and bottom flux QTAB [-100..100 cm/d, R]\n* HTAB is negative below the soil surface, QTAB is positive when flux is upward:\n\n{{#TABLE_SWBOTBTB4}}\n  {{HTAB}} {{QTAB}}\n{{/TABLE_SWBOTBTB4}}\n* End of table\n{{/SWITCH_SWQHBOT_OPTION_2}}\n\n**********************************************************************************\n{{/SWITCH_SWBOTB_OPTION_4}}\n{{#SWITCH_SWBOTB_OPTION_5}}\n**********************************************************************************\n* In case of SWBOTB = 5, prescribe soil water pressure head of bottom compartment\n\n* Specify date DATE5 [date] and bottom compartment pressure head HBOT5 [-1.d10..1000 cm, R]:\n\n{{#TABLE_SWBOTBTB5}}\n  {{DATE5}} {{HBOT5}}\n{{/TABLE_SWBOTBTB5}}\n* End of table\n\n**********************************************************************************\n{{/SWITCH_SWBOTB_OPTION_5}}\n\n* End of input file .BBC!\n</code></pre>","boost":0.5},{"location":"blog/archive/2024/","title":"2024","text":""},{"location":"blog/category/news/","title":"News","text":""}]}